count	text
196959	}
32168	{
19483	else {
17010	return;
11602	break;
10271	do {
8968	return 0;
6935	local_8 = 0;
6641	status
5761	ZY=t
5332	int in_ECX;
4738	source
4696	LVIN
3983	int local_8;
3960	(**(code **)(*DAT_2121b220 + 0x10))(0);
3957	_^Y[]
3680	short sVar2;
3672	short sVar1;
3519	int iVar1;
3306	return uVar1;
3301	if (local_8 != 0) {
3019	QRhh
2902	return local_8;
2892	d$_^Y[]
2867	Error\FC In
2834	undefined4 local_8;
2810	PTH0
2646	default:
2547	SQRVW
2530	if (sVar2 == 0) {
2486	d$=t
2438	int iVar2;
2407	int *piVar1;
2404	VIDS
2290	undefined4 uVar1;
2279	code
2155	int iVar3;
2139	Error\FC Out(F)
2112	Return String
2110	Timeout
2064	case 1:
2059	code@0
2047	Mode
2019	_^ZY[]
2018	Enabled?
1992	FUN_2102a4c0();
1988	undefined4 uVar2;
1988	(**(code **)(*DAT_2121b220 + 8))(0xffffffff,&local_8);
1944	return sVar1;
1930	Error Flag
1920	FPHP
1893	Error Message
1880	Cal Mode
1845	BDHP
1836	Errant Test
1827	@ Error\FC Out
1824	Test Leads?
1784	QRhhh
1772	if (local_8 == 0) {
1760	piVar1 = param_1;
1734	case 2:
1720	uint uVar1;
1696	sVar2 = getDevicePtr(param_1,&param_1);
1660	controller
1660	VXI base addr
1649	VXI logical addr
1638	return 0xd8ed;
1627	send mode
1627	VXI model code
1624	local_c = 0;
1618	return sVar2;
1604	case 4:
1597	timeout
1594	VXI manu ID
1583	GPIB addr
1583	GPIB-VXI addr
1572	initialized
1572	GPIB term char
1564	return -0x28a3;
1561	GPIB term char en
1561	GPIB-VXI map space
1561	I/O protocol
1550	user data
1550	FDC channel
1519	ZY=tA
1510	Status Cluster
1507	receive mode@
1484	GPIB boardl
1477	MS Sans Serif
1454	int iVar4;
1452	return -0x2713;
1434	undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
1430	undefined2 uVar1;
1427	PTAB
1426	case 6:
1420	Tests to Performo
1408	ExceptionList = local_14;
1406	return -0x2a3a;
1396	VXI slota
1390	/* WARNING: Control flow encountered bad instruction data */
1390	/* WARNING: Bad instruction - Truncating control flow here */
1390	halt_baddata();
1385	uint uVar2;
1380	short __thiscall
1378	@0Current Teste
1374	FDC modea
1374	map basea
1366	short sVar3;
1365	undefined4 local_c;
1363	VXI map IDa
1360	Test Sequence @@
1343	error in (no error)
1340	int iVar5;
1340	void *local_14;
1340	int *in_ECX;
1338	YXPQ
1336	undefined *puStack_10;
1336	undefined *puStack_c;
1336	puStack_10 = &DAT_211d8630;
1336	local_14 = ExceptionList;
1336	ExceptionList = &local_14;
1324	case 3:
1304	return 0xd5c6;
1282	VWQQWV
1282	d$Y_^
1271	error out
1264	map sizea
1236	uint uVar3;
1220	if (sVar2 != 0) {
1213	undefined2 extraout_var;
1209	@!Error\FC Out
1202	_^[]
1195	int local_c;
1183	QRhP
1180	return 0xd8e9;
1178	Error\FC In(F)
1169	byte count
1152	Clr Buf?@
1150	case 0:
1140	GPIB error
1134	case 5:
1116	mode
1083	undefined4
1082	LVINLBVW
1069	instr handle in
1041	return uVar2;
1025	@0Input String
1002	return sVar3;
1000	if (sVar1 == 0) {
985	local_10 = 0;
968	undefined4 local_10;
962	undefined4 local_14;
950	uint local_8;
939	undefined4 uVar3;
931	;
914	case 0xd:
910	case 10:
888	Clr Buf?
884	int iVar6;
882	local_14 = 0;
873	RSRC
870	undefined4 local_18;
855	uint uVar4;
846	short sVar4;
837	int local_10;
836	|$$u
830	if (sVar3 == 0) {
824	return 1;
820	undefined4 param_5)
810	local_8 = 0xffffffff;
801	data string
800	case 8:
795	count
789	UUT Comm.viW
780	undefined4 *in_ECX;
778	return -0x278b;
778	EPV
769	return uVar3;
766	Ep_^Y[]
758	*param_3 = 0;
757	UUT Comm.vi
752	if (((sVar1 < -11000) || (((-10000 < sVar1 && (sVar1 < 10000)) && (sVar1 != 0)))) ||
752	(11000 < sVar1)) {
751	port number
750	case 0xe:
744	sVar1 = -0x271d;
744	return iVar2;
740	return sVar4;
739	RSID
738	return 0xd75d;
734	int local_14;
732	local_20 = param_1;
726	d$ZY
725	if (iVar1 != 0) {
711	Test Name
710	case 7:
708	undefined4 *puVar3;
708	if (sVar3 != 0) {
706	return -0x2717;
706	L$ Qh
702	if (sVar4 != 0) goto LAB_211d47e9;
688	0RSRC
684	undefined2 extraout_var_00;
679	LVCC
672	_RPC_MESSAGE local_100;
672	_MIDL_STUB_MESSAGE local_d4;
672	RPC_BINDING_HANDLE local_20;
672	NdrSendReceive(&local_d4,local_d4.Buffer);
672	if ((local_100.DataRepresentation & 0xffff) != 0x10) {
672	int unaff_EBP;
672	NdrFreeBuffer((PMIDL_STUB_MESSAGE)(unaff_EBP + -0xd0));
671	Mode 0(All)
668	undefined1 *local_1c;
668	short sVar5;
668	no error
668	Symbols 0(All)
665	HQRhhh
660	undefined4 local_1c;
660	int iVar7;
658	if (iVar2 != 0) {
658	Message
658	Mode 2(Ind)
657	undefined4 uVar4;
655	Mode 1(Cap)
654	local_18 = 0;
644	case 0xf:
644	if (sVar1 != 0) {
644	Symbols 2(Ind)
641	Symbols 1(Cap)
632	# Cap Ranges
632	# Ind Ranges
630	*param_4 = 0;
627	d$=tA
622	local_1c = 0;
621	if (iVar1 == 0) {
619	uVar4 = 0;
615	vers
611	t$(=
608	undefined4 param_5,undefined4 param_6,undefined4 param_7)
604	if (iVar2 == 0) {
603	address
602	source ("")
600	DFDS
598	*/
598	case 9:
598	LIds
595	Input String
592	d$ZY_^ZY[]
589	Instr Handle Indicator.ctl
588	return iVar3;
586	if (sVar5 == 0) {
582	return local_24;
579	uVar3 = 0;
575	if (param_4 == 0) {
575	D$ =
574	if (sVar4 != 0) {
570	return 0xd734;
570	undefined4 local_20;
569	uint uVar6;
568	$hPh
568	GPRF
564	GlobStat.viW
559	ERROR
554	return -0x28cc;
554	Instr Source.ctl
550	while( true ) {
548	undefined2
546	HIST
544	*param_2 = 0;
541	return uVar4;
538	VTL Global.vi
538	ZY=u
536	if (iVar3 == 0) {
536	short sVar6;
532	undefined4 param_5,undefined4 param_6)
532	hhUh
532	QRhhhVh
529	uVar2 = 0;
526	coder@0
524	local_1c = &stack0xffffffc8;
522	if (param_2 == 0) {
519	if (iVar5 == 0) {
519	ICON
516	uint uVar5;
510	uint local_c;
510	GlobStat.vi
510	VICD
510	DLDR
508	undefined4 local_24;
508	uVar2 = FUN_2100dee0(*(undefined4 *)(in_ECX + 4));
504	LIfp
503	uVar1 = 0;
501	undefined4 *puVar1;
501	Instr Error In Cluster.ctl
500	switch(param_1) {
499	InstrUse
498	goto LAB_210ee001;
498	LIbd
497	i386
497	ABORT?.vi
496	return 0xffffd5c6;
495	uVar6 = 0;
494	New Occurrencer@
490	int local_18;
489	Port Width
486	char cVar1;
485	return local_c;
484	HANDLE hDevice;
484	DWORD dwIoControlCode;
484	DWORD nInBufferSize;
484	DWORD nOutBufferSize;
484	LPOVERLAPPED lpOverlapped;
484	lpOverlapped = (LPOVERLAPPED)0x0;
484	hDevice = (HANDLE)FUN_21002400();
484	int iVar8;
483	System
483	ffff
483	3.1b4
483	instr vtl global
482	param_1 = 0;
482	if (iVar6 == 0) {
482	=t$f;
482	W!f;
482	Pf;Y
482	l$SQVW
482	L$$=
482	t ;]Tu
482	Epf;
482	hUh
482	|$(=
482	WVhUh
482	gencode.cGenRangeCheck
482	gencode.cGenCopyProcs1
482	gencode.cGenCopyProcs2&
482	gencode.cGenDefaultProc
479	Instr Handle Control.ctl
478	if (param_3 == 0) {
478	Write/Read
477	Instr Error Out Cluster.ctl
476	local_24 = 0;
473	Initialize?
472	sVar3 = 0;
472	return 0xffffd8ed;
472	Input
469	uint local_10;
468	if (iVar4 == 0) {
468	lpBytesReturned,lpOverlapped);
466	local_20 = 0;
466	if (local_24 != 0) {
465	undefined4 uVar5;
465	ff33
465	33ff
464	DeviceIoControl(hDevice,dwIoControlCode,lpInBuffer,nInBufferSize,lpOutBuffer,nOutBufferSize,
454	return sVar5;
453	DSTM
449	Abort?
448	undefined4 param_9,undefined4 param_10,undefined4 param_11,undefined4 param_12,
447	FTAB
445	3333
445	Current Test
444	case 0x12:
443	Tests to Perform
442	instr handle out
439	platGlob.vi
436	undefined4 local_24 [2];
436	return param_1;
434	int *piVar2;
434	_^f3
432	LPDWORD lpBytesReturned;
432	return uVar15;
428	T_Setup.vi
426	short local_8;
424	);
424	return local_24[0];
422	Test Sequence$@@
420	sVar2 = 0;
420	return local_8 & 0xffff;
420	return iVar1;
420	Receive.vi
418	4882TMO.vi
417	STRG
414	Miles S. Mondt
411	uVar7 = 0;
410	case 0xb:
409	ZY_^ZY[]
407	gencode.cGenCopyProcs3
404	local_8 = local_8 + 1;
402	Send.vi
396	undefined2 uVar2;
396	/* WARNING: Treating indirect jump as call */
394	uint uVar7;
394	field
393	Open GPIB Driver.vi
388	uVar5 = 0;
388	return uVar6;
388	if ((param_1 & 1) != 0) {
388	/* public: virtual short __thiscall
388	SShUh
388	[_^Y[]
387	MakeAddr.vi
387	Instr
386	if ((short)uVar15 != 0) {
386	pattern
386	error code
384	return (int)sVar2;
384	int local_1c;
380	undefined4 *puVar4;
380	local_d4.Buffer = local_d4.Buffer + 2;
380	param_2 = 0;
377	QELM
376	case 0x1e:
376	daqDevice *in_ECX;
376	puVar3 = local_24;
372	undefined2 extraout_var_01;
372	return uVar1 & 0xffff0000;
372	sVar4 = 0;
372	ushort uVar1;
372	GetDevInfoShort.vi
368	return -0x2803;
368	*param_2 = 0x78;
366	int local_20;
366	LIvi
364	switch(param_2) {
364	if (iVar2 < 1) {
364	WAIT.VI
363	Beep.vi
362	case 0x30:
362	GetDevInfoLong.vi
358	InitVXIlibrary.vi
357	uint local_14;
357	1QRP
356	*(undefined4 *)local_d4.Buffer = param_2;
356	if (param_3 != 0) {
355	iVar3 = 0;
352	WSrd.vi
350	WSwrt.vi
348	undefined4 uVar6;
348	case 0x16:
348	if (param_2 != 0) {
347	CPTM
346	case 0x20:
346	DIO_R-W.VI
344	if (param_3 == 1) {
344	error
343	d$=
342	*param_5 = 0;
342	if (param_4 != 0) {
342	TRec
340	return local_10;
340	undefined4 param_9)
340	void *in_ECX;
340	return iVar4;
338	undefined4 local_2c;
338	return 0xd8a0;
338	if (param_4 == 1) {
338	if (local_c == 0) {
337	Instr Read.vi
336	uint uVar8;
336	uint local_18;
336	return 0xd8d3;
336	Instr Initialize Interface.vi
335	Core GPIB Read.vi
332	Core GPIB Write.vi
331	undefined4 *puVar2;
331	IST_WT_A.VI
330	int iVar9;
330	case 0x14:
328	case 0x21:
328	(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
328	case 0x32:
326	Instr Write.vi
324	case 0xc:
324	Port Number@
323	Instr Open.vi
323	Voltage Reading
322	General Error Handler.vi
321	Delay in ms
320	if (sVar5 != 0) {
318	?f""
317	retcount
317	timeout (488.2 global)
316	ushort uVar2;
314	undefined4 local_28;
314	task ID out
313	local_2c = 0;
312	double dVar1;
312	int local_24;
309	uint local_20;
308	if (param_1 == 0) {
308	mode@
307	uint local_1c;
306	final count
304	sVar3 = sVar3 + 1;
304	sVar5 = 0;
303	if (uVar2 == 0) {
303	Enabled?(T)
302	undefined2 *puVar1;
302	if (sVar4 == 0) {
302	else if (local_8 == 0) {
302	device
302	Run Test?
300	*(undefined2 *)local_d4.Buffer = param_2;
300	local_30 = 0;
300	*puVar1 = uVar2;
297	} while( true );
296	d$f
296	Reading Command
295	model coded
293	if (iVar4 != 0) {
292	local_8 = 1;
292	wwwwwwwwwwwwww
290	RD8840A.VI
288	local_c = local_c + 1;
288	undefined4 *lpInBuffer;
288	undefined4 *lpOutBuffer;
288	lpBytesReturned = &param_1;
288	*param_3 = 1;
288	param_1 = param_1 + 1;
287	iVar4 = 0;
286	undefined4 local_30;
286	_^[
285	shortvalue
284	dwIoControlCode = 0xabcd2000;
284	if (lVar2 == 0) {
284	Fluke 8840A.vi
284	C.F. Value
283	QRRWP
282	uVar10 = 0;
278	uVar6 = uVar6 + 1;
277	bVar1 = true;
276	short *psVar1;
276	short local_c;
275	int *piVar3;
275	xxxxx
274	uVar2 = uVar2 + 1;
274	short sVar7;
273	data
272	undefined4 param_9,undefined4 param_10)
270	ushort uVar3;
270	return uVar7;
270	refnum
269	) {
269	undefined4 uVar7;
268	iVar2 = 0;
268	uVar1 = param_1;
268	return uVar5;
268	undefined1 local_6 [2];
268	int iVar10;
268	DIO Port Config.vi
266	Error\FC InPTH0
265	uVar8 = 0;
265	SETLD_RD.VI
264	if (param_1 != 0) {
264	*param_4 = 1;
264	icl4
263	refnumf
263	address (NOADDR)
262	long lVar2;
262	byte bVar1;
262	C.F. Index
261	Arial
260	sVar4 = sVar4 + 1;
259	Oldest compatible LabVIEW.
258	if (local_10 != 0) {
258	*param_6 = 0;
258	_^VW
256	bVar1 = false;
256	undefined2 extraout_var_02;
256	return uVar2 & 0xffff0000;
256	duration (msec) - ignored
255	intensity (0-255) - ignored
255	dfdP0
255	txdP0
254	case 0x1c:
254	undefined4 *puVar6;
254	fVfWfU
254	f]f_f^f
254	gencode.cGenDispatchEntry
252	case 0x31:
252	sVar2 = sVar2 + 1;
252	if (sVar4 < 0) goto LAB_21190eec;
250	puVar4 = puVar4 + 1;
249	if (iVar3 != 0) {
249	Meter Handle In
249	IUVI
248	long __thiscall
248	Settled Value
247	Meter Handle Out
247	Function Mode
246	undefined2 uVar3;
246	ushort uVar4;
244	local_28 = 0;
244	if (param_3 == -1) {
243	FL 884XX Initialize.vi
242	return sVar6;
242	param_3 = 0;
242	param_2 = param_2 + 1;
241	char cVar2;
241	packed address
240	if (sVar6 == 0) {
240	uVar3 = uVar3 + 1;
240	ZYQR
239	local_14 = 1;
239	Range
237	(bool) status: TRUE if an error has occurred.
237	(i32) code: the error code associated with an error.
237	A value of 0 means no error, a negative value is an
237	error, and a positive value is a warning.
237	error occurred, usually the name of the VI.
236	NdrGetBuffer(&local_d4,local_d4.BufferLength,param_1);
236	case 0x18:
236	sVar6 = sVar6 + 1;
236	if (iVar5 != 0) {
236	_memDelete(in_ECX);
235	bool bVar1;
234	undefined4 local_44;
234	} while (iVar7 != 0);
234	# Smpl
232	undefined2 uVar4;
232	undefined2 *puVar2;
232	undefined2 in_stack_0000000a;
232	undefined1 local_c [4];
232	iVar5 = iVar5 + -1;
232	if (0 < param_2) {
232	Read from Digital Port.vi
232	YXWh
232	GPIB Card
231	Open Serial Driver.vi
230	iVar5 = 0;
230	sVar6 = 0;
230	if (lVar3 == 0) {
230	Write to Digital Port .vi
229	wwww
229	Serial Port Read.vi
229	code0@
228	undefined4 param_9,undefined4 param_10,undefined4 param_11)
228	sVar1 = 0;
228	uVar4 = uVar4 + 1;
228	Trigger Mode
227	}|u
226	if (local_c != 0) {
226	int iVar11;
226	return (int)sVar1;
226	if (param_5 == 0) {
226	DIO Port Read.vi
226	serpConfig.vi
224	uVar9 = 0;
224	return (undefined4 *)0x0;
224	iVar1 = iVar2;
224	T$ QRP
223	Bytes At Serial Port.vi
222	int local_28;
222	short sVar8;
222	iVar7 = iVar7 + -1;
222	LVSB
221	DIO Port Write.vi
220	if (param_2 == 1) {
220	case 0x33:
220	lVar2 = tPIMMblockReferenceBase::allocateMemory
220	port width (8)
219	secondary address
218	uint *puVar1;
218	return 0xd68f;
218	if (local_10 == 0) {
216	undefined4 local_3c;
216	return -0x2971;
216	local_c = 1;
216	return -0x2970;
216	ssprintf(s__s__s__s__2120a584,s_j__drvsrc_ALL_nidaq_e_series_wal_2120a590,s_ssAssert_2120a5c4,
216	s_nodeID_>__0____nodeID_<__tWRM::k_2120a5d0);
216	(**(code **)(*piVar1 + 0x24))
216	goto switchD_2119a59b_default;
215	long lVar1;
215	int *piVar4;
214	local_10 = 1;
214	return local_14;
214	double dVar2;
214	SND_CF&V.vi
214	FPTD
213	# Milliseconds
213	Tahoma
212	byte bVar2;
212	iVar1 = param_1;
212	uVar1 = (uint)(param_1 & 0xff00 | *(ushort *)(in_ECX + 0x2c));
212	if (local_14 != 0) {
212	puVar3 = puVar3 + 1;
212	} while (iVar5 != 0);
212	case 0x40:
212	if (local_8 != 1) {
212	ETPU
211	undefined4 uVar8;
209	Error\FC In@0
208	undefined1 local_10 [4];
208	return uVar3 & 0xffff0000;
208	0driver names
208	address error
207	uint uVar10;
207	undefined2 uVar5;
206	uint uVar9;
206	uVar5 = uVar5 + 1;
206	local_34 = 0;
206	iVar19 = iVar19 + 1;
206	$hUh
205	URP
204	undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8)
204	undefined4 *puVar8;
204	if (sVar6 != 0) {
204	void *pvVar3;
203	uVar7 = uVar7 + 1;
202	sVar5 = sVar5 + 1;
200	undefined2 extraout_var_03;
200	uVar10 = uVar10 + 1;
200	local_10 = local_10 + 1;
200	return 0xffffd7fd;
199	CPST
199	1st Rdng?
198	CALB_SET.VI
198	E_^Y[]
198	GPIB board
197	488.2 timeout
197	logical address
196	byte bVar3;
196	param_3 = param_3 + 1;
196	return uVar4 & 0xffff0000;
196	return 0xd8e8;
196	iVar2 = (int)sVar1;
195	uint local_24;
195	error - ignored @
195	,DDOD
194	puVar8 = puVar8 + 1;
194	puVar6 = puVar6 + 1;
194	if (iVar7 == 0) {
194	sourceL
194	task ID
194	line mask
194	Device
193	codeM
193	CPMp
192	undefined4 uVar9;
192	local_d4.MaxCount = param_5;
192	lVar3 = tPIMMblockReferenceBase::allocateMemory
192	for (iVar5 = 7; iVar5 != 0; iVar5 = iVar5 + -1) {
192	case 0x60:
192	xBCos
192	coder
190	*param_3 = 2;
190	iVar6 = iVar6 + -1;
190	Boolean
190	iteration (0:initialize)
188	sVar7 = 0;
188	undefined2 *lpInBuffer;
188	INSTR_WT.VI
188	return count
188	Settling Time(mS)
187	VXI map ID
187	FDC mode
187	VXI slot
187	map base
186	case 0x10:
186	GPIB boardd
185	MQV
185	RS-232 Communications.vi
185	ZY=u0
185	Status_Glob.vi
184	case 0x15:
184	undefined2 *lpOutBuffer;
184	*param_1 = 0;
184	if (pvVar3 == (void *)0x0) {
184	GPIB Address
184	# Tries(2)
183	codeP0
182	undefined4 local_38;
182	undefined4 local_48;
182	*param_7 = 0;
182	local_38 = 0;
182	} while (iVar6 != 0);
182	status4
181	uint local_28;
181	/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */
180	if (-1 < sVar2) {
180	local_d4.Buffer = local_d4.Buffer + 6;
180	*param_8 = 0;
180	undefined4 local_34;
180	short *psVar2;
180	switch(param_3) {
180	iVar2 = iVar1;
180	uVar7 = (**(code **)(iVar5 + 0x7c))(&local_8);
180	gpibdrv
179	iVar4 = iVar4 + -1;
179	String Read.vi
178	undefined4 local_54;
178	undefined4 local_50;
178	if (iVar6 != 0) {
178	*(undefined2 *)
178	float fVar1;
178	sVar4 = -0x28cc;
176	if (sVar2 < 0) {
176	int iVar13;
176	*param_2 = 1;
176	int *local_8;
176	if (-1 < sVar3) {
176	else if (param_3 == 2) {
176	*param_2 = 0xd3;
176	Outputi
175	Serial Port Write.vi
175	UUT_BEEP.vi
175	GPIB addresse
175	longvalue
175	primary address
175	Disabled
174	local_3c = 0;
174	if ((short)uVar4 != 0) {
174	long local_8;
174	String Write.vi
173	} while (iVar2 != 0);
173	;QRP
172	*(undefined2 *)(local_d4.Buffer + 4) = param_3;
172	short local_10;
171	int local_2c;
170	iVar6 = 0;
170	undefined4 local_40;
170	int local_30;
170	local_8 = (int)sVar1;
170	# Smpls(3)
168	if (uVar1 != 0) {
168	uVar2 = ftol();
168	void *pvVar7;
168	if (sVar4 == -0x272f) {
168	serpOpen.vi
168	error?
168	code out
167	;hhUh
166	*param_3 = 3;
166	ushort uVar5;
166	undefined4 local_58;
166	undefined4 local_4c;
166	ABORT?.viU
165	map size
165	Devicei
164	int *piVar5;
164	*(undefined2 *)(local_d4.Buffer + 2) = param_3;
164	undefined4 *puVar5;
164	if (uVar2 != 0) {
164	else if (iVar1 == 0) {
164	d$_^ZY[]
163	undefined2 *puVar4;
163	[error source] (" ")
163	P/F_Glob.vi
162	case 0x1a:
162	uint local_34;
162	1ST_READ.vi
161	iVar2 = iVar2 + -1;
160	(piVar1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9,param_10,
160	return 0xd8eb;
160	*(undefined4 *)(local_d4.Buffer + 4) = param_3;
160	case 0x17:
160	uint local_2c;
160	if (param_1 == 1) {
160	if ((short)uVar2 == 0) {
160	local_50 = 0;
160	*param_2 = 0x12;
160	function (Vdc:0)
160	port width
160	VIVI
160	DSDS
158	local_44 = 0;
158	short sVar9;
158	if ((short)uVar3 == 0) {
158	void *pvVar2;
158	port select
158	XQRP
156	case 0x11:
156	case 0x13:
156	uVar8 = uVar8 + 1;
156	undefined1 local_14 [4];
156	case 0x44:
156	goto LAB_211d47e9;
155	Standard Deviation.vi
155	output refnum
154	undefined2 *puVar3;
154	case 100:
154	iVar2 = param_1;
154	local_10 = local_14;
154	ffffffffffffff
154	++++++++++++++++++++++
154	Port Number
154	URf
153	receive mode
153	Optional Expec. Val.
152	undefined4 param_13,undefined4 param_14)
152	return 0xd8e6;
152	return 0xd8e4;
152	return 0xd738;
152	} while (iVar4 != 0);
152	return uVar10;
152	if (0 < sVar4) {
152	iVar3 = iVar2;
152	else if (iVar3 == 0) {
152	[exception code]
151	Error\FC In"
150	double dVar3;
150	undefined1 local_18 [4];
150	local_1c = local_1c + 1;
150	monnie
150	trigger mode (cont:0)
150	line direction map
148	(*pcVar1)();
148	local_c = 2;
148	*param_4 = uVar2;
148	return sVar7;
148	return -0x2718;
148	return -0x2976;
148	(string) source:  an indication of where an
148	T_Setup.viV
147	measurement
146	ushort uVar6;
146	undefined1 local_8 [4];
146	undefined4 local_64;
146	iVar4 = *piVar1;
145	@ Error\FC Outu
145	Delay in ms@
144	undefined4 param_9,undefined4 param_10,undefined4 param_11,undefined4 param_12)
144	local_d4.Buffer = local_d4.Buffer + 4;
144	undefined1 local_8 [2];
144	local_40 = 0;
144	if (param_5 != 0) {
144	return 0xd8ea;
144	piVar1[1] = (int)s_j__drvsrc_ALL_nidaq_e_series_wal_212090e8;
144	local_8 = iVar2;
144	local_14 = (uint *)((int)local_14 + 1);
144	(I32)
144	[user-defined descriptions]
144	d$hh
143	URV
143	numeric GPIB status
143	PWRtest.VIV
143	EdQRh
142	iVar3 = (int)sVar2;
142	if ((short)param_2 == 0) {
142	local_58 = 0;
142	param_2 = param_2 + -1;
142	else if (param_3 == 3) {
142	Relay Settle Time(mS)
142	COMP_CF.vi
142	on mac?
142	async I/O?
141	undefined4 *puVar7;
141	APRX_EQL.vi
141	E\QRhU
141	WVhU
141	L$ QhU
141	d:\automated\lv51\lvsource\gencode.cGenCopyProcs1
141	d:\automated\lv51\lvsource\gencode.cGenCopyProcs2$
141	d:\automated\lv51\lvsource\gencode.cGenCopyProcs3n
141	d:\automated\lv51\lvsource\gencode.cGenDefaultProc
140	undefined2 extraout_var_04;
140	daqDevice::operator_delete(in_ECX);
140	return 0xffffd734;
140	if (uVar6 != 0) {
140	sVar7 = sVar7 + 1;
140	if (param_2 != 1) {
140	if (sVar3 < 0) {
140	if ((short)local_8 == 0) {
140	if ((short)local_c == 0) {
140	return -0x2716;
140	local_1c = 1;
140	Read Lines From File.vi
140	source out
139	SQRVWf
139	d$ZYf
138	iVar1 = 0;
138	byte bVar4;
138	undefined4 local_5c;
138	*(byte *)(param_1 + 0x789 + (int)(short)local_c) =
138	*(byte *)(param_1 + 0x789 + (int)(short)param_2) =
138	[exception action] (none:0)
138	LVSR
137	if (bVar1) {
136	case 0x2f:
136	uVar1 = param_2;
136	short local_14;
136	if (-1 < sVar1) {
136	return 0xd690;
136	switch(param_4) {
136	if (uVar3 != 0) {
136	uVar6 = 1;
136	uVar3 = (**(code **)(iVar5 + 0x7c))(&local_8);
136	exdP0
134	if (sVar8 != 0) {
134	int iVar12;
134	undefined1 local_1c [4];
134	pvVar4 = (void *)0x0;
134	if (iVar11 == 0) {
134	input error
133	uint uVar11;
133	iVar4 = iVar4 + 1;
132	uVar1 = (int)*(short *)(in_ECX + 0x2c) | param_1 & 0xffffff00;
132	if ((short)param_2 == 1) {
132	FUN_21185130(uVar1,local_14 & 0xffff,*local_c);
132	iVar7 = 0;
132	short *psVar3;
132	case 0x2d:
132	local_54 = 0;
132	if (puVar4 != (undefined4 *)0x0) {
132	switch(param_5) {
132	for (sVar13 = param_8; sVar13 != 0; sVar13 = sVar13 - 1) {
132	if ((sVar5 < 0) || (7 < sVar5)) goto LAB_211d1434;
132	status`
132	Status Cluster In
132	SETLD_RD.VIW
132	Tolerance
131	undefined2 in_stack_0000000e;
131	busaddress list
130	param_1 = param_1 + -1;
130	return 0xd754;
130	else if (param_4 == 2) {
130	FUN_21136340(uVar7);
130	local_c = 0x18;
130	Test data out
129	uVar2 = param_1;
129	Close File+.vi
129	f=t7U
128	case 0x1f:
128	local_8 = in_ECX;
128	iVar3 = param_1;
128	char cVar3;
128	return 0xd5a8;
128	short local_6;
128	if (param_8 == 0) {
128	local_48 = 0;
128	puVar3 = (undefined4 *)0x0;
128	iVar2 = *piVar1;
128	(*(undefined4 *)(in_ECX + 4),*(undefined4 *)(in_ECX + 8),
128	FUN_21124170(&param_3);
128	specific reset ?
128	_^ZY[
128	HLabl
128	Returned Value
127	uint local_38;
127	EPf
127	Oldest compatible LabVIEW.M
126	int local_38;
126	iVar9 = iVar9 + -1;
126	undefined1 uVar1;
126	sVar1 = ftol();
126	uint local_30;
126	uVar11 = 0;
126	(**(code **)(**(int **)((int)extraout_ECX + 0x163) + 0x20))();
126	if (sVar5 < 0) goto LAB_21190eec;
124	undefined4 param_13,undefined4 param_14,undefined4 param_15,undefined4 param_16,
124	local_d4.Buffer = local_d4.Buffer + 8;
124	*(undefined2 *)(local_d4.Buffer + 4) = param_4;
124	ushort uVar7;
124	if ((short)uVar2 != 0) {
124	local_8 = local_8 + -1;
124	return (float10)0.0;
124	iVar11 = 0;
124	} while (param_2 != 0);
124	*param_4 = 2;
124	if ((short)uVar7 != 0) {
124	return puVar4;
124	(**(code **)(**(int **)(in_ECX + 0x157) + 0x20))
124	"fQ&gf
124	file size (bytes)
124	read buffer
122	undefined4 local_60;
122	local_5c = 0;
122	statusH
122	Load Select
121	puVar5 = puVar5 + 1;
121	fP&gf
121	Description
120	param_11);
120	*(undefined4 *)(local_d4.Buffer + 8) = param_4;
120	*param_9 = 0;
120	return local_2c;
120	iVar3 = iVar3 + 1;
120	double local_c;
120	return (uint)param_2 & 0xffff0000;
120	if ((short)uVar3 != 0) {
120	if ((short)local_c != 0) {
120	void *pvVar1;
120	puVar4 = (undefined4 *)0x0;
120	iVar3 = iVar1;
120	uVar3 = (**(code **)(iVar1 + 0x7c))(&local_8);
120	(*(undefined4 *)((int)in_ECX + 0x14f),&local_8);
120	local_38 = puVar5;
120	iVar6 = FUN_210f56c0();
120	else if (param_4 == 3) {
120	(int)local_1c * 0x2e) + (int)local_c * 4) +
120	(int)local_20 * 2);
119	type of dialog (OK msg:1)
119	oldP0
118	undefined2 local_c;
118	return -0x271a;
118	*puVar2 = 0;
118	local_18 = local_18 + 1;
118	local_14 = local_14 + 1;
118	if ((short)uVar6 != 0) {
118	if ((lVar1 == 0) &&
118	s_ssAssert_2120a5c4,s_nodeID_>__0____nodeID_<__tWRM::k_2120a5d0);
118	CONCAT22((short)((uint)iVar3 >> 0x10),
118	LEADSHRT.vi
118	(cluster) error out:  a cluster containing error information.  If error in indicated an error, error out contains the same error information.  Otherwise, it describes the error status of this VI.  Use the General Error Handler utility VI to check the error at the end of your diagram.  The error out cluster contains the following parameters:
118	,QRhP
118	ZYQRhh
118	t hh
117	,Cosm
117	qwwww
117	Pass/Fail
117	FC In
116	short *psVar4;
116	undefined2 extraout_var_05;
116	DWORD local_8;
116	if ((short)local_10 != 0) {
116	if (param_7 == 0) {
116	short local_18;
116	return (uint)uVar3 << 0x10;
116	int *piVar6;
116	if ((short)uVar10 != 0) {
116	if (param_4 != 1) {
116	*param_2 = -0x2a58;
116	case 0x23:
116	iVar5 = **(int **)((int)in_ECX + *psVar12 * 4 + 0x1fa);
116	icl8
116	IST_WT_A.VIW
116	DTHP
115	long lVar3;
115	local_18 = 1;
115	EEPROM.VI
115	GET_CF.vi
115	string read
115	@0StatusGlobalg
114	param_10);
114	bVar2 = true;
114	int local_34;
114	param_4 = 0;
114	if (uVar14 == 0) {
114	uVar3 = ftol();
114	*param_4 = 4;
114	local_4c = 0;
114	piVar9[1] = (int)s_j__drvsrc_ALL_nidaq_e_series_wal_212090e8;
114	return -0x2865;
114	(**(code **)(**(int **)((int)extraout_ECX + 0x163) + 0x44))();
114	6.0rc5
113	parity error byte
113	@LIvi
113	Max NSTD@
113	4QRhP
112	code *pcVar1;
112	undefined2 in_stack_00000006;
112	param_10,param_11,param_12,param_13,param_14,param_15,param_16,param_17,
112	return uVar8;
112	short *psVar5;
112	if (param_2 == 2) {
112	if ((short)uVar1 == 0) {
112	iVar4 = ftol();
112	local_8 = (uint)sVar2;
112	pvVar3 = (void *)0x0;
112	puVar1 = param_4;
112	_memDelete(pvVar7);
112	requested byte count
112	666666666
111	*puVar1 = 0;
111	error out2`P
111	error out2@P
111	byte count (0)
111	0-Ver. Cmnd(IND)
111	test.vi
111	Pass or Fail Global
110	iVar6 = iVar6 + 1;
110	} while (iVar9 != 0);
110	if (iVar8 == 0) {
110	if (*param_2 == 0) {
110	param_2 = (uint *)0x0;
110	Write File+ (string).vi
110	Read File+ (string).vi
110	XON byte
110	f`ff
110	system error
109	error in
108	return local_18;
108	if (sVar1 < 0) {
108	*puVar4 = *puVar3;
108	return (int)(short)local_8;
108	} while (local_8 != 0);
108	int *local_c;
108	if (local_5 == '\0') {
108	if (local_8 != 0) break;
108	uVar1 = uVar1 + 1;
108	FUN_21136340(uVar1);
108	local_60 = 0;
108	undefined4 local_6c;
108	if (pvVar1 != (void *)0x0) {
108	local_8 = -0x28cc;
108	uVar2 = 0xffff3bb3;
108	uVar2 = -(uint)(0x740c000 < *param_3) & 0xffff3bb4;
108	(**(code **)*puVar4)(1);
108	*param_2 = -0x28cc;
108	if (iVar1 < 1) {
108	uVar2 = (**(code **)(iVar1 + 0x7c))(&local_8);
108	iVar2 = **(int **)(in_ECX + 0x20a);
108	if ((local_8 == -0x272f) && (local_8 = FUN_21146c41(param_1), local_8 == 0)) {
108	return -0x273e;
108	sVar5 = *(short *)(*(int *)(*(int *)(*(int *)(*(int *)(local_10 + 0x3f) + 2) + 0x1e +
108	Open/Create/Replace File.vi
108	New Occurrence@!
108	FDQRh
107	iVar3 = iVar3 + -1;
107	} while (iVar3 != 0);
107	Next Range to cal
107	]SV
107	Visible
107	empty
107	terminator
107	Output
106	local_20 = 1;
106	int local_3c;
106	int local_40;
106	bVar2 = false;
106	if (bVar2) {
106	return 0xd755;
106	uVar2 = param_2;
106	sVar8 = 0;
106	if (cVar1 != '\0') {
106	iVar3 = *piVar2;
106	Open File+.vi
106	Serial Port Reset.vi
106	Find First Error.vi
106	XOFF byte
106	port number@
105	bool bVar2;
105	REV_CHK.vi
105	Serial Port Buffer Size.vi
104	if (-1 < iVar1) {
104	local_d4.Buffer = (uchar *)((uint)(local_d4.Buffer + 3) & 0xfffffffc);
104	int *piVar7;
104	(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9,param_10,
104	iVar5 = param_1;
104	if (sVar4 < 0) {
104	iVar8 = iVar8 + -1;
104	if (sVar7 != 0) {
104	iVar11 = iVar11 + 1;
104	return -0x2a33;
104	if (uVar3 == 0) {
104	local_c = 4;
104	if (0 < param_3) {
104	return 0xd698;
104	param_2 = param_2 - 1;
104	local_64 = 0;
104	uVar3 = uVar2;
104	pvVar2 != (void *)0x0)) {
104	if (*param_2 < 0x6500000) {
104	*puVar1 = (int)(short)param_2;
104	if ((int)(short)param_2 == 0) {
104	syncClose(*(iSync **)(in_ECX + 0x138),(long *)0x0);
104	(**(code **)(*piVar1 + 0x20))
104	STARTCHK.vi
104	Serial Port Init.vi
104	EEClear.VI
104	buffer size
104	Abort?PTH0
104	COM1:
104	!_^[
104	OVj
104	7QRhhh
104	,BDPW
103	undefined2 local_1c;
103	Caldate.vi
103	Cancel
103	CAPSETUP.vi
103	}xu"
102	undefined2 uVar6;
102	return local_1c;
102	/* WARNING: Type propagation algorithm not settling */
102	uVar14 = 0;
102	return -0x2968;
102	*param_4 = 5;
102	*param_4 = 6;
102	case 0x1b:
102	if (iVar9 == 0) {
102	param_2 = (tBuffer *)0x0;
102	puVar5 = (undefined1 *)0xad;
102	if (*local_10 == 4) {
102	GAIN_CAL.VI
102	LEAK_VLT.VI
102	fXfYf
102	baud rate
102	Write & Read
102	Write Only
102	SQRVWP
101	10V_Set.vi
101	Leak_CAL.VI
101	Last Range Cal'd
101	CAL_MODE.vi
101	LEADOPEN.vi
101	Write Characters To File.vi
101	standard deviation
100	uVar2 = uVar1;
100	undefined2 extraout_var_06;
100	lpOutBuffer = &local_1c;
100	lpInBuffer = &local_1c;
100	local_14 = param_2;
100	param_11,param_12,param_13,param_14);
100	if (param_2 == (int *)0x0) {
100	return 0xd7fd;
100	size_t sVar1;
100	NdrPointerBufferSize(&local_d4,param_4,"\x12");
100	NdrPointerMarshall(&local_d4,param_4,"\x12");
100	if (sVar2 == 1) {
100	short sVar10;
100	uint uVar12;
100	uVar11 = uVar11 + 1;
100	if ((short)uVar5 != 0) {
100	*puVar3 = 0;
100	switch(uVar1) {
100	if (*(int *)(iVar1 + 0xc) != 0) {
100	iVar4 = FUN_21058a50();
100	*param_4 = -0x2a58;
100	*param_3 = -0x2a58;
100	puVar4 = puVar3;
100	return -0xc3e6;
100	sVar7 = -0x28cc;
100	if (sVar3 < 0) goto LAB_2118ee7a;
100	return psVar4;
100	DA_TEST.VI
100	ESR_CAL.VI
100	GET_PATH.vi
100	IND_CAL.VI
100	$DDOD
100	instr handle inPTH0
100	FC Out
99	uVar3 = 1;
99	CALCLEAR.VI
99	error in (no error)<`P
99	error in (no error)<@P
99	INDSETUP.vi
99	bus4
99	End Cal Factor(59)
98	uVar8 = 1;
98	if (param_3 == 2) {
98	case 0x19:
98	if (local_14 == 0) {
98	} while (param_1 != 0);
98	if (uVar1 == 0) {
98	short local_1c;
98	CALSET.VI
98	CAP_CAL.VI
98	ISRC_CAL.VI
98	SER_SET.VI
98	Ringer.vi
98	error out4
98	input refnum
98	instrument descripter
98	Read Only
98	QRhhhVhU
97	undefined2 *puVar5;
97	if (uVar4 != 0) {
97	LEAK_I.VI
97	++++
97	frequency (Hz) - ignoredp
97	frequency (Hz) - ignored
97	mean
97	COM2:
96	return local_20;
96	param_11,param_12);
96	uVar5 = 1;
96	local_d4.MaxCount = param_6;
96	(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)
96	uVar15 = 0;
96	iVar8 = 0;
96	short sVar11;
96	puVar1 = DAT_212191c0;
96	double local_14;
96	return 0xd68b;
96	if (0 < sVar3) {
96	FUN_21098c40(&local_8,&local_c);
96	sVar1 = getDevicePtr(param_1,&param_1);
96	param_2 = (int *)0x0;
96	iVar1 = *(int *)(in_ECX + 0x40);
96	if (*(int *)(iVar1 + 0xc) == *(int *)(iVar1 + 8)) {
96	(*(int *)(iVar1 + 0x10) + *(int *)(iVar1 + 8)) * 0x1c,1,8);
96	*(undefined4 **)(iVar1 + 4) = puVar3;
96	puVar4 = puVar4 + 7;
96	*(int *)(iVar1 + 8) = *(int *)(iVar1 + 8) + *(int *)(iVar1 + 0x10);
96	puVar4 = (undefined4 *)(*(int *)(iVar1 + 4) + *(int *)(iVar1 + 0xc) * 0x1c);
96	*(int *)(iVar1 + 0xc) = *(int *)(iVar1 + 0xc) + 1;
96	uVar4 = (**(code **)(iVar2 + 0x7c))(&param_2);
96	*param_2 = 0x28;
96	goto switchD_210ecb83_default;
96	puStackY_34 = (undefined1 *)0x3;
96	local_14 = (uint *)0x0;
96	Start Cal Factor(0)
96	data bits
96	[error code] (0)$@@
95	uint *puVar5;
95	VER#_SAV.VI
95	Max NSTD
94	if (param_6 == 0) {
94	return -0x2715;
94	EPW
94	stop bits
94	ShUh
94	udfP
93	uint *puVar2;
92	case 0x36:
92	iVar6 = param_1;
92	local_10 = param_2;
92	ushort *puVar1;
92	uint in_EAX;
92	if (iVar9 != 0) {
92	if (0 < sVar5) {
92	uint local_40;
92	} while (iVar8 != 0);
92	local_20 = local_20 + 1;
92	iVar1 = param_2;
92	FUN_21136340(uVar3);
92	local_5 = '\x01';
92	iVar2 = iVar2 + 1;
92	uVar2 = 1;
92	if ((short)local_10 == 0) {
92	if (local_24 == 0) {
92	*puVar2 = 1;
92	FUN_21058a50();
92	local_8 = local_8 & 0xffff;
92	uVar9 = uVar9 + 1;
92	dVar1 = 0.0;
92	void *pvVar4;
92	if (pvVar4 == (void *)0x0) {
92	(**(code **)(**(int **)(in_ECX + 0xc) + 0x24))
92	&local_8);
92	param_4 = (undefined4 *)0x0;
92	ssprintf(s__s__s__s__2120a584,s_j__drvsrc_ALL_nidaq_e_series_wal_2120a550,
92	pvVar7 = *(void **)(iVar1 + 4);
92	puVar6 = (undefined4 *)(((int)pvVar7 - (int)puVar3) + (int)puVar4);
92	puVar8 = puVar4;
92	*puVar8 = *puVar6;
92	iVar7 = (int)sVar1;
92	float fVar3;
92	if (&stack0x00000000 == (undefined1 *)0xfffffff8) {
92	local_8 = -0x2730;
92	(i32) code: the error code associated with an error.  A value of 0 means no error, a negative value is an error, and a positive value is a warning.[W(string) source:  an indication of where an error occurred, usually the name of the VI.
92	# Beeps(3)
92	Path to Stan. Vals
91	undefined2 local_24;
91	error in (not an error)
91	TVICD
91	hCPTM
91	QRQP
90	pcVar1 = (code *)swi(0x21);
90	undefined2 unaff_CS;
90	byte bVar5;
90	case 0x39:
90	iVar11 = iVar11 + -1;
90	} while (iVar11 != 0);
90	char local_5;
90	puVar7 = puVar7 + 1;
90	if (lVar1 == 0) {
90	*param_4 = 8;
90	puVar25 = (undefined1 *)0xad;
90	return -0x2867;
90	.QRP
89	MQW
89	instr handle in0
89	output error
89	DD@D
88	local_d4.MaxCount = param_4;
88	*param_3 = 4;
88	undefined4 in_EAX;
88	case 0x24:
88	sVar2 = ftol();
88	uint uVar13;
88	return -0x28ad;
88	return sVar8;
88	if ((int)uVar8 < 0) {
88	uVar8 = (uVar8 - 1 | 0xfffffffe) + 1;
88	iVar10 = iVar10 + -1;
88	undefined4 uStack_8;
88	undefined4 local_74;
88	sVar2 = sVar3;
88	_memDelete(pvVar1);
88	if (0 < iVar2) {
88	uVar1 = (**(code **)(iVar3 + 0x7c))();
88	float fVar2;
88	(**(code **)(**(int **)(in_ECX + 0x15f) + 0x20))
88	/* public: virtual long __thiscall
88	SVWU
88	DLabl
88	refnumu
88	statusgencode.cGenDispatchEntry
88	04;M
88	address`
88	f(cluster) error in:  a cluster describing any error conditions prior to this VI's execution.  The default input of this cluster is no error.  If an error has already occurred, this VI does nothing.  The error in cluster contains the following parameters:
88	If status is TRUE, this VI does nothing.
88	(ABC) source:  an indication of where an
88	source ("")<@P
88	Code
88	DAC Count
87	undefined2 uVar7;
87	if (uVar4 == 0) {
87	?~<>
87	Offset
87	Expected Reading
87	XLIfp
86	pcVar1 = (code *)swi(0x31);
86	case 0x3a:
86	case 0xc9:
86	if (sVar4 == 1) {
86	short sVar12;
86	puVar12 = puVar12 + 1;
86	return -0x28ab;
86	sVar8 = sVar8 + 1;
86	case 0x14f:
86	case 0x156:
86	case 0x15b:
86	case 0x161:
86	case 0x162:
86	local_8 = uVar5;
86	Instr Error Out Cluster.ctl2@P
86	Instr Error In Cluster.ctl<@P
86	convert eol? (no:F)
86	SND_CF&V.viW
86	ERP
86	Inductance test.vi
86	w8~|
85	undefined2 uVar8;
85	range (auto:0)
85	0Test data in
85	0DTHP
84	undefined2 local_8;
84	case 0x37:
84	lpOutBuffer = &local_24;
84	lpInBuffer = &local_24;
84	local_8 = param_2;
84	return this;
84	undefined4 param_13,undefined4 param_14,undefined4 param_15)
84	)
84	local_d4.Buffer = (uchar *)((uint)((int)local_d4.Buffer + 3U) & 0xfffffffc);
84	short *psVar6;
84	return in_EAX & 0xffff0000;
84	iVar1 = *param_1;
84	if (param_3 != 1) {
84	uint local_3c;
84	param_4 = param_4 + 1;
84	*param_4 = 10;
84	puVar2 = puVar2 + 1;
84	int local_5c;
84	piVar10 = piVar10 + 1;
84	if (-1 < (int)local_8) {
84	if (0 < sVar1) {
84	if ((int)local_8 < 0) {
84	if (*param_3 == 0) {
84	return 0xd68a;
84	(**(code **)(**(int **)(in_ECX + 0x10) + 0x24))
84	if (-1 < local_8) {
84	FUN_210c1740();
84	piVar10 = (int *)&param_2;
84	if (local_24 != 0) break;
84	if ((short)psVar4 != 0) {
84	iVar13 = *(int *)(iVar13 + 0x94);
84	103FINAL.VI
84	A unique reference to an instrument I/O session.  It identifies which device to communicate with and all configuration information to perform the I/O.  An instr handle is returned from the Instr Open VI or the Initialize VI of an instrument driver.
84	^Y[f=
84	file path (dialog if empty)
84	Ef=
84	NWj
83	piVar3 = piVar3 + 1;
83	[pattern]
83	Key Focus
83	driver opened
82	undefined2 extraout_var_07;
82	if (local_2c != 0) {
82	*param_10 = 0;
82	undefined4 *puVar9;
82	undefined4 local_68;
82	sVar4 = -0x2717;
82	local_c = local_8;
82	return 0x2a30;
82	iVar9 = 0;
82	return -0x292c;
82	return 0xd6d4;
82	@ Error\FC Out"
82	parity
82	Actual High
82	Status Cluster Out
82	t_^
82	PQj
82	MQf
82	Delay
81	333333
81	@Error\FC Out
81	4B0
81	input refnumf
81	d$ZY=
80	uint *puVar3;
80	undefined2 *puVar6;
80	case 0x38:
80	daqDevice::~daqDevice(in_ECX);
80	*param_5 = *(undefined2 *)local_d4.Buffer;
80	if (-1 < (short)uVar3) {
80	*param_11 = 0;
80	*param_3 = 5;
80	*param_3 = 6;
80	if (uVar7 != 0) {
80	ushort uVar8;
80	case 0x2a:
80	iVar3 = (int)sVar1;
80	param_3 = param_3 + -1;
80	param_2 + 0x39a);
80	return (int)sVar3;
80	if (sVar1 == 1) {
80	FUN_21136340(uVar5);
80	if (*param_1 == 0) {
80	local_c = local_c + -1;
80	return uVar7 & 0xffff0000;
80	local_5 = '\0';
80	puVar11 = puVar11 + 1;
80	return (uint)param_4 & 0xffff0000;
80	uVar7 = 1;
80	*param_4 = 3;
80	return 0xffffd8e9;
80	if (cVar1 == '\0') {
80	case 0x1d:
80	FUN_210880f0();
80	if (local_8 < 0) {
80	param_4[1] = (int)s_j__drvsrc_ALL_nidaq_e_series_wal_212092dc;
80	undefined1 local_c [8];
80	(**(code **)(**(int **)(in_ECX + 0x157) + 0x24))
80	return -0x2730;
80	sVar3 = -0x28cc;
80	pos offset (bytes:0)
80	file path
80	advisory dialog? (display:T)
80	x8|>
80	ABORT?.viW
80	CALON
80	[exception source]
80	666666
80	Input StringPTH0
79	int local_54;
79	int local_12;
79	undefined2 local_20;
79	uint *puVar4;
79	uVar1 = 1;
79	undefined2 in_stack_00000012;
79	undefined2 in_stack_00000016;
79	error outR
79	Error\FC InX
79	Actual Low
79	mark after read (chars.)
79	d:\automated\lv51\lvsource\gencode.cGenRangeCheck
79	DTHPD
78	local_10 = param_3;
78	if ((short)uVar4 == 0) {
78	undefined4 *local_c;
78	return 0xd5d0;
78	local_68 = 0;
78	uVar1 = ftol();
78	*(double *)
78	*param_4 = 7;
78	*param_2 = 0x116;
78	FUN_21082700();
78	piVar10 = (int *)0xffffffec;
78	goto LAB_21190eec;
78	}WV
78	DSIM
78	hDSTM
78	line mask@
78	ffffff33ff33
78	33ff333333
78	g~&<~
77	bool bVar5;
77	0);+
77	busPTH0
77	lffffff
77	flfff
77	(ABC)
77	instrument descriptor (INSTR{})
77	aQRRVh
77	QRQWV
76	bool bVar3;
76	local_8 = param_1;
76	local_18 = param_1;
76	DWORD local_c;
76	nOutBufferSize = 0x18;
76	nInBufferSize = 0x18;
76	ulong *param_6)
76	*param_6 = *(undefined2 *)local_d4.Buffer;
76	if ((short)uVar3 < 0) {
76	if ((param_3 != 0) && (param_3 != 1)) {
76	if (-1 < sVar4) {
76	short local_3c;
76	double dVar4;
76	undefined4 param_6)
76	int local_4c;
76	if ((short)local_8 != 0) {
76	undefined4 uVar10;
76	puVar1 = param_1;
76	if (iVar7 != 0) {
76	return -0x2a30;
76	iVar4 = iVar3;
76	char *pcVar1;
76	uVar13 = 0;
76	if (iVar1 == 1) {
76	iVar5 = ftol();
76	*param_6 = 1;
76	local_8 = (uint)sVar1;
76	local_8 = iVar7;
76	((tPIMMblockReferenceBase *)&param_1,
76	puVar3 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&param_1);
76	local_8 = (**(code **)(*(int *)in_ECX[3] + 0x14))(param_4,&local_c,&local_14,&local_10);
76	double dVar7;
76	local_28 = 8;
76	Meas. Low
76	(X~=Y)?
76	Done?
76	u_^
76	[_^]
76	CKHh
76	P!Error\FC Out
76	t$QRRVh
75	if (local_18 == 0) {
75	(i32) The error code associated with an error.  Possible values:
75	-1201  Error finding instruments
75	-1210  Parameter out of range
75	-1220  Error getting attribute
75	-1221  Error setting attribute
75	-1224  Error clearing instrument
75	-1225  Error triggering instrument
75	-1226  Error polling instrument
75	-1230  Error writing to instrument
75	-1231  Error reading from instrument
75	-1250  Error mapping VXI address
75	-1251  Error unmapping VXI address
75	-1252  Error accessing VXIbus
75	The pop-up option Explain Error (or Explain Warning) gives more information about the error displayed.
75	O$X
75	Continue Button
75	,STRG
74	int local_44;
74	undefined2 uVar9;
74	} while (iVar12 != 0);
74	undefined2 extraout_var_08;
74	uint uVar14;
74	piVar8 = piVar8 + 1;
74	if (pvVar2 != (void *)0x0) {
74	*(undefined1 *)
74	if ((((byte)(param_1 >> 0x18) & 0xf) != 5) && ((param_1 & 0xf000000) != 0)) {
74	URW
74	wwwwww
74	0  Success
74	-1200  Invalid syntax string
74	-1202  Unable to initialize interface or instrument
74	-1205  Invalid instr handle
74	-1240  Instrument timed out
74	-1260  Function not supported by controller
74	code4
74	t'!!
73	bool bVar4;
73	u &gf
73	coder0@
73	Slope
73	NFCO
72	undefined4 param_17,undefined4 param_18,undefined4 param_19,undefined4 param_20,
72	*(undefined4 *)(local_d4.Buffer + 0xc) = param_5;
72	local_d4.Buffer = (uchar *)((int)local_d4.Buffer + 8);
72	NdrConvert(&local_d4,"N\x0fN\bN\x06M\x01\n");
72	local_d4.Buffer = local_d4.Buffer + 0xc;
72	uVar3 = local_20;
72	if ((short)param_2 != 0) {
72	sVar1 = sVar1 + 1;
72	if (param_1 == (int *)0x0) {
72	if ((short)param_5 == 0) {
72	short param_6)
72	iVar5 = iVar5 + 1;
72	if (param_5 == 1) {
72	uVar3 = 2;
72	case 0x26:
72	iVar5 = param_2;
72	uVar4 = 1;
72	double dVar5;
72	local_c = 3;
72	short sVar13;
72	char *pcVar4;
72	int local_50;
72	sVar9 = 0;
72	param_2 = param_2 + 2;
72	} while (iVar10 != 0);
72	if ((short)uVar5 == 0) {
72	sVar2 = *(short *)((int)DAT_212191c0 + 1);
72	uVar3 = local_8;
72	uVar3 = param_2;
72	*param_3 = 0x6720;
72	local_8 = -0x2713;
72	local_8 = 0xffffd8ed;
72	*in_ECX = 0;
72	sVar3 = sVar2;
72	*psVar1 = sVar2;
72	if (*puVar1 != 0) {
72	*param_2 = -0x2713;
72	iVar4 = *in_ECX;
72	piVar3 = *(int **)(in_ECX + 0xc);
72	*param_3 = uVar2;
72	param_2[1] = (int)s_j__drvsrc_ALL_nidaq_e_series_wal_2120a994;
72	if (*(int *)(in_ECX + 0x3c) != 0) {
72	} while (local_c != 0);
72	_memDelete(this);
72	param_7 = 0;
72	if (iVar3 < 1) {
72	local_8 = uVar3;
72	*param_2 = 0x117;
72	*param_2 = 0x13e;
72	*param_2 = 0x122;
72	((tTimerTimeWasterSleep *)(iVar7 + 0x24),(long *)&param_2);
72	param_3 = iVar4;
72	local_8 = -0x292c;
72	local_18 = (short *)CONCAT22(local_18._2_2_,sVar1);
72	return -0x272c;
72	*(byte *)(param_1 + 0x957 + local_8 * 0x10) =
72	*(byte *)(param_1 + 0x958 + local_8 * 0x10) =
72	sVar3 = local_10;
72	sVar4 = *(short *)(iVar13 + 0x2fa);
72	sVar3 = (short)local_c;
72	*(undefined4 *)param_12 = param_5;
72	*(undefined4 *)((int)param_12 + 4) = param_6;
72	wwwwwwwww
72	'>O|
72	hhhP
72	?f"" "
71	if (-1 < iVar2) {
71	error in (no error)4
71	error - ignored
71	error in (no error) @
71	- sources: `Final_Cal_103FIN.EXE.strings.txt, Source_LV3_1_103f_cal.llb.strings.txt, Source_LV5_1_103f_cal.llb.strings.txt`
71	source4
71	string to write
71	Result
71	number of lines (all:-1)
71	True RE
71	?fbb`
70	bVar4 = true;
70	ushort uVar10;
70	param_5 = 0;
70	*param_4 = 9;
70	iVar12 = iVar12 + -1;
70	int iVar14;
70	int local_48;
70	if (iVar8 != 0) {
70	double *pdVar5;
70	ftol();
70	*param_2 = 0x8c;
70	local_8 = 0x1e;
70	local_c = 0x80;
70	local_c = -0x2730;
70	3.1b14
70	EpPR
70	@0Input StringPTH0
70	pLIvi
70	QRhhh
69	if (uVar8 != 0) {
69	byte bVar6;
69	P Error\FC Out
69	` Error\FC Out
69	codeH
69	Item Names
69	6QRP
68	if ((short)uVar2 < 0) {
68	nOutBufferSize = 0x10;
68	nInBufferSize = 0x10;
68	local_c = param_1;
68	*) */
68	param_10,param_11);
68	local_d4.Buffer = (uchar *)((int)local_d4.Buffer + 2);
68	undefined4 *puVar11;
68	*param_3 = uVar1;
68	return false;
68	ushort uVar9;
68	case 0x25:
68	undefined2 *puVar7;
68	uVar2 = param_3;
68	if (sVar1 == -1) {
68	} while (param_3 != 0);
68	if (sVar5 == 1) {
68	undefined1 uVar2;
68	if (param_3 == 50000) {
68	*param_1 = 1;
68	undefined2 extraout_var_09;
68	*param_2 = 2;
68	undefined1 local_20 [4];
68	int *piVar8;
68	puVar2 = DAT_212191c0;
68	local_14 = 2;
68	param_5 = param_5 + 1;
68	return (int *)0x0;
68	return -0x2a58;
68	FUN_21082830();
68	return uVar4 & 0xffff;
68	FUN_210c4c30();
68	in_ECX[1] = 0;
68	short local_24;
68	uStack_8 = 0;
68	uVar2 = palStatusMapStatusValue(*puVar1);
68	void *local_8;
68	piVar1 = *(int **)(in_ECX + 0x138);
68	param_3[1] = (int)s_j__drvsrc_ALL_nidaq_e_series_wal_212092dc;
68	tBuffer *this;
68	if (this != (tBuffer *)0x0) {
68	local_8 = uVar2;
68	return 0xffffd8ea;
68	return -0x271c;
68	return 0xd774;
68	param_6 = param_6 + param_5;
68	CALOFF
68	CONP
68	TM80
68	SCSR
68	FPHc
68	FPSE
67	undefined2 local_1e;
67	The name of the VI that is calling this VI.  If an error occurs during the operation of this VI, the value in source will be placed in the source element of the error out cluster.
67	Error\FC In4
67	GlobStat.viH
67	delay break ?
67	BDHc
67	UUT Comm.viPTH0
66	undefined2 local_14;
66	*param_5 = 1;
66	uVar6 = 2;
66	puVar9 = puVar9 + 1;
66	uint local_54;
66	uVar14 = uVar14 + 1;
66	else if (param_2 == 1) {
66	sVar2 = -0x28cc;
66	return -0x2882;
66	local_8 = param_2 + -1;
66	iVar3 = local_1c + 0x15 + local_18 * 8;
66	*(undefined4 *)(local_1c + 0x215 + local_18 * 8) =
66	*(undefined4 *)(local_1c + 0x15 + local_18 * 8);
66	*(undefined4 *)(local_1c + 0x219 + local_18 * 8) =
66	*(undefined4 *)(local_1c + 0x19 + local_18 * 8);
66	*(undefined4 *)(local_1c + 0x415 + local_18 * 8) = 0;
66	*(undefined4 *)(local_1c + 0x419 + local_18 * 8) = 0x3ff00000;
66	sVar3 = local_14;
66	if (sVar4 < 0) goto LAB_2118a552;
66	} while ((int)local_14 < (int)(short)local_34);
66	"fQfU&g
66	status&
66	fffff
66	450
66	bus @@
66	$hhhR
66	send string
66	24MD
66	Global.vi
66	6666666
66	y>G8
66	BDSE
65	char cVar4;
65	uint *puVar7;
65	close when? (now:T)
65	PLAT
65	PRU
65	3333333
65	error outPTH0!
65	StatusGlobal
65	FC out
65	udf6PP
65	MUID
64	bool bVar8;
64	local_14 = param_1;
64	lpOutBuffer = &local_20;
64	lpInBuffer = &local_20;
64	lpOutBuffer = &local_18;
64	lpInBuffer = &local_18;
64	*(undefined2 *)(local_d4.Buffer + 6) = param_5;
64	local_20 = (int)*(short *)(in_ECX + 0x2c) | param_1 & 0xffffff00;
64	return 0xd75f;
64	if ((short)param_3 == 0) {
64	if (local_1c == 0) {
64	iVar2 = param_2;
64	param_4 = param_4 + -1;
64	if ((short)uVar7 == 0) {
64	short *psVar7;
64	local_28 = 1;
64	return local_c & 0xffff;
64	if ((param_3 < 0) || (7 < param_3)) {
64	return -0x28ac;
64	sVar12 = 0;
64	if (param_4 == -1) {
64	u64 *puVar4;
64	u64 *puVar5;
64	local_10 = local_10 + -1;
64	} while (local_10 != 0);
64	undefined2 extraout_var_10;
64	*param_4 = uVar1;
64	piVar6 = piVar6 + 1;
64	undefined4 uStack_10;
64	short local_20;
64	int local_70;
64	undefined4 local_7c;
64	if (param_1 == 2) {
64	if ((lVar2 == 0) &&
64	if ((int)local_8 < 1) {
64	if (!bVar1) {
64	FUN_21183e60(0x32,2);
64	local_8 = 0xffffd734;
64	if ((lVar3 == 0) &&
64	*param_3 = -0x28cc;
64	if (&stack0x00000000 == (undefined1 *)0x8) {
64	if (iVar2 == 1) {
64	if (piVar1 != (int *)0x0) {
64	FUN_21082350();
64	if (0 < iVar1) {
64	else if (iVar4 == 0) {
64	if (iVar7 != 0) goto LAB_210cc773;
64	iVar5 = *(int *)*puVar4;
64	_memDelete(local_8);
64	(**(code **)(**(int **)(in_ECX + 0x157) + 0x34))
64	return 0xbffa4003;
64	case 0x14d:
64	(**(code **)(**(int **)((int)in_ECX + 0x15f) + 0x20))
64	if (uVar12 != 0) {
64	switch(iVar4) {
64	error in (no error)PTH0
64	u &g
64	pattern`
64	# MillisecondsPTH0
64	EOF??
64	]VW
64	Capacitance testII.vi
64	codeU
64	SQRVW_^ZY[]
64	GlobStat.viPTH0
63	SVW
63	error out0
63	4U0
63	420
63	d$ f
63	Software Rev.
62	undefined2 local_10;
62	undefined2 uVar10;
62	bVar3 = true;
62	if (param_4 != 2) {
62	sVar11 = 0;
62	float10 extraout_ST0;
62	uint local_58;
62	FUN_210062e0(param_1);
62	short local_34;
62	undefined1 local_1c [8];
62	undefined2 *local_c;
62	if (0 < (short)param_2) {
62	return 0xd893;
62	long lVar4;
62	local_18 = 0.0;
62	int *param_6)
62	if (*piVar3 == 0) {
62	*param_3 = 7;
62	float fVar4;
62	return 0xd8dc;
62	case 0x140:
62	error in (no error)2P@
62	103FINAL.VIW
62	rattle relays.vi
62	ESR.vi
62	Leakage voltage test.vi
62	D/A.vi
62	Leakage current test.vi
62	use system decimal point (T)
62	True W
61	MessagePTH0
61	Error\FC In(F)0
61	lead zero short/open.vi
61	Inductance testII.vi
61	DAC_RITE.vi
61	SQRVWhU
61	Error\FC Out(F)&
60	sVar2 = (short)param_2;
60	local_c = param_4;
60	local_10 = param_1;
60	iVar1 = iVar1 + -1;
60	(piVar1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
60	undefined4 param_13)
60	return lVar1;
60	local_d4.BufferLength = 4;
60	NdrGetBuffer(&local_d4,4,param_1);
60	local_d4.BufferLength = 0xc;
60	ulong uVar2;
60	undefined1 local_2c [8];
60	} while (iVar13 != 0);
60	uVar1 = param_3;
60	switch(iVar3) {
60	puVar10 = puVar10 + 1;
60	undefined4 uVar12;
60	short *local_c;
60	iVar8 = iVar8 + 1;
60	iVar4 = param_2;
60	nOutBufferSize = 0x50;
60	nInBufferSize = 0x50;
60	dwIoControlCode = 0xabcd201c;
60	double local_1c;
60	if (0 < (short)local_34) {
60	return (short)local_8;
60	return iVar5;
60	uVar12 = 0;
60	if (uVar7 == 0) {
60	if (cVar1 == '\x01') {
60	undefined2 *local_10;
60	iVar10 = 0;
60	short local_30;
60	return 0xd753;
60	iVar5 = local_8;
60	local_14 = 0.0;
60	*param_7 = 1;
60	lpBytesReturned = (LPDWORD)&param_1;
60	local_30 = 1;
60	int local_58;
60	iVar4 = (int)sVar6;
60	undefined1 local_14 [8];
60	if (uVar8 == 0) {
60	if (-1 < (short)uVar2) {
60	if (param_4 != 3) {
60	param_3 = (int)sVar3;
60	in_ECX[7] = 0;
60	))) {
60	(**(code **)(*piVar3 + 0x24))
60	*(undefined4 *)(iVar7 + 5) = param_1;
60	if (-1 < *param_2) {
60	if (-1 < *param_4) {
60	*piVar1 = -0x2a58;
60	(**(code **)(iVar4 + 0x10))(&param_4);
60	*piVar9 = -0x28a3;
60	if (iVar7 < 1) {
60	uVar4 = *(undefined4 *)(in_ECX + 0x3dc);
60	iVar2 = FUN_21058a50();
60	pvVar4 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&stack0xffffffec);
60	case 0x14e:
60	(**(code **)(**(int **)(in_ECX + 4) + 0x38))(4,0,local_c,&local_8);
60	return 0xbffa000c;
60	return param_1 & 0xffff0000;
60	return -0x2711;
60	return -0x2719;
60	*(uint *)(local_30 + 0x3d6) =
60	local_8 = FUN_21171bda(param_1,&local_14);
60	*(byte *)(param_1 + 0x95f + local_8 * 0x10) =
60	*(byte *)(param_1 + 0x6d6) = *(byte *)(param_1 + 0x6d6) & 0x7f;
60	local_c = 0x68;
60	local_c = 0xb6;
60	if ((param_6 < 1) || (0x40 < param_6)) {
60	goto LAB_2118ee7a;
60	if (local_24 == (ushort *)0xffffffff) {
60	sVar4 = -0x292c;
60	sVar4 = FUN_21171bda(*puVar26,&local_8);
60	sVar4 = FUN_211c4920(local_10,local_14,&local_1c,&local_c,&local_20);
60	if (local_1c != (uint *)0xffffffff) {
60	sVar7 = *(short *)(*(int *)(puVar26 + 3) + (int)local_c * 2);
60	} while (local_14 < local_28);
60	local_8 = local_38;
60	sVar4 = FUN_211c4920(local_10,*local_8,&local_1c,&local_c,&local_20);
60	if (local_1c == (uint *)0xffffffff) goto LAB_211d1434;
60	error in (no error)@
60	URS
60	return count2@P
60	write buffer ("")
60	0-Ver. Cmnd(CAP)
59	if (local_2c == 0) {
59	undefined2 local_42;
59	uint *puVar6;
59	Rdng. Seq.
59	line string
58	char *pcVar2;
58	bVar4 = false;
58	iVar13 = 0;
58	*param_4 = 0xb;
58	short *psVar8;
58	iVar6 = 1;
58	if (piVar2 == (int *)0x0) {
58	return 0xd799;
58	void __thiscall
58	*param_13 = 0;
58	(int)&param_1 + 2);
58	double *pdVar6;
58	if (param_2 == 0xffff) {
58	iVar5 = **(int **)((int)param_1 + *psVar12 * 4 + 0x1fa);
58	Array Index
58	string
58	output XON/XOFF
58	instrument descriptor
58	return string
58	|DSTM
58	Max # Readings
58	UPR
58	FC in
58	DIO_R-W.VIV
58	True H
57	Comm Error Out
57	TUUU
57	flow control etc.
57	?RSRC
57	QRPf
56	*puVar4 = 0;
56	DWORD *lpBytesReturned;
56	local_10 = 2;
56	local_c = param_2;
56	local_18 = param_2;
56	local_c = param_3;
56	} while (iVar1 != 0);
56	undefined4 param_21,undefined4 param_22,undefined4 param_23,undefined4 param_24,
56	NdrGetBuffer(&local_d4,0xc,param_1);
56	double *pdVar2;
56	(uint)*(ushort *)(in_ECX + 0xb);
56	uVar2 = uVar3;
56	if (uVar6 == 0) {
56	iVar5 = (int)sVar3;
56	uVar4 = ftol();
56	undefined4 in_ECX;
56	bVar3 = 0;
56	if (iVar2 < 0) {
56	sVar3 = (short)param_1;
56	undefined4 uVar11;
56	iVar4 = local_8;
56	goto switchD_2104d7a5_caseD_9;
56	if ((short)local_1c == 0) {
56	return (int)sVar4;
56	if (*piVar1 == 0) {
56	*param_3 = param_2;
56	iVar6 = FUN_21058a50();
56	param_2[1] = 0;
56	return (uint)uVar2 << 0x10;
56	iVar4 = (int)sVar2;
56	if (local_5 != '\0') {
56	iVar1 = param_1 + 0x15;
56	if (piVar1 == (int *)0x0) {
56	in_ECX[2] = 0;
56	*(int *)(iVar2 + 0x4b5) = (int)(short)param_1._2_2_;
56	if (param_2 == 8) {
56	local_8 = (int)sVar3;
56	tMemBlockReferenceBase::unassignExternalPointer
56	tMemBlockReferenceBase::assignExternalPointer
56	void *pvVar5;
56	float10 fVar2;
56	uVar2 = Ordinal_65(*param_1,&param_4);
56	uVar2 = Ordinal_33(*param_1,0x594,&param_3);
56	pvVar3 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&param_1);
56	iVar4 = **(int **)(in_ECX[6] + 0x14);
56	iVar6 = *piVar3;
56	if (param_1 == -1) {
56	puVar2 = param_4;
56	param_3[1] = (int)s_j__drvsrc_ALL_nidaq_e_series_wal_2120a994;
56	param_2 = *(int *)(iVar1 + 0xc);
56	return uVar2 & 0xffff;
56	return 0xd641;
56	param_7 = param_7 + 1;
56	tBuffer *ptVar2;
56	*(undefined4 *)(in_ECX + 0x44) = 1;
56	sVar1 = (**(code **)(*in_ECX + 0x3a4))();
56	*piVar1 = iVar5;
56	FUN_210dbf10(param_1);
56	if ((in_ECX[local_c * 0x14 + 6] != 4) && (in_ECX[local_c * 0x14 + 6] != 5)) {
56	*param_1 = (int **)(int)sVar3;
56	goto switchD_210ec1e2_caseD_c469;
56	*param_2 = (short)local_8;
56	return 0xbffa0010;
56	float local_14;
56	local_8 = FUN_21171bda(param_1,local_10);
56	if ((param_7 < 0) ||
56	LVSBLBVW
56	URj
56	QSVW
56	output alt HW HShk.
56	input Hardware HShk.
56	input alt HW HShk.
56	output Hardware HShk.
56	|PTH0
56	Tests Selected
56	input XON/XOFF
56	AVG_RD.VI
56	LVIN DIO table for main board test.vi
56	66666
56	u5QRP
56	ABORT?.viPTH0
55	*param_2 = uVar2;
55	uVar1 = *param_1;
55	*param_1 = uVar1;
55	undefined2 local_22;
55	int local_a;
55	ulong uVar1;
55	fff`ff
55	f`fff`f`
55	ffff`
55	fff`
55	fffffff`
55	ff`ff
55	f`f`
55	f`f`f`
55	0driver names(
55	15MD
55	4+0=
55	YXhWh
55	source ("")PTH0
55	instr vtl globalPTH0
55	error outPTH0
55	04(0
55	DIGPRTRD
55	DIGPRTCF
54	switch(uVar3) {
54	undefined4 uVar13;
54	case 0x28:
54	} while (param_4 != 0);
54	*param_14 = 0;
54	if (0 < sVar6) {
54	short local_40;
54	if (iVar10 == 0) {
54	local_24 = local_24 + -1;
54	uVar7 = uVar14 & 0xffff;
54	local_c = 0x400;
54	undefined4 local_90;
54	return 0xbffa400b;
54	local_c = local_c + 8;
54	local_24 = FUN_21005ab0();
54	for (local_8 = 0; local_8 < 4; local_8 = local_8 + 1) {
54	sVar3 = *(short *)(*(int *)(puVar14 + 5) + (short)local_14 * 2);
54	puVar22 = local_38;
54	puVar26 = (undefined2 *)(*(int *)(*(int *)(local_10 + 0x3f) + 2) + (int)local_1c * 0x2e);
54	- sources: `Final_Cal_103FIN.EXE.strings.txt, Source_LV3_1_103f_cal.llb.strings.txt, Source_LV5_1_103f_cal.llb.strings.txt, Source_LV6_103f_cal.llb.strings.txt`
54	- occurrences: `3`
54	MQS
54	Message@0
54	440
54	pos mode (rel. to mark:2)
54	MAINB_II.VI
54	[user-defined codes].@@
54	False H
54	New Occurrence
53	uint local_60;
53	bool bVar6;
53	bool bVar7;
53	DIO Setting Int
53	]SW
53	prompt
53	@FPHP
53	ERROR"
53	PWRtest.VI
53	}"u@
53	}!ur
53	vQRP
53	}"uH
53	}/uvQRP
52	byte bVar7;
52	bVar3 = false;
52	sVar2 = -0x2a30;
52	nOutBufferSize = 0x14;
52	nInBufferSize = 0x14;
52	lpOutBuffer = &local_14;
52	lpInBuffer = &local_14;
52	nOutBufferSize = 0x1e;
52	nInBufferSize = 0x1e;
52	nOutBufferSize = 0x1c;
52	nInBufferSize = 0x1c;
52	param_11,param_12,param_13,param_14,param_15,param_16,param_17,param_18,param_19,
52	(piVar1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9,param_10);
52	param_11,param_12,param_13,param_14,param_15);
52	piVar1 = param_2;
52	return (uint)param_3 & 0xffff0000;
52	if (0 < param_1) {
52	*param_7 = *(undefined2 *)local_d4.Buffer;
52	*(ULONG_PTR *)local_d4.Buffer = param_5;
52	*(undefined2 *)(local_d4.Buffer + 6) = param_4;
52	local_d4.Buffer = (uchar *)((int)local_d4.Buffer + 0xc);
52	local_d4.Buffer = (uchar *)((ULONG_PTR *)((uint)(local_d4.Buffer + 3) & 0xfffffffc) + 1);
52	local_d4.Buffer = local_d4.Buffer + 0x10;
52	local_1c = &stack0xffffffcc;
52	FUN_21185a40(local_c);
52	if (param_8 != 0) {
52	local_24[0] = 0;
52	sVar3 = (short)param_3;
52	undefined1 local_2c [4];
52	undefined4 uStack_20;
52	if (sVar8 == 6) {
52	switch(sVar2) {
52	double local_28;
52	iVar3 = param_2;
52	uVar4 = 2;
52	FUN_21136340(uVar2);
52	sVar3 = *(short *)((int)DAT_212191c0 + 1);
52	return -0x2a31;
52	if (sVar2 != 0) break;
52	double dVar6;
52	param_6 = param_6 + 1;
52	bVar4 = 0;
52	if (param_2 == -1) {
52	short *psVar10;
52	if (sVar7 == 0) {
52	sVar9 = sVar9 + 1;
52	sVar3 = (short)param_2;
52	undefined2 *local_1c;
52	if (param_2 < 0) {
52	if (iVar4 < 0) {
52	uVar4 = uVar4 | 0x20;
52	return sVar9;
52	uVar9 = param_2;
52	undefined1 local_24 [8];
52	if (puVar1 != (undefined4 *)0x0) {
52	iVar5 = (int)sVar4;
52	undefined1 local_24 [4];
52	iVar3 = 1;
52	return uVar5 & 0xffff0000;
52	undefined4 *param_5)
52	return -0x28c8;
52	uVar4 = param_2;
52	uint uVar15;
52	param_2 = (undefined4 *)0x0;
52	uint *puVar8;
52	FUN_21185130(*(undefined4 *)(param_2 + 0xc),2,(int)*(short *)(param_2 + 0x41d));
52	return true;
52	undefined4 local_78;
52	return 0xd5a6;
52	return -0x271d;
52	if (*(char *)(param_1 + 0x167) == '\x01') {
52	_STCMgrControlUser_12(uVar1);
52	local_70 = 0;
52	local_6c = 0;
52	return 0xd8e1;
52	long lVar6;
52	FUN_21082330();
52	_memDelete(pvVar2);
52	if (sVar6 == 0x10) {
52	double *pdVar4;
52	if (param_2 == 0x19) {
52	if (param_2 != 9) {
52	if (param_2 != 0x20) {
52	if (*param_2 != 0) {
52	if (0 < local_8) {
52	float10 fVar7;
52	iVar6 = (int)sVar4;
52	puVar4 = param_1;
52	iVar1 = *(int *)(in_ECX + 0xa7);
52	iVar4 = **(int **)(in_ECX + 0xc);
52	iVar2 = **(int **)(in_ECX + 0x14);
52	if (-1 < *param_3) {
52	void *local_10;
52	return -0x2985;
52	if ((0 < iVar1) || (iVar1 == 0)) {
52	FUN_210cfc20(0x300,0);
52	if ((sVar3 != 0) && (sVar2 == 0)) {
52	double dVar8;
52	double *pdVar9;
52	local_8 = (double *)0x0;
52	(**(code **)(**(int **)(in_ECX + 0x163) + 0x20))
52	(**(code **)(*piVar1 + 0x40))(*(undefined4 *)(in_ECX + 0x14f),&local_8);
52	if (0 < (int)param_3) {
52	(**(code **)(*in_ECX + 0x6a8))(local_8);
52	case 0x141:
52	(**(code **)(*(int *)in_ECX[0x16] + 0x44))(0xb,in_ECX[0x17],&local_8);
52	return -0x4005fff0;
52	switch(iVar2) {
52	iVar8 = local_14;
52	return -0x2799;
52	u64::u64(param_1,puVar3);
52	return 0xd79b;
52	iVar5 = FUN_21009150(param_1,0x25);
52	*(undefined4 *)
52	DIO Setting Out
52	Unregistered User
52	4#0
52	instr handle inM
52	[user-defined codes]*@@
52	FRj
52	A,RP
51	uVar4 = param_1;
51	uVar3 = param_1;
51	- occurrences: `2`
51	u$&g
51	u$&gf
51	PPPP
51	String
51	SNUM
51	3.1b7
51	XPTH0
51	DPTH0
51	range (auto:0)@@P
50	undefined1 local_34 [4];
50	if (sVar2 == -1) {
50	case -1:
50	if (sVar9 == 0) {
50	)) {
50	undefined2 uVar12;
50	if (!bVar3) {
50	case 0x27:
50	local_34 = 1;
50	local_8 = 2;
50	short local_4c;
50	undefined2 extraout_var_11;
50	if (param_4 == 2) {
50	int *local_10;
50	if ((local_8 == 0) &&
50	short local_2c;
50	double *pdVar1;
50	*puVar7 = 0;
50	param_3 = (int *)0x0;
50	return 0xd877;
50	uVar18 = uVar18 + 1;
50	short local_38;
50	if ((local_c == -0x272f) && (local_c = FUN_21146c41(param_1), local_c == 0)) {
50	if (-1 < local_14) {
50	param_12);
50	local_c = 0x600;
50	float local_1c;
50	EPS
50	EPj
50	(DSR)
50	Meas. High
50	output HW Handshake
50	Communications Error
50	Cal. Factor
50	xxxx
50	@f;E
50	u_f
50	ZXhh
50	tDTHP
49	if (local_18 != 0) {
49	undefined1 *puVar1;
49	error in (no error)R
49	Press 'Enter' when ready.
49	px>?
49	LICON
49	TCPTM
49	|DFDS
49	QRPQ
49	True SE
49	CODE
48	undefined1 local_24 [32];
48	DWORD local_14;
48	return param_2;
48	undefined2 *param_4)
48	NdrPointerBufferSize(&local_d4,param_3,"\x12");
48	NdrPointerMarshall(&local_d4,param_3,"\x12");
48	undefined2 param_4,undefined2 *param_5)
48	local_d4.Buffer = local_d4.Buffer + 10;
48	uVar3 = (int)*(short *)(in_ECX + 0x2c) | param_1 & 0xffffff00;
48	if (sVar3 == 1) {
48	local_24[1] = 0;
48	undefined4 *puVar10;
48	iVar13 = iVar13 + -1;
48	ushort uVar11;
48	sVar6 = 2;
48	double local_24;
48	puVar3[1] = 0;
48	double local_30;
48	local_c = 0.0;
48	undefined1 uVar4;
48	puVar1 = param_2;
48	switch(uVar2) {
48	uint local_44;
48	return 0xd5ce;
48	sVar10 = 0;
48	iVar8 = local_8;
48	if (sVar9 != 0) {
48	if (1 < param_2) {
48	iVar4 = iVar2;
48	uVar3 = uVar3 & 0xffff0000;
48	iVar14 = iVar14 + -1;
48	} while (iVar14 != 0);
48	if (param_2 != 2) {
48	if (param_4 < 0) {
48	undefined1 uVar3;
48	sVar5 = -0x28cc;
48	iVar5 = 1;
48	return 0xd89f;
48	if (0 < param_4) {
48	*(undefined1 *)((uint)param_2 + param_4) = 0;
48	undefined4 extraout_ECX;
48	if (bVar17) {
48	iVar7 = param_1;
48	piVar12 = piVar12 + 1;
48	sVar3 = 1;
48	switch(iVar1) {
48	puVar2 = param_2;
48	uVar5 = param_2;
48	undefined4 local_70;
48	iVar1 = *param_2;
48	iVar1 = *in_ECX;
48	lVar5 = tPIMMblockReferenceBase::allocateMemory
48	return 0xd67b;
48	if (*(int *)(in_ECX + 0x38) == 0) {
48	uVar2 = 8;
48	uVar2 = 9;
48	local_8 = 0xffffd698;
48	local_8 = (int)sVar2;
48	*param_1 = 0xffffd734;
48	return 0xd8de;
48	sVar1 = (short)param_2;
48	iVar1 = *(int *)(in_ECX + 0xab);
48	*param_2 = -0x2a3a;
48	if (*param_4 == 0) {
48	in_ECX[5] = 0;
48	case 0x82:
48	param_7 = (int *)0x0;
48	goto LAB_210b6999;
48	goto LAB_210bdfd0;
48	else if (iVar2 == 0) {
48	if ((0 < iVar1) || (iVar2 = 0, iVar1 == 0)) {
48	NIBS100::tBuffer::~tBuffer(this);
48	(**(code **)(iVar1 + 0x44))(0xb,uVar3);
48	case 0xc652:
48	case 0xc65c:
48	case 0xc670:
48	case 0xc68e:
48	case 0xc698:
48	case 0xc6a2:
48	case 0xc6ac:
48	case 0xc6ae:
48	case 0xc6b0:
48	case 0xc6b2:
48	case 0xc6b4:
48	case 0xc6b6:
48	case 0xc6b8:
48	case 0xc6ba:
48	*param_2 = 0x25;
48	*param_2 = 0x13d;
48	double dVar9;
48	if (uVar8 == 0) break;
48	puVar25 = (undefined1 *)0xac;
48	case 0xe9:
48	local_84 = 0;
48	param_4[1] = uVar1;
48	uVar2 = Ordinal_65(*param_1,&param_3);
48	*param_3 = 0x8c;
48	(**(code **)(*in_ECX + 0x634))
48	pdVar10 = param_12;
48	iVar2 = FUN_21121090(uVar3,&local_8);
48	puVar1 = *(undefined4 **)(this + 0x50);
48	short local_28;
48	uVar8 = (int)param_3 & 0x80000001;
48	local_8 = FUN_21171bda(param_1,&local_10);
48	*(byte *)((int)local_24 + (local_20 & 0xff) * 0x10 + 0x95b) =
48	*(byte *)(local_24 + (local_20 & 0xff) * 8 + 0x4b2) =
48	*(byte *)((int)local_24 + (local_c & 0xff) + (local_1c & 0xff) * 0x10 + 0x957) =
48	iVar5 = *(int *)(*(int *)(param_2 + 0x94e) + param_3 * 4);
48	if ((param_7 & 0xffff) == 1) {
48	sVar6 = strlen(_Str);
48	(**(code **)(*local_c + 0x24))
48	iVar13 = *piVar17;
48	param_15 = (int *)0x0;
48	if (((*(int *)(local_8 + 0x1da) != 0) || (local_c != 0)) ||
48	*(undefined2 *)(iVar9 + (short)iVar19 * 2) = uVar7;
48	local_20 = (short)local_14 * 0x18;
48	iVar9 = (int)(short)local_14;
48	puVar22 = puVar22 + 1;
48	} while (iVar11 < (short)local_34);
48	sVar4 = FUN_21171bda(*puVar26,&local_18);
48	fU&gf
48	function (open:0)
48	(DTR)
48	MUUUU
48	device`
48	x8<=
48	input alt HW HShk
48	wwwwwwwwwwwww
48	CLRPAR
48	<FTAB
47	uVar6 = param_2;
47	[error code] (0)
47	MQP
47	EPh
47	No Error
47	;:::::::::::::::::
47	New Occurrencer
47	Serial Number
47	NSTD
47	LLLLLL
47	'[max characters per line]  (no limit:0)
47	EOF?
47	FPanel Rev# Out
47	Test data in
46	uVar2 = *puVar1;
46	undefined1 local_a [2];
46	uVar5 = param_1;
46	if ((short)local_18 != 0) {
46	param_5 = param_5 + -1;
46	local_24 = local_24 + 1;
46	if (cVar3 != '\0') {
46	if (param_6 != 0) {
46	iVar12 = 0;
46	sVar5 = (short)param_2;
46	char *pcVar7;
46	undefined2 extraout_var_12;
46	int iVar16;
46	iVar5 = (int)sVar2;
46	char local_6;
46	int *piVar9;
46	local_c = 0x200;
46	if (iVar11 != 0) {
46	undefined4 local_a4;
46	if ((int)uVar3 < 0) {
46	if (uVar10 != 0) {
46	*(undefined4 *)param_12 = 0;
46	return -0x2a32;
46	lVar4 = tPIMMblockReferenceBase::allocateMemory
46	case 200:
46	*param_3 = 0x15;
46	short local_10 [2];
46	while (-1 < (int)param_2) {
46	if (-1 < (int)param_2) {
46	} while (uVar6 < uVar8);
46	switch((undefined2)local_8) {
46	local_24 = local_30;
46	"
46	syncClose(*(iSync **)(param_1 + 0x138),(long *)0x0);
46	sourceH
46	4;0
46	(RTS)
46	(CTS)
46	7UUUU
46	410
46	4PTH0
46	@PTH0
46	4b0
46	INSTR{}
46	YYYYYY
46	input HW Handshake
46	output alt HW HShk
46	file path (" ")
46	ESV
46	Avg Reading
46	False RE
46	HBDPW
46	\RTSG
46	$FPTD
46	8CPMp
46	(VCTP
45	int local_e;
45	undefined4 *puVar12;
45	status[8] - I/O Completed
45	ZV(bool) status: TRUE if an error has occurred. If status is TRUE, this VI does nothing."
45	DIO Setting In
45	fU&g
45	error in is a cluster of three elements (error?, code, and source) that describe the upstream error state, that is, the existance of any error preceeding the execution of the VI.  The VI executes normally only if no incoming error exists; otherwise it merely passes the error in value to error out.  error? is TRUE if an error occurred; the default value is FALSE.  code is the error code; the default value is 0.  source is in most cases the name of the VI or function that produced the error; the default value is an empty string.
45	error out is a cluster of three elements (error?, code, and source) that describe the error state following the execution of the VI.  If an incoming error does not exist, the VI executes normally and error out describes the VI's error state; if an incoming error exists, error out equals error in.
45	pos mode (rel. to end:1)
45	4f0
45	$RPf
45	DTHPD4iO
44	size_t sVar2;
44	DWORD local_18;
44	*(undefined ***)this = &_vftable_;
44	undefined2 in_stack_0000001e;
44	return 2;
44	FUN_2100e080(param_2,param_3);
44	return param_3;
44	local_d4.MaxCount = param_8;
44	local_d4.BufferLength = 6;
44	NdrGetBuffer(&local_d4,6,param_1);
44	*param_3 = *(undefined2 *)local_d4.Buffer;
44	if ((short)local_2c == 0) {
44	undefined2 __cdecl
44	if (sVar10 != 0) {
44	iVar4 = param_1;
44	case 0x29:
44	if (sVar11 != 0) {
44	iVar1 = iVar1 + 1;
44	uint local_50;
44	FUN_21185130(uVar1,local_2c & 0xffff,*local_1c);
44	local_2c = local_2c + 1;
44	psVar5 = psVar5 + 1;
44	iVar7 = local_8;
44	if (sVar11 == 0) {
44	*param_3 = sVar6;
44	*psVar2 = sVar5;
44	sVar12 = sVar12 + 1;
44	else if (param_3 == 0xc364) {
44	return -0x2728;
44	if (param_9 == 0) {
44	short extraout_AX;
44	local_6 = '\x01';
44	if (piVar2 != (int *)0x0) {
44	param_1 = (int *)*param_1;
44	_STCMgrControlUser_12(uVar2);
44	undefined4 uStack_44;
44	uint local_4c;
44	local_8 = -0x2717;
44	return -0x29bf;
44	undefined4 local_16;
44	FUN_210c4a40();
44	if (*(int *)(param_1 + 0x2b9) != 0) {
44	if (iVar4 == 1) {
44	*puVar6 = 0;
44	iVar1 = Ordinal_17(&local_14);
44	if (local_14 == -0x6d63) {
44	iVar1 = Ordinal_64(local_14,(int)param_1,&local_c);
44	if (local_c == -0x6d63) {
44	iVar1 = Ordinal_63(local_c,1,0x19,0,0,0,&local_10);
44	iVar1 = Ordinal_33(local_c,0x582,&local_8);
44	iVar1 = Ordinal_33(local_c,0x586,&local_8);
44	iVar1 = Ordinal_33(local_c,0x587,&local_8);
44	local_10 = FUN_2104a4d0(local_c,1,0x20,0x56a,param_3);
44	iVar1 = Ordinal_33(local_c,0x583,&local_8);
44	local_10 = FUN_2104a4d0(local_c,1,uVar2,0x56a,param_3);
44	local_8 = (uint)sVar3;
44	*param_8 = 1;
44	if (0 < sVar2) {
44	*in_ECX = param_1;
44	pvVar5 = (void *)0x0;
44	pvVar4 != (void *)0x0)) {
44	in_ECX[4] = 0;
44	if (*piVar1 < 0) {
44	piVar3 = *(int **)(in_ECX + 0x138);
44	*piVar1 = -0x2896;
44	undefined4 *local_8;
44	local_8 = pvVar7;
44	pvVar7 = local_8;
44	} while (bVar1);
44	0x5a,0,0x5a,0,0x5a,0,0x5a,0,0x5a,0,0x5a,0,0x5a,0,0x5a,0);
44	FUN_210cb4d0();
44	if (-1 < iVar4) {
44	return 0xffffd875;
44	return 0xffffb1dd;
44	if (0 < (int)param_2) {
44	(**(code **)(**(int **)((int)in_ECX + 0x157) + 0x34))
44	case 0xea:
44	case 0xeb:
44	case 0xec:
44	uVar1 = 0xffffd75d;
44	iVar5 = FUN_21058a50();
44	iVar4 = (**(code **)(*in_ECX + 0x6cc))();
44	iVar1 = (**(code **)(*in_ECX + 0x6d0))();
44	if (iVar1 == 8) {
44	else if (iVar1 == 0x10) {
44	if (iVar1 != 0x20) {
44	(**(code **)(*in_ECX + 0x6a8))(0xffffd5a8);
44	_Src = _Src + 2;
44	_Src = _Src + 4;
44	if ((sVar4 != 1) || (cVar1 == '\0')) {
44	psVar14[sVar4 * 8 + 5] = 0;
44	} while (sVar4 < 3);
44	return -(ushort)(iVar1 != 0) & 0xd7fd;
44	return -0x2712;
44	local_1c = 1.0;
44	local_8 = (ushort)uVar3;
44	*(undefined1 *)(param_1 + 0x12) = 1;
44	*(undefined4 *)param_7 = 0;
44	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 8;
44	*in_stack_0000002c = (int)(puVar1 + uVar12);
44	sVar4 = (short)uVar9;
44	if (bVar19) {
44	iVar5 = FUN_21183e00(local_40);
44	See the Data Acquisition VI Reference Manual for your platform for tables listing the default settings and ranges for this VI for the boards with which it will work.
44	param_5 = (undefined4 *)0x0;
44	"fQfU&gf
44	0LVIN
44	coderP0
44	pwwww
44	GPIB status vector:
44	status[0] - Device Clear State
44	status[1] - Device Trigger State
44	status[2] - Listener Active State
44	status[3] - Talker Active State
44	status[4] - Attention line asserted
44	status[5] -
44	Controller In Charge
44	status[6] - Remote State
44	status[7] - Lockout State
44	status[9] - not used
44	status[10]- not used
44	status[11]- not used
44	status[12]- SRQ line asserted when CIC
44	status[13]- EOI or EOS detected
44	status[14]- Timeout occured
44	0%;#
44	xPTH0
44	++++++++++
44	laPTH0
44	source ("")@
44	%` 5
44	Receive.viND
44	RD8840A.VIV
44	Initial Choices
44	Return Terminator
44	T_Setup.viW
44	MPQ
44	QRPW
44	udf@PP
44	6666
44	Fluke 8840A.viZ
43	DECIMAL       HEXADECIMAL     DESCRIPTION
43	--------------------------------------------------------------------------------
43	int local_16;
43	local_2c = 1;
43	iVar4 = 1;
43	undefined2 local_38;
43	return local_28;
43	local_c = local_10;
43	ulong uVar3;
43	undefined2 *puVar9;
43	start path  (Not A Path)
43	Comm Error In
43	Most applications need only connect wires to the controls and indicators displayed in bold.  Connections to other controls and indicators are useful only if specifically needed.
43	offset past number
43	SVWf
43	<vilib>
43	0PTH0
43	pPTH0
43	490
43	D1XE
43	wwwwwwwwwww
43	UUT Comm.viU
43	Disk Rev# Out
43	QRUh
42	local_1c = param_4;
42	if (sVar9 == 1) {
42	uVar12 = FUN_2103d030(param_4);
42	if ((short)local_14 == 0) {
42	if ((short)param_2 == 2) {
42	sVar6 = (short)param_1;
42	ushort *puVar4;
42	short local_44;
42	return uVar9;
42	sVar4 = (short)param_2;
42	if ((short)local_1c != 0) {
42	undefined2 extraout_var_13;
42	switch(param_2 & 0xffff) {
42	int iVar15;
42	short local_c [2];
42	local_78 = 0;
42	uVar6 = ftol();
42	undefined8 local_c;
42	undefined2 *local_24;
42	_memDelete(pvVar4);
42	case 0x84:
42	if (ptVar8 != (tBuffer *)0x0) {
42	case 0xc666:
42	case 0xc67a:
42	case 0xc684:
42	case 0xc6bc:
42	case 0xc634:
42	case 0xc63e:
42	*param_2 = 0x57;
42	double *local_8;
42	pdVar6 = pdVar6 + 1;
42	pdVar11 = pdVar11 + 1;
42	if ((int)uVar4 < 0) {
42	local_30 = 1.59149684406881e-312;
42	tTimerTimeWasterSleep::getResolutionTimeUnit
42	if ((piVar10 == (int *)0x0) || (-1 < *piVar10)) {
42	uVar8 = tTimerTimeWasterSleep::canSleepNow
42	FUN_210825b0();
42	(**(code **)(**(int **)((int)extraout_ECX + 0x163) + 0x24))();
42	puStackY_34 = &stack0xfffffff8;
42	local_38 = *(undefined1 **)((int)extraout_ECX + 0x14f);
42	local_3c = (int *)0x10;
42	if (iVar6 != 0) goto switchD_210fe9fe_default;
42	puVar5 = (undefined1 *)0xac;
42	iVar13 = local_c;
42	sVar2 = FUN_21129b00(CONCAT22((short)((uint)&local_10 >> 0x10),param_1),*local_1c,
42	sVar2 = FUN_21166c24(*(undefined4 *)(local_50 + 5));
42	FUN_211431c0(*(undefined4 *)(param_2 + 0xe + local_18 * 6),
42	*(undefined2 *)(param_2 + 0x12 + local_18 * 6)),iVar3);
42	local_8c = 0;
42	case 0x6e:
42	local_10 = (short)uVar4;
42	local_20 = local_2c;
42	iVar7 = *(int *)(*(int *)(param_2 + 0x94e) + 0x80);
42	&DAT_2120cff0,1,&local_8,
42	local_a,local_18,0,local_c),
42	if ((sVar3 == 1) || (sVar3 == 10)) {
42	psVar19 = local_10;
42	sVar4 = *(short *)(*(int *)(puVar26 + 3) + (int)local_c * 2);
42	puVar22 = local_8;
42	if (local_48 != (ushort *)0x0) {
42	puVar25 = (ushort *)((int)puVar25 + 1);
42	*param_14 = (ushort)param_9;
42	E gf
42	PLabl
42	daqtabls
42	dLIfp
42	`icl4
42	LEADSHRT.viW
42	the LC103 Final Test Box.
42	mark after read (bytes)
42	GetCommErr
42	message@@P
42	Port Width for the Lab boards, SCXI-1200, DAQBox-1200, DIO-24, DIO-32F, DIO-96, and AT-MIO-16D ports 2, 3 and 4 should be at least 8.
42	FPanel Rev# In
42	t_f
42	test data out
42	d$ZY=t
41	undefined2 local_e;
41	error descriptions (hidden)
41	,LIbd
41	@BDHP
41	PRT
41	4@0
41	?>?~
41	Disabled Items
41	@0Input String0
41	Error\FC In(F)&
41	DTRec
41	QRPR
41	SQRVWQRU
40	char *pcVar6;
40	return -0x28a1;
40	undefined4 local_a;
40	FUN_21185030(*(undefined4 *)(param_1 + 0xc),2);
40	FUN_21185030(*(undefined4 *)(param_1 + 0xc),3);
40	local_10 = 3;
40	nOutBufferSize = 0x20;
40	nInBufferSize = 0x20;
40	DWORD local_10;
40	param_11,param_12,param_13);
40	(piVar1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9,param_10
40	if ((short)uVar1 != 0) {
40	param_10,param_11,param_12,param_13,param_14);
40	param_10,param_11,param_12);
40	(daqDevice *this,short param_1,short param_2,short param_3,short param_4,short param_5,
40	NdrPointerBufferSize(&local_d4,param_5,"\x12");
40	NdrPointerMarshall(&local_d4,param_5,"\x12");
40	NdrConvert(&local_d4,"N\x0fN\x06N\x06N\x06Q\x01\x06");
40	*param_4 = *(undefined2 *)local_d4.Buffer;
40	local_d4.BufferLength = 8;
40	NdrGetBuffer(&local_d4,8,param_1);
40	ULONG_PTR *pUVar1;
40	pUVar1 = (ULONG_PTR *)((uint)(local_d4.Buffer + 3) & 0xfffffffc);
40	pdVar8 = pdVar8 + 1;
40	local_24 = param_3;
40	local_1c = &stack0xffffffc0;
40	iVar2 = sVar1 + 1;
40	undefined4 uStack_18;
40	if ((short)param_5 != 0) {
40	return (uint)uVar6;
40	byte *pbVar1;
40	iVar2 = local_8;
40	double local_2c;
40	switch(iVar5) {
40	case 0x3c:
40	undefined2 local_54;
40	undefined4 local_52;
40	switch(sVar4) {
40	iVar5 = 2;
40	bVar2 = *pbVar1;
40	sVar2 = (short)param_1;
40	sVar5 = (short)param_1;
40	*local_c = *local_c & ~(ushort)local_10;
40	sVar4 = 1;
40	else if (sVar6 == 1) {
40	if (param_2 == 4) {
40	iVar11 = param_2;
40	local_8 = uVar6;
40	iVar2 = 1;
40	puVar4 = local_8;
40	undefined1 local_28 [8];
40	return -0x2722;
40	*puVar2 = uVar1;
40	*param_1 = puVar1;
40	*puVar1 = 1;
40	return 0xd72c;
40	if ((short)param_9 == 0) {
40	bVar5 = true;
40	if (bVar5) {
40	local_1c = 2;
40	if (param_10 == 0) {
40	short *local_10;
40	int local_1a;
40	dwIoControlCode = 0xabcd2024;
40	piVar7 = piVar7 + 1;
40	} while (local_24 != 0);
40	local_5 = 0x80;
40	if (param_5 == 2) {
40	piVar5 = piVar5 + 1;
40	sVar10 = sVar10 + 1;
40	local_3c = 1;
40	bVar6 = true;
40	if (bVar7) {
40	uVar2 = uVar2 & 0xffff0000;
40	piVar4 = piVar4 + 1;
40	sVar1 = daqDevice::Get_DAQ_Device_Info_TheVirtualThing(in_ECX,param_1,param_2,param_3);
40	if ((param_4 != 0) && (param_4 != 1)) {
40	if ((-1 < param_2) && (param_2 < 4)) {
40	FUN_2107ce00(param_1,param_2,param_6);
40	case 0x532a:
40	uVar1 = uVar1 & 0xffff0000;
40	uVar7 = ftol();
40	case 0x22:
40	puVar5 = (u64 *)FUN_21058950();
40	uVar7 = param_2;
40	piVar10 = local_3c;
40	uVar1 = *(uint *)(in_ECX + 0x2c);
40	uVar1 = local_8;
40	else if (uVar4 == 0) {
40	iVar1 = in_ECX[1];
40	if (uVar5 != 0) {
40	in_ECX[10] = 0;
40	if (*(int *)(in_ECX + 8) != 0) {
40	local_20 = 0.0;
40	float10 fVar10;
40	double local_18;
40	pdVar7 = pdVar7 + 1;
40	piVar1 = param_3;
40	*param_6 = (int)sVar1;
40	(pvVar2 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_8),
40	uVar1 = (**(code **)(**(int **)(in_ECX + 0x3a) + 0x7c))();
40	float10 fVar4;
40	short local_48;
40	local_24 = param_1;
40	pvVar2 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_8);
40	FUN_210b6be0();
40	uVar15 = uVar15 + 1;
40	in_ECX[8] = 0;
40	param_2 = &local_8;
40	piVar5 = &local_8;
40	return in_EAX;
40	local_8 = iVar3;
40	(**(code **)(**(int **)(in_ECX + 0xc) + 0x10))(0xffff0012,1,param_1);
40	dVar3 = 0.0;
40	goto LAB_210b3a67;
40	if (lVar4 == 0) {
40	FUN_21163b30();
40	void *local_c;
40	local_8 = (uint)sVar4;
40	*param_6 = iVar1;
40	return 0xd8ee;
40	local_8 = iVar1;
40	FUN_210ce680(param_1,param_2,0);
40	iVar3 = **(int **)(in_ECX + 0x1d6 + param_1 * 4);
40	(**(code **)(iVar5 + 0x44))(0xb,uVar3);
40	(**(code **)(*piVar2 + 0x20))(0x82,0x57,*(undefined4 *)(in_ECX + 0x3dc),&local_8);
40	if ((int **)(int)sVar3 == (int **)0x0) {
40	uVar4 = *(undefined4 *)((int)in_ECX + 0x16);
40	double dVar15;
40	double *pdVar3;
40	pdVar10 = pdVar10 + 1;
40	_memDelete(puVar6);
40	if (param_3 < 1) {
40	(**(code **)(*piVar2 + 0x40))(*(undefined4 *)((int)in_ECX + 0x14f),&local_8);
40	if (*in_ECX != 0) {
40	uVar2 = palStatusMapStatusValue(uVar2);
40	(**(code **)(*piVar1 + 0x40))(*(undefined4 *)(local_8 + 0x14f),param_1);
40	if ((param_4 < 0) || (7 < param_4)) {
40	iVar6 = puVar1[2];
40	iVar11 = (int)sVar13;
40	if (0 < (short)local_c) {
40	short local_6c;
40	cVar1 = FUN_211525de(local_8);
40	CONCAT22(sVar4 >> 0xf,
40	*(byte *)(param_2 + 0x957 + sVar4 * 0x10 + (int)sVar5) =
40	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 0x80;
40	return 0xd88f;
40	return -0x2724;
40	return 0xd897;
40	if (0 < (short)local_10) {
40	if (0 < psVar2[5]) {
40	goto LAB_211cf8dd;
40	return dVar1;
40	Inductance Decade Box (L Terminal)
40	]_^[
40	`MLbl
40	Continue
40	dup refnumu
40	@ICON
40	Start Disable?
40	Port Select
40	CPOH
40	@ Error\FC Out@0
40	ESVW
40	TEST
40	ITERATIONS
40	dLIvi
39	uint local_5c;
39	uint local_48;
39	undefined2 local_4a;
39	undefined2 local_3c;
39	undefined2 local_1a;
39	undefined2 local_18;
39	iVar3 = 4;
39	uVar3 = uVar4;
39	===Short the UUT leads to the
39	BBBNow connect the red lead to the
39	error codes (hidden)
39	error in (no error)6@P
39	TLabl
39	4,0
39	instr handle in[
39	ffffffffff33ffffff33
39	ff33ffff3333ff33ff
39	33ffff33ff3333ff3333
39	3333ff333333333333
39	s|8>
39	'new file path (Not A Path if cancelled)
39	default name
38	local_e = 0;
38	if (bVar3) {
38	uVar4 = extraout_var;
38	param_9 = param_9 + 1;
38	local_20 = local_24;
38	int *local_14;
38	sVar6 = (short)param_2;
38	undefined8 local_10;
38	sVar11 = (short)param_2;
38	if (local_20 == 0) {
38	short local_14 [2];
38	undefined4 *puVar14;
38	local_98 = 0;
38	if (param_5 < 1) {
38	return -0x271f;
38	short *psVar9;
38	int *piVar11;
38	param_3 = 1;
38	local_24 = 1;
38	uVar6 = 3;
38	psVar7 = (short *)0x0;
38	int param_6)
38	if (sVar8 == 0) {
38	if ((short)local_30 != 0) {
38	sVar4 = -0x2713;
38	int *piVar10;
38	if (puVar6 == (undefined4 *)0x0) {
38	undefined4 local_94;
38	undefined4 local_8c;
38	return 0xd89e;
38	tMemBlockReferenceBase *this;
38	if (iVar6 != 0) break;
38	float10 fVar11;
38	pdVar5 = pdVar5 + 1;
38	param_5 = (int *)0x0;
38	iVar5 = iVar4;
38	case 0xc648:
38	switch(param_6) {
38	local_18 = local_18 + -1;
38	if ((short)local_34 != 0) {
38	case 0x80:
38	local_8 = *(int *)(param_1 + 10);
38	if (param_3 == 0x20) {
38	local_c = 0x40;
38	Generic File IO Error
38	Windows Error During Print
38	Memory Error During Print
38	Can't Open Device
38	local_8 = (**(code **)(*(int *)param_1[3] + 0x14))(param_5,&local_c,&local_14,&local_10);
38	DDO
38	hFPHP
38	######
38	Symbols
38	SUUU
38	out ref
38	in ref
38	+***
38	pattern@
38	DIGPRTWR
38	Read
38	New Occurrencered
38	error codes
38	message
38	Cal Values
38	!_^f
38	SVW3
38	QRPV
38	ERPQ
38	9 9$9(9,9094989<9@9D9H9L9P9T9X9\9`9d9h9l9p9t9x9|9
38	""""""))))))UUUUUUMMMMMMBBBBBB999999
38	ZYQRP
38	ZhhU
38	[exception source]6@P
38	PBDPW
38	E`QRh
37	undefined2 local_28;
37	if (uVar5 == 0) {
37	file path is the path name of the file.  If file path is empty (default value) or is Not A Path, the VI displays a File dialog box from which you can select a file.  Error 43 occurs if the user cancels the dialog.
37	start path (Not A Path)
37	- sources: `Final_Cal_103FIN.EXE.strings.txt, Source_LV3_1_103f_cal.llb.strings.txt`
37	u(&g
37	tf=
37	CIN
37	!f=
37	Memory Full
37	Out of Zone
37	End of File
37	File Already Open
37	File Not Found
37	File Permission Error
37	Disk Full
37	Duplicate Path
37	Too Many Files Open
37	Not Enabled
37	Resource File Not Found
37	Cannot Add Resource
37	Resource Not Found
37	Image Not Found
37	Image Memory Error
37	Pen Does Not Exist
37	Config Bad Type
37	Config Token Not Found
37	Config Parse Error
37	Config Memory Error
37	Bad External Code Format
37	Bad External Code Offset
37	External Code Not Present
37	Null Window
37	Destroy Window Mixup
37	Null Menu
37	Print Aborted
37	Bad Print Record
37	Print Driver Error
37	Print Dialog Error
37	Generic Print Error
37	Invalid Device Refnum
37	Device Not Found
37	Device Parameter Error
37	Device Unit Error
37	Device Call Aborted
37	Generic Error
37	Cancelled By User
37	|LIds
37	d$Z)
37	@HIST
37	instr handle in@
37	`VICD
37	|LIvi
37	04D0
37	statusw
37	intensity (0-255) - ignored.
37	Message4
37	$hhV
37	dfdP2
37	txdP2
36	uVar8 = 2;
36	if (param_3 == 0x4c90) {
36	uVar5 = extraout_var;
36	uVar3 = FUN_21185030(*(undefined4 *)(param_1 + 0xc),0);
36	FUN_21185070(*(undefined4 *)(param_1 + 0xc),2);
36	undefined4 local_e;
36	lpBytesReturned = (LPDWORD)&param_2;
36	if ((short)uVar4 < 0) {
36	undefined2 in_stack_00000022;
36	undefined2 in_stack_0000001a;
36	undefined2 in_stack_00000026;
36	long,unsigned long) */
36	size_t sVar3;
36	return sVar1 + 1;
36	local_d4.Buffer = local_d4.Buffer + 0x14;
36	NdrPointerBufferSize(&local_d4,param_7,"\x12");
36	*(ULONG_PTR *)((int)local_d4.Buffer + 4) = param_6;
36	NdrPointerMarshall(&local_d4,param_7,"\x12");
36	undefined2 *param_8)
36	local_d4.BufferLength = 2;
36	NdrGetBuffer(&local_d4,2,param_1);
36	*(undefined2 *)(local_d4.Buffer + 8) = param_6;
36	*(undefined4 *)(local_d4.Buffer + 8) = param_5;
36	undefined2 *param_9)
36	local_d4.MaxCount = param_7;
36	undefined2 *param_5)
36	uVar3 = FUN_2100dee0(*(undefined4 *)(in_ECX + 4));
36	if ((short)local_28 == 0) {
36	undefined4 *puVar13;
36	*param_12 = 0;
36	DWORD DVar1;
36	if ((short)param_2 != 2) {
36	puVar13 = puVar13 + 1;
36	short *local_8;
36	if (sVar2 == 0x12) {
36	if (sVar2 == 6) {
36	double local_3c;
36	uVar4 = local_8;
36	uVar8 = param_3;
36	undefined4 unaff_EBX;
36	return param_3 & 0xffff0000;
36	param_2 = 2;
36	switch(sVar1) {
36	local_54 = 0xd;
36	local_52 = *(undefined4 *)(param_1 + 0x10);
36	local_4e = FUN_21184ef0(*(undefined4 *)(param_1 + 0xc));
36	local_48 = *(undefined4 *)(param_1 + 0x394);
36	sVar11 = sVar11 + 1;
36	return uVar17;
36	puVar3 = DAT_212191c0;
36	return (uint)uVar1 << 0x10;
36	double local_10;
36	return 0xd5cf;
36	bVar4 = bVar4 + 1;
36	sVar4 = (short)param_1;
36	return 0xd828;
36	uVar6 = param_1;
36	_param_1 = 0;
36	sVar7 = FUN_2104a3a0(param_1);
36	param_4[1] = 0;
36	if ((short)uVar8 != 0) {
36	uVar7 = 2;
36	psVar7 = psVar7 + 1;
36	return local_18 & 0xffff;
36	iVar3 = (int)param_2;
36	uVar3 = param_3;
36	if (sVar4 == 2) {
36	u64 *puVar7;
36	puVar6 = param_9;
36	undefined4 uStack_78;
36	u64::u64(local_40,puVar4);
36	if (sVar3 == 4) {
36	iVar7 = 2;
36	local_c = 8;
36	psVar9 = psVar9 + 1;
36	psVar8 = psVar8 + 1;
36	return uVar3 & 0xffff;
36	iVar2 = 2;
36	float10 fVar5;
36	uVar4 = uVar3;
36	puVar14 = puVar14 + 1;
36	*(byte *)(iVar2 + 0xae1) = bVar16;
36	param_1 = param_2;
36	uVar4 = uVar1;
36	if ((short)uVar5 < 0) {
36	uVar3 = extraout_var;
36	goto LAB_2106cf49;
36	pcVar9 = (char *)FUN_2104a6a0(param_1 + -1);
36	param_1 = 1;
36	char local_7;
36	if ((short)param_7 == 0) {
36	uVar8 = uVar7 & 0xffff;
36	} while ((int)uVar7 < (int)sVar4);
36	if (cVar2 == '\0') {
36	sVar2 = -0x2713;
36	puVar15 = (undefined1 *)(int)(short)local_c;
36	if (puVar15 < param_5) {
36	iVar9 = (int)puVar15 * 2;
36	} while (puVar15 < param_5);
36	FUN_21185130(*(undefined4 *)(param_2 + 0xc),6,(int)*(short *)(param_2 + 0x421));
36	bVar6 = false;
36	iVar9 = local_14;
36	while (iVar2 != 0) {
36	uVar6 = uVar6 - 1;
36	CloseHandle(DAT_2121a078);
36	CloseHandle(DAT_2121a07c);
36	sVar6 = 1;
36	undefined4 local_bc;
36	local_7c = 0;
36	local_14 = 8;
36	uVar2 = extraout_var;
36	if (local_34 == 0) {
36	if (param_2 != (int *)0x0) {
36	return 0xffffd5a3;
36	local_74 = 0;
36	local_6c[0] = param_2;
36	undefined4 uStack_14;
36	*param_3 = iVar2;
36	undefined4 uStack_38;
36	*psVar6 = sVar1;
36	if (puVar3 == (undefined4 *)0x0) {
36	pvVar3 != (void *)0x0)) {
36	iVar12 = iVar12 + 1;
36	if (param_4 == (int *)0x0) {
36	if (piVar3 == (int *)0x0) {
36	if (param_1 < 0) {
36	uVar4 = uVar5;
36	local_30 = 0.0;
36	sVar6 = FUN_21092c30(psVar2);
36	float10 fVar8;
36	sVar2 = FUN_210918a0(param_1,param_4,local_8,_param_2,uVar6,param_6,&local_14);
36	*puVar5 = 0;
36	return (uint)uVar2;
36	local_8 = -0x2a3a;
36	piVar1 = param_6;
36	lVar1 = tPIMMblockReferenceBase::allocateMemory
36	param_10 = (uint)sVar1;
36	param_10 = 0;
36	in_ECX[3] = 0;
36	in_ECX[9] = 0;
36	in_ECX[0x12] = 0;
36	(**(code **)(**(int **)(in_ECX + 0xc) + 0x10))(0xffff0007,1,param_1);
36	iVar6 = *(int *)(*(int *)(in_ECX + 0x10) + 4);
36	iVar7 = piVar3[1];
36	(**(code **)(**(int **)(in_ECX + 0xc) + 0x10))(0xffff000d,0,param_1);
36	in_ECX[1] = param_1;
36	local_8 = local_c;
36	(**(code **)(**(int **)(in_ECX + 0x138) + 0x10))(&param_4);
36	in_ECX[2] = param_3;
36	char *_Dest;
36	lVar1 = tPIMMblockReferenceBase::allocateMemory((tPIMMblockReferenceBase *)&param_2,0xc,1,8);
36	(pvVar2 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&param_2),
36	iVar1 = (**(code **)(*in_ECX + 0xbc))(param_3);
36	if ((param_2 != 1) && (param_2 != 2)) {
36	return 0xd8e5;
36	else if (uVar2 == 0) {
36	float local_18;
36	float local_10;
36	if (param_1 != 0xb) {
36	if ((int)uVar1 < 1) {
36	(pvVar3 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_c),
36	if ((iVar1 != 0) ||
36	FUN_210cfc20(0x301,0);
36	if (0 < (short)param_1) {
36	uVar4 = CONCAT44(piVar5,uVar1);
36	case 0xc62a:
36	(**(code **)(*piVar2 + 0x24))(0xcc,1,*(undefined4 *)(in_ECX + 0x3dc),&local_8);
36	(**(code **)(*piVar3 + 0x4c))(in_ECX[0xf7],&local_8);
36	iVar1 = ftol();
36	(**(code **)(*piVar1 + 0x40))(*(undefined4 *)((int)in_ECX + 0x16),&local_8);
36	*psVar9 = -0x2a3a;
36	uVar18 = 0;
36	double dVar10;
36	double dVar13;
36	double dVar16;
36	(**(code **)(**(int **)(in_ECX + 0x163) + 0x24))
36	((tPIMMblockReferenceBase *)&stack0xffffffec,0x128,0,0);
36	iVar6 = FUN_210f4df0();
36	iVar7 = FUN_21082470();
36	if (*(int *)(iVar7 + 0x14) != 0) {
36	local_30._4_4_ =
36	(double *)
36	if (((piVar10 != (int *)0x0) && (*piVar10 < 0)) || (iVar9 = FUN_21058a50(), iVar9 == 0)) {
36	local_30._4_4_ = (double *)&stack0xffffffe0;
36	tTimerTimeWasterSleep::sleep((tTimerTimeWasterSleep *)(iVar7 + 0x24));
36	iVar7 = *piVar10;
36	puVar5 = &stack0xfffffff8;
36	uVar13 = ftol();
36	goto LAB_210fec51;
36	this = (tMemBlockReferenceBase *)0x3e;
36	if (iVar6 != 0) goto switchD_210ff5fa_default;
36	goto LAB_210ff84d;
36	sVar1 = FUN_211040f0(param_2);
36	return 0xffffd8e7;
36	(**(code **)(**(int **)(in_ECX + 4) + 0x20))(4,0,&local_c,&local_8);
36	float *pfVar2;
36	tTimerTimebaseEfficient::getResolutionTimeUnit(local_48,(long *)&param_1);
36	int local_60;
36	(**(code **)(*piVar1 + 0x40))();
36	} while (uVar10 < 0x4000);
36	_Dst = _Dst + 1;
36	bVar7 = (byte)(((int)(iVar11 + (iVar11 >> 0x1f & 3U)) >> 2) << 1);
36	*(uint *)(iVar6 + 0x31) = uVar12;
36	dwIoControlCode = 0xabcd2030;
36	memDelete(param_4);
36	return pcVar5;
36	local_8 = FUN_21171bda(param_1,&local_18);
36	if ((param_2 < 1) || (*(short *)(local_18 + 0x10) < param_2)) {
36	*(undefined2 *)(local_1c + 0x695 + local_18 * 2) = 0;
36	if ((param_2 < 1) || (*(short *)(local_14 + 0x10) < param_2)) {
36	(*(char *)(param_1 + 0x12) == '\0')) {
36	local_20 = CONCAT31(local_20._1_3_,(char)local_20 + '\x01');
36	for (local_8 = 0; (int)local_8 < (int)(uint)*(ushort *)(param_1 + 0xa8b);
36	local_8 = local_8 + 1) {
36	*(byte *)(param_1 + 0x959 + local_8 * 0x10) =
36	*(byte *)(param_1 + 0x95a + local_8 * 0x10) =
36	*(byte *)(param_1 + 0x95b + local_8 * 0x10) =
36	*(byte *)(param_1 + 0x964 + local_8 * 0x10) =
36	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 1;
36	*param_6 = (double)local_30;
36	*param_7 = (double)local_2c;
36	if (local_90 == -NAN) {
36	local_20 = local_90;
36	local_1c = local_8c[0];
36	iVar7 = *(int *)(*(int *)(param_2 + 0x94e) + local_2c * 4);
36	int local_78;
36	uVar5 = 1000000;
36	puVar3 = (u64 *)u64::u64(local_6c,(u64 *)&param_2);
36	case 0x6f:
36	local_18,0,local_c);
36	return -0x2801;
36	return 0xd8ec;
36	case 0x65:
36	return 0xd63a;
36	if (0.0 < param_2) {
36	*(undefined4 *)(iVar12 + 0x120));
36	psVar4 = (short *)FUN_2100a860(param_1,local_70);
36	goto LAB_211a02db;
36	iVar11 = local_14;
36	uVar9 = (uint)*puVar15;
36	return -0x2739;
36	if (iVar13 == 0) break;
36	if ((iVar13 == 0) ||
36	puVar11 = (undefined4 *)(local_8 + 0x122);
36	(uVar9 = param_7, (bVar12 & 0xf) == 6)) {
36	if (((*(int *)(local_8 + 0x1da) != 0) || (local_c != 0)) || ((bVar12 & 0xf) == 6)) {
36	local_50 = local_50 + (short)local_28;
36	uVar15 = FUN_2116ab53();
36	sVar3 = (short)uVar15;
36	iVar6 = FUN_21183e00(local_40);
36	puVar26 = (undefined2 *)(*(int *)(*(int *)(psVar19 + 0x3f) + 2) + (int)local_24 * 0x2e);
36	if (*(short *)(*(int *)(puVar26 + 0x13) + (int)local_c * 4) == 0x33) {
36	iVar12 = (int)sVar4;
36	sVar4 = FUN_2117e7b3(CONCAT22((short)((uint)(iVar12 * 0x2a3) >> 0x10),*puVar26),
36	bVar27 = uVar8 == 0;
36	if (!bVar27) {
36	puVar25 = (ushort *)0x0;
36	} while (puVar25 < local_48);
36	cVar3 = FUN_21152619(local_18);
36	puVar26 = *(undefined2 **)(local_10 + 0x3f);
36	0 RSRC
36	DIO table for main board test.vi
36	DDOUse
36	HPTH0
36	++++++++++++++
36	port numberPTH0
36	CALOFFO
36	EEPROM.VIU
36	Beep.viX
36	SETLD_RD.VIMD
36	new file
36	append to file? (new file:F)
36	iteration (0:initialize)@
36	Cap. Standard Vals.
36	Cal/Test(s) to Perform
36	PQRW
36	!!Pj
36	NPj
36	M0Qf
36	7 7$7(7,7074787<7@7D7H7L7P7T7X7\7`7d7h7l7p7t7x7|7
36	8 8$8(8,8084888<8@8D8H8L8P8T8X8\8`8d8h8l8p8t8x8|8
36	KH)h
36	last range
36	test.viS
36	DAC_RITE.viW
36	WAIT.VIPTH0
36	Beep.viPTH0
35	uint local_64;
35	undefined2 local_44;
35	undefined2 local_36;
35	local_a = 0;
35	Inductance Decade Box (L Terminal)BNow connect the red lead to the
35	#####
35	0
35	(LIbd
35	<BDHP
35	Write
35	4I0
35	Dio width
35	Test Namep0
35	QRhhPf
34	undefined2 local_12;
34	char *pcVar5;
34	char *_Str;
34	undefined2 uVar14;
34	if ((short)local_18 == 0) {
34	uVar12 = extraout_var;
34	} while (param_5 != 0);
34	int *piVar12;
34	if (uVar14 != 0) {
34	if (sVar5 == 2) {
34	} while (local_18 != 0);
34	uVar9 = 1;
34	psVar2 = param_1;
34	uVar7 = extraout_var_00;
34	local_6 = '\0';
34	if ((short)param_7 == 1) {
34	if (local_6 != '\0') {
34	local_20 = 2;
34	local_14 = local_14 + -1;
34	uint local_70;
34	local_90 = 0;
34	if ((int)uVar5 < 0) {
34	local_44 = 2;
34	undefined1 local_18 [8];
34	if (local_3c != 0) {
34	undefined4 uStack_40;
34	undefined4 local_80;
34	local_1c = 0.0;
34	local_10 = 0.0;
34	undefined4 *local_14;
34	if (iVar5 == 1) {
34	undefined4 local_9c;
34	undefined4 local_84;
34	undefined4 *local_20;
34	case 0xf0:
34	case 0x43f8:
34	case 0x440c:
34	case 0x4416:
34	case 0xc4e0:
34	case 0xc4ea:
34	int local_68;
34	switch(local_18) {
34	case 0x4420:
34	case 0x442a:
34	iVar4 = (int)sVar1;
34	pdVar14 = pdVar14 + 1;
34	double *pdVar10;
34	local_14 = local_8;
34	local_c = 0x100;
34	if (local_10 < 0) {
34	case 99:
34	if (local_14 < 0) {
34	sVar2 = -0x2730;
34	if (param_8 != (uint *)0x0) {
34	iVar13 = param_4;
34	bVar19 = !bVar19;
34	status[15]- GPIB error detected
34	[W(string) source:  an indication of where an error occurred, usually the name of the VI."
34	error in (no error)o
34	Set Serial Number
34	piVar1 = *(int **)(param_1 + 0x138);
34	- occurrences: `4`
34	uVW
34	Message`0
34	400g
34	|LIbd
34	TICON
34	hicl4
34	|icl8
34	timeout`
34	33333
34	$PTH0
34	04H0
34	`PTH0
34	Test Sequence
34	N'b;
34	[user-defined codes]
34	,@2'new file path (Not A Path if cancelled)
34	EPQ
34	VQj
34	UQRP
34	RSPQj
34	!hP
34	? ?$?(?,?0?4?8?<?@?D?H?L?P?T?X?\?`?d?h?l?p?t?x?|?
34	0 0$0(0,0004080<0@0D0H0L0P0T0X0\0`0d0h0l0p0t0x0|0
34	; ;$;(;,;0;4;8;<;@;D;H;L;P;T;X;\;`;d;h;l;p;t;x;|;
34	2 2$2(2,2024282<2@2D2H2L2P2T2X2\2`2d2h2l2p2t2x2|2
34	DIO delay (ms)
34	PWRtest.VIPD
34	QRhh!h
34	Mode&
34	Errant Test&
34	udf P@
34	GlobStat.viRE
34	extV P
33	puVar3 = param_2;
33	bool bVar10;
33	Manager Argument Error
33	offset past number"@!
33	error - ignored,
33	}WS
33	8LVIN
33	exists
33	Bit 2
33	Bit 4
33	L&c(
33	async I/O?PTH0
33	488.2 timeoutPTH0
33	GenevaRSRC
33	timeout (488.2 global)&
33	420p
33	LFTAB
33	Send.viND
33	statusX
33	,vers
33	6Wh<
33	] l"
33	instr handle outns@
33	+VVVVVVVVVV
33	:X B
33	source ("")L
33	31MD
33	instr vtl globalsp
33	Receive.viN
33	%dND
33	sourceU
33	8PTH0
33	#, O
33	@` T
33	CPOW
33	WAIT.VIOD
33	Cal Points
33	KHih
33	duration (msec) - ignored.
33	IST_WT_A.VIPTH0
32	iVar1 = param_3;
32	(*(short *)(param_1 + 0xaf8) = *(short *)(param_1 + 0xaf8) + -1,
32	*(short *)(param_1 + 0xaf8) == 0)) {
32	FUN_2105f760(*(undefined2 *)(param_1 + 0x10),
32	return 0xd7ef;
32	lpBytesReturned = &local_8;
32	undefined4 local_12;
32	undefined4 param_17,undefined4 param_18)
32	puVar2 = param_3;
32	piVar2 = param_2;
32	param_10,param_11,param_12,param_13);
32	short *param_6)
32	if (iVar1 < 0) {
32	sVar1 = strlen(param_2);
32	sVar1 = strlen(param_3);
32	*(undefined4 *)(local_d4.Buffer + 0x10) = param_6;
32	local_d4.MaxCount = param_11;
32	local_d4.Buffer = (uchar *)((int)local_d4.Buffer + 6);
32	local_d4.Buffer = (uchar *)((undefined2 *)((uint)(local_d4.Buffer + 1) & 0xfffffffe) + 1);
32	local_d4.Buffer = (uchar *)((int)local_d4.Buffer + 4);
32	local_d4.BufferLength = 0x20;
32	local_d4.BufferLength = 0x10;
32	*param_8 = *(undefined2 *)local_d4.Buffer;
32	undefined4 param_4,undefined4 param_5,undefined2 *param_6)
32	uVar1 = FUN_2100dee0(*(undefined4 *)(in_ECX + 4));
32	size_t sVar5;
32	if (param_4 != -1) {
32	local_20 = param_2;
32	uVar3 = ((param_1 >> 0x18 & 0xf) << 8 | param_1 >> 0x10 & 0xf) << 0x10 |
32	return local_28[0];
32	puVar3 = local_28;
32	*(undefined4 *)(in_ECX + 0x2c) = 0;
32	else if (param_2 == 2) {
32	FUN_2103cbb0();
32	undefined4 uVar20;
32	int iVar18;
32	if ((*(short *)(iVar2 + 0x10) == 0x21) &&
32	sVar7 = 1;
32	if ((param_2 != 0) && (param_2 != 1)) {
32	double local_34;
32	return (int)(short)local_10;
32	return 0xd5cb;
32	puVar3 = param_3;
32	return 0xd5a3;
32	uint extraout_ECX;
32	undefined4 unaff_EDI;
32	if (sVar4 == 4) {
32	undefined4 local_4e;
32	p_Var9 = (LPOVERLAPPED)0x0;
32	case 0x2c:
32	case 0x3b:
32	if (sVar1 == 4) {
32	FUN_21136340(uVar4);
32	uVar7 = uVar6;
32	iVar5 = 4;
32	iVar5 = iVar5 + 2;
32	if (param_2 == 3) {
32	uVar5 = ftol();
32	param_6 = 0;
32	sVar3 = ftol();
32	if ((short)param_4 == 0) {
32	local_8 = 8;
32	ushort *puVar2;
32	FUN_21185130(uVar1,local_28 & 0xffff,*local_18);
32	*local_c = *local_c | (ushort)local_10;
32	return local_10 & 0xffff;
32	iVar3 = (int)param_1;
32	*local_c = *local_c & ~local_10[0];
32	*param_4 = 0xffff;
32	if (sVar6 == 1) {
32	param_5[2] = 0;
32	DVar15 = 0x50;
32	pvVar8 = (HANDLE)FUN_21002400();
32	if (sVar6 == 2) {
32	if (sVar3 == -1) {
32	uVar5 = uVar5 - 1;
32	param_10 = param_10 + 1;
32	if (param_1 != (undefined4 *)0x0) {
32	if (param_3 == 3) {
32	return (uint)uVar3;
32	sVar3 = FUN_210990b0(param_1);
32	*puVar3 = 1;
32	if (param_3 < 0) {
32	puVar1 = param_3;
32	if (sVar2 != 1) {
32	undefined4 in_EDX;
32	if (local_10 == 4) {
32	else if (param_3 == 0xc35a) {
32	undefined1 local_38 [8];
32	undefined4 uStack_80;
32	param_3 = param_1[1] * param_3;
32	uVar1 = *param_2;
32	char *pcVar10;
32	if (cVar3 == '\0') {
32	sVar2 = sVar1;
32	undefined2 extraout_var_14;
32	undefined2 extraout_var_15;
32	undefined2 extraout_var_16;
32	return param_2 & 0xffff0000;
32	if ((short)param_6 == 0) {
32	uVar7 = FUN_21136310(*(undefined4 *)(param_2 + 0x266));
32	FUN_211850f0(*(undefined4 *)(param_2 + 0xc),0xc,0);
32	iVar2 = (int)param_2;
32	if ((short)uVar6 == 0) {
32	local_24 = 2;
32	iVar8 = 2;
32	undefined1 local_28 [4];
32	uVar1 = DAT_21219160;
32	FUN_211362c0(uVar1);
32	bVar3 = 0x80;
32	FUN_211850f0(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x2a),
32	bVar4 = 0x80;
32	uVar3 = param_4;
32	uVar2 = local_8;
32	uVar1 = FUN_21136310(param_1);
32	undefined2 uVar13;
32	param_3[1] = 0;
32	if (bVar14) {
32	sVar3 = -0x2713;
32	if (0 < sVar9) {
32	undefined1 local_30 [4];
32	if (sVar3 == 2) {
32	undefined1 local_38 [4];
32	return -0x2a5b;
32	if (0 < sVar11) {
32	local_28 = local_28 + 1;
32	*param_3 = iVar1;
32	*param_4 = iVar1;
32	in_ECX = local_c;
32	local_1c = param_3;
32	short local_8 [2];
32	undefined4 local_a8;
32	if (param_3 == 0x66bc) {
32	bVar2 = 0;
32	case 0x52ee:
32	case 0x52f8:
32	if (cVar2 != '\0') {
32	cVar2 = '\0';
32	if (local_30 == 0) {
32	*param_2 = uVar1;
32	local_18 = 3;
32	*param_2 = iVar1;
32	tTimerTimebaseEfficient *in_ECX;
32	local_c = uVar3;
32	_memDelete(puVar3);
32	long lVar5;
32	local_10 = local_c;
32	iVar3 = *in_ECX;
32	FUN_21088660(param_1);
32	in_ECX[0xd] = 0;
32	_memDelete(piVar2);
32	if (sVar5 != 0) break;
32	if (*psVar1 == 0) {
32	iVar3 = FUN_21058a50();
32	double local_20;
32	uStack_10 = 0;
32	bool bVar9;
32	double *pdVar7;
32	return -0x2733;
32	if ((int)uVar7 < 0) {
32	FUN_21098c60(local_8,local_c);
32	local_8 = 0xffffd68f;
32	local_8 = -0x2a30;
32	*param_11 = param_7;
32	param_2 = (void *)0x0;
32	undefined2 *in_ECX;
32	FUN_210a0600(0x14);
32	tBufferFactory local_10 [8];
32	return 0xd8d8;
32	*psVar1 = -0x2a3a;
32	if (local_5c != 0) {
32	_memDelete(param_9);
32	(**(code **)(*in_ECX + 0x10))(0xffff0004,2,param_2);
32	param_2);
32	uVar3 = 3;
32	in_ECX[1] = param_2;
32	FUN_210ab620(&local_50,0,0);
32	double local_38;
32	(**(code **)(*piVar2 + 0x24))
32	} while (uVar4 < uVar2);
32	if (*param_1 != 0) {
32	piVar3 = *(int **)(in_ECX + 0x10);
32	*(undefined4 *)(iVar6 + 5) = param_1;
32	iVar7 = *(int *)(*(int *)(in_ECX + 0xc) + 4);
32	*(undefined4 *)(iVar7 + 0xd) = 0x90;
32	(**(code **)(**(int **)(in_ECX + 0xc) + 0x10))(0xffff0020,1,param_1);
32	if (pcVar15 != (char *)0x0) break;
32	if (*param_2 < 0) {
32	if (*param_3 < 0) {
32	if (*in_ECX == 0) {
32	short local_54;
32	case 0x41:
32	case 0x4b:
32	case 0x77:
32	if (((short)param_2 != 1) && ((short)param_2 != 2)) {
32	param_8 = 0;
32	local_8 = uVar4;
32	_memDelete(local_c);
32	pvVar3 == (void *)0x0)) goto LAB_210ce30d;
32	if (iVar2 != 0) goto LAB_210cea0b;
32	case 0x79:
32	(**(code **)(**(int **)((int)in_ECX + iVar10 * 4 + 0x32) + 0x24))
32	uint *in_ECX;
32	*(undefined4 *)(this + 0x14) = 0;
32	ptVar2 = NIBS100::tBufferFactory::makeBuffer
32	_param_2 = _param_2 + 1;
32	iVar4 = *piVar3;
32	return -0x278a;
32	case 0xc616:
32	return -0x2788;
32	case 0x33f4:
32	case 0x33fe:
32	case 0x3408:
32	case 0x3412:
32	case 0x341c:
32	case 0x3426:
32	case 0x3430:
32	*param_2 = 0x15;
32	*param_2 = 0x23;
32	double dVar12;
32	uVar2 = ftol(*(undefined4 *)(in_ECX + 0x14f),&local_8);
32	*(undefined4 *)(in_ECX + 0x14f),&local_8);
32	_memDelete(ptVar2);
32	param_5 = (double *)0x0;
32	return (double *)0xffffb1df;
32	pdVar9 = pdVar9 + 1;
32	uVar1 = FUN_21117dc0(param_2);
32	uVar13 = uVar13 + uVar3;
32	} while (uVar13 < uVar10);
32	case 0x119:
32	case 0x11a:
32	case 0x11b:
32	case 0x11c:
32	case 0x11d:
32	case 0x11e:
32	case 0x127:
32	case 0x128:
32	case 0x129:
32	case 0x12a:
32	case 299:
32	case 300:
32	if (-1 < iVar9) {
32	if (local_1c != 0) {
32	if (*(int *)((int)in_ECX + 0x173) != 0) {
32	(**(code **)(**(int **)((int)in_ECX + 0x1b3) + 0x20))
32	(**(code **)(*piVar1 + 0x24))();
32	return 0xbffa4001;
32	case 0x78:
32	uVar3 = (**(code **)(*in_ECX + 0x6a8))(iVar5);
32	uVar2 = 3;
32	_Dst = (double *)((int)_Dst + 2);
32	_Dst = (double *)((int)_Dst + 4);
32	_Src = _Src + 8;
32	lVar1 = FUN_211276d0(param_1,param_2);
32	local_8 = *puVar1;
32	pvVar7 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_8);
32	if (uVar3 == 1) {
32	_param_1 = (ulong *)0x0;
32	sVar3 = palStatusMapStatusValue(_param_1);
32	nOutBufferSize = 0x16;
32	nInBufferSize = 0x16;
32	dwIoControlCode = 0xabcd2010;
32	local_1a = param_1;
32	short local_80;
32	uVar12 = uVar7 & 0x80000007;
32	local_30 = local_30 + 1;
32	return 0x272b;
32	sVar16 = sVar16 + 1;
32	if (0 < sVar16) {
32	iVar9 = iVar9 + 1;
32	short local_68;
32	if (*param_4 == 1) {
32	for (local_2c = 0; local_2c < 4; local_2c = local_2c + 1) {
32	local_c = FUN_21171bda(param_1,&local_18);
32	int local_10 [2];
32	local_10 = -0x2730;
32	sVar2 = FUN_21171bda(param_1,&param_2);
32	*(undefined4 *)(param_1 + 0x79e) = 0;
32	*(byte *)(uVar1 + 0x95f + ((int)param_3 / 2) * 0x10) =
32	if (param_3 == '\0') {
32	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 0x10;
32	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 3;
32	return 0xd686;
32	*(uint *)(param_1 + 0x8ea + param_2 * 4) =
32	local_c = 0x118;
32	if (*(char *)(param_1 + 0x7ea7) == '\x03') {
32	uVar2 = (uint)!bVar1;
32	puVar3 = u64::operator+=(puVar3,uVar2);
32	puVar3 = u64::operator*=(puVar3,uVar5);
32	float *pfVar10;
32	if (in_stack_00000028 != (float *)0x0) {
32	*puVar8 = (short)(*puVar7 >> 0x10);
32	puVar7 = puVar7 + uVar11;
32	uVar8 = *(undefined2 *)(iVar5 + 0x14);
32	iVar14 = (int)sVar4;
32	sVar6 = strlen(pcVar7);
32	*param_12 = 0.0;
32	param_3 = (char *)0x2;
32	sVar3 = **(short **)(puVar2 + 6);
32	fVar1 = 0.0;
32	*param_4 = 0x5e24;
32	param_4 = param_4 + (int)param_3;
32	param_4 = param_4 + param_3;
32	goto LAB_21199c81;
32	iVar3 = iVar3 + iVar1;
32	iVar5 = FUN_211ae970(local_18,local_1c);
32	local_14 * 2),uVar9,piVar12)
32	bVar13 = iVar5 == 0;
32	PMLbl
32	@LVIN
32	daqlptrs
32	statusL
32	,CPTM
32	tCPTM
32	task ID`
32	Capacitance Calibration
32	stddevh
32	LEADOPEN.viW
32	frequency (Hz) - ignoredpPTH0
32	y?~~
32	Optional Expec. Val.PTH0
32	type of dialog (OK msg:1)@0
32	message<@P
32	[exception source]2@P
32	(_^[
32	VUUU
32	PSQRj
32	PQRj
32	@f;G
32	QRSh
32	6 6$6(6,6064686<6@6D6H6L6P6T6X6\6`6d6h6l6p6t6x6|6
32	: :$:(:,:0:4:8:<:@:D:H:L:P:T:X:\:`:d:h:l:p:t:x:|:
32	< <$<(<,<0<4<8<<<@<D<H<L<P<T<X<\<`<d<h<l<p<t<x<|<
32	> >$>(>,>0>4>8><>@>D>H>L>P>T>X>\>`>d>h>l>p>t>x>|>
32	5 5$5(5,5054585<5@5D5H5L5P5T5X5\5`5d5h5l5p5t5x5|5
32	3 3$3(3,3034383<3@3D3H3L3P3T3X3\3`3d3h3l3p3t3x3|3
32	P/F_Glob.viZ
32	frequency (Hz) - ignoredPTH0
32	UUT Comm.viRE
32	oldV P
32	d$hhU
32	reference
31	bool bVar14;
31	undefined2 in_DX;
31	undefined2 local_2c;
31	puVar3[2] = 0;
31	ulong uVar4;
31	undefined2 *puVar14;
31	uVar6 = uVar7;
31	error in (no error)0
31	(cluster) error in:  a cluster describing any error conditions prior to this VI's execution.  The default input of this cluster is no error.  The error in cluster contains the following parameters:
31	Inductance Decade Box (H Terminal)=Short the UUT leads to the
31	start of read offset (chars.:0 ),@
31	u,&g
31	$LVIN
31	HLVIN
31	dFTAB
31	sourceM
31	$DLDR
31	error outM
31	rf
31	Back Up
31	Port Select.@
31	?2333
31	AKH(
31	QRhh#h
31	QRhh$h
30	bVar7 = 0;
30	uVar2 = 4;
30	undefined1 *puVar5;
30	*puVar8 = 0;
30	else if ((sVar8 == 0xd) || (sVar8 == 0xe)) {
30	else if (sVar8 != 0x12) {
30	*(short *)(iVar2 + 0xaf8) = *(short *)(iVar2 + 0xaf8) + 1;
30	byte bVar11;
30	local_c = 0x1e;
30	int iVar20;
30	sVar6 = FUN_2104a3a0(param_1);
30	int iVar17;
30	if ((short)param_2 != 1) {
30	return -0x28d4;
30	local_58 = 1;
30	undefined4 param_6,undefined4 param_7,undefined4 param_8,undefined4 param_9,
30	*param_10 = 1;
30	case 0x47:
30	case 0x48:
30	param_11._0_2_ =
30	iVar16 = local_18;
30	uVar20 = 0;
30	param_11._0_2_ = -0x2a5e;
30	FUN_211850f0(*(undefined4 *)(iVar8 + 0xc),0x17,0x40);
30	uVar3 = FUN_21185030(*(undefined4 *)(iVar8 + 0xc),0x15);
30	uVar4 = FUN_21185030(*(undefined4 *)(iVar8 + 0xc),0x15);
30	bVar2 = FUN_21185030(*(undefined4 *)(iVar8 + 0xc),0);
30	*(byte *)(iVar8 + 0xadc) = bVar2;
30	if ((bVar2 & 0x20) == 0) {
30	*(undefined2 *)(iVar16 + 0x10e) = 1;
30	param_11._0_2_ = *(short *)(iVar16 + 0x10e);
30	iVar7 = FUN_21183e00(local_84);
30	if (iVar7 != 0) goto LAB_2106c731;
30	return 0xd695;
30	local_8 = '\x01';
30	local_7 = '\x01';
30	if (local_7 == '\0') {
30	local_3c = *(int **)(local_54 + 0xcf);
30	uVar10 = FUN_21185070(local_24[3],0);
30	*param_3 = 10;
30	int local_7c;
30	undefined8 local_28;
30	return (uint)uVar4;
30	if (local_8 == 1) {
30	if (pvVar4 != (void *)0x0) {
30	iVar5 = *piVar1;
30	*piVar9 = -0x2a58;
30	FUN_210b3cf0(iVar4,0,piVar9,2);
30	puVar7 = puVar7 + 4;
30	puVar7 = puVar7 + 2;
30	*param_3 = 0xb;
30	case 0xc490:
30	case 0xc49a:
30	case 0xc4ae:
30	case 0xc4b8:
30	*param_3 = 0x12;
30	case 0xc4fe:
30	case 0xc508:
30	case 0xc512:
30	case 0xc526:
30	case 0xc53a:
30	short param_6,short param_7)
30	if (param_3 != -1) {
30	local_40 = 1;
30	(**(code **)(iVar5 + 0x40))(uVar7);
30	goto switchD_210e32aa_caseD_c62a;
30	goto switchD_210e363d_caseD_c634;
30	return 0xd8d6;
30	goto switchD_210ea366_caseD_43dc;
30	return 0xbffa0054;
30	u64::u64((u64 *)&stack0xffffffdc,100);
30	iVar6 = FUN_210f4f00();
30	iVar6 = 0x200;
30	local_30 = 4.32887141432508e-312;
30	this = ptVar20;
30	size_t sVar6;
30	local_28 = 2;
30	if (iVar13 != 0) {
30	sVar2 = local_24;
30	sVar2 = local_20;
30	undefined2 *local_14;
30	for (local_40 = 0; local_40 < param_2; local_40 = local_40 + 1) {
30	*(undefined2 *)(local_1c + 0x695 + local_18 * 2) =
30	if (local_18 == 7) {
30	*(undefined4 *)(local_1c + 0x615 + local_18 * 4) = 0;
30	uVar3 = (uVar3 - 1 | 0xfffffffe) + 1;
30	local_14 = (undefined2 *)0x0;
30	if ((local_24 != 0) ||
30	if (local_24 != 0) goto LAB_2115e218;
30	if ((param_5 == 0) && (param_6 == 0x40100000)) {
30	local_20 = (uint)local_20._1_3_ << 8;
30	*(byte *)(param_1 + 0x6d6) = *(byte *)(param_1 + 0x6d6) & 0xdf;
30	*(byte *)(param_1 + 0x957 + local_8 * 0x10) | 0x10;
30	*(byte *)(param_1 + 0x958 + local_8 * 0x10) | 0x10;
30	*(byte *)(param_1 + 0x959 + local_8 * 0x10) | 0x10;
30	*(byte *)(param_1 + 0x95a + local_8 * 0x10) | 0x10;
30	local_c = 0x66;
30	local_c = 0xb4;
30	*param_7 = (double)fVar10;
30	local_c = 1000;
30	local_c = 0x54;
30	local_c = 0xa8;
30	local_c = 0xc0;
30	local_c = 0x180;
30	local_10 = sVar3;
30	for (local_2c = 0; sVar3 = local_10, local_2c < 8; local_2c = local_2c + 1) {
30	CONCAT31((int3)((uint)iVar7 >> 8),(undefined1)local_8),3);
30	local_8c = local_8c + 1;
30	sprintf(local_4e4,s_WalrusChWzHack_d_2120b9a8,
30	*(undefined4 *)(pcVar2 + 0x388));
30	while (sVar4 == 0) {
30	local_c = FUN_21150ea4(psVar18,uVar13,1);
30	goto LAB_211c201f;
30	bVar19 = *(short *)(*(int *)(puVar14 + 7) + iVar9 * 2) == 0;
30	local_18 = (uint)bVar19;
30	uVar15 = FUN_211586c1(psVar18,uVar13,local_8,
30	local_d = '\x01';
30	sVar4 = FUN_211c4920(local_10,uVar13,&local_24,&local_c,&local_30);
30	sVar4 = FUN_211c4920(local_10,uVar13,&local_24,&local_30,&local_40);
30	*param_11 = (ushort)param_7;
30	local_44 = CONCAT22(uVar21,puVar26[1]);
30	puVar22 = local_c;
30	puVar26 = (undefined2 *)(*(int *)(*(int *)(local_10 + 0x3f) + 2) + (int)local_1c * 0x2e)
30	param_6,param_12);
30	if ((param_4 == 0) && (iVar11 = 0, 0 < (short)local_34)) {
30	uVar13 = *puVar22;
30	if (*(short *)(*(int *)(puVar26 + 0x13) + (int)local_c * 4) != 0x33) goto LAB_211d0f61;
30	if (param_6 < 7) {
30	(**(code **)(iVar4 + 0x10))(&param_5);
30	iVar4 = *param_1;
30	URh
30	RhDU
30	@LIds
30	TDFDS
30	|vers
30	byte count (0)<@P
30	write buffer ("")<@P
30	source ("")2@P
30	error out$@0
30	NIDAQDW
30	LABVIEW
30	Software Rev. Check
30	Calibration Reset
30	Inductance Calibration
30	@ Error\FC Out4
30	input error"
30	dPTH0
30	4]0
30	CPOO
30	Test Name4
30	1ST_READ.viW
30	Path to Version File
30	PQj!
30	QRj!
30	Mf3
30	PQRV
30	EVW
30	QSRPj
30	h@x}
30	1 1$1(1,1014181<1@1D1H1L1P1T1X1\1`1d1h1l1p1t1x1|1
30	= =$=(=,=0=4=8=<=@=D=H=L=P=T=X=\=`=d=h=l=p=t=x=|=
30	4 4$4(4,4044484<4@4D4H4L4P4T4X4\4`4d4h4l4p4t4x4|4
30	VIDS DIO table for main board test.vi
30	DIO setting
30	instr handle in6@P
30	use system decimal point (T)$
30	QRhh"h
30	QRhh%h
30	QRhh(h
30	cancelled
30	ZXQRP
30	task ID out@@P
29	undefined2 local_a;
29	if (!bVar5) {
29	code is the error code.
29	(i32) code: the error code associated with an error.  A value of 0 means no error, a negative value is an error, and a positive value is a warning.
29	Inductance Decade Box (H Terminal)W
29	The status boolean is either TRUE (X) for an error, or FALSE (checkmark) for no error or a warning.
29	The source string describes the origin of the error or warning.
29	The code input identifies the error or warning.
29	select mode (2)
29	FPHPu
29	4DDOD
29	<LVIN
29	Error\FC Out'
29	new file path
29	XLIvi
29	PSTRG
29	DFTAB
29	4.0
29	4j0
29	DLLP
29	tPTH0
29	Modeo
29	MOac
29	#3333
29	F,Z@
29	8KL_
29	line mode (characters:F)
29	QRhh)h
29	QRRP
29	QRPP
28	return local_2c[0];
28	switch((short)param_2) {
28	case 0x2e:
28	return iVar6;
28	return 4;
28	if ((*(short *)(param_1 + 0x10) == 0x21) && (*(short *)(param_1 + 0xaf8) == 0)) {
28	if (-1 < (short)uVar6) {
28	local_8 = param_4;
28	param_18,param_19,param_20,param_21,param_22,param_23,param_24,param_25,
28	long *) */
28	return -0x272d;
28	short,unsigned short) */
28	long,unsigned long,unsigned long) */
28	iVar2 = (int)param_1;
28	local_d4.Buffer = (uchar *)((int)local_d4.Buffer + 10);
28	NdrGetBuffer(&local_d4,0x10,param_1);
28	*(undefined4 *)(local_d4.Buffer + 0xc) = param_6;
28	local_d4.BufferLength = 10;
28	NdrGetBuffer(&local_d4,10,param_1);
28	undefined2 param_4,undefined2 param_5,undefined2 param_6,undefined2 param_7,
28	undefined4 *param_4,undefined2 *param_5)
28	local_d4.Buffer = (uchar *)((int)local_d4.Buffer + 0x10);
28	undefined4 param_4,undefined2 *param_5)
28	local_d4.Buffer = local_d4.Buffer + 0x18;
28	undefined1 *puVar2;
28	(uint)*(ushort *)(in_ECX + 0x2c);
28	uVar2 = FUN_2100dee0(in_ECX[1]);
28	undefined4 param_6,undefined4 param_7)
28	*param_10 = param_1;
28	puVar3 = &local_20;
28	FUN_21183e60(0x32,1);
28	if ((short)iVar3 < 0) {
28	return (int)(short)iVar3;
28	if (uVar11 != 0) {
28	undefined4 uVar14;
28	uVar12 = extraout_var_00;
28	if (sVar2 == 8) {
28	if ((sVar2 == 0xd) || (sVar2 == 0xe)) {
28	ushort uVar12;
28	ushort *puVar3;
28	piVar2 = param_1;
28	short *psVar11;
28	double dVar14;
28	iVar13 = iVar13 + 1;
28	if (sVar1 == 2) {
28	if ('\0' < cVar1) {
28	sVar5 = 6;
28	local_42 = 0;
28	case 0x2b:
28	if (uVar10 == 0) {
28	undefined2 *puVar8;
28	sVar3 = (short)uVar5;
28	bVar1 = *param_2;
28	bVar3 = bVar3 - 1;
28	undefined1 local_40 [4];
28	local_38 = 1;
28	*local_c = *local_c | local_10[0];
28	if ((sVar3 < 1) || (0x40 < sVar3)) {
28	return (uint)(ushort)(param_1 >> 0xf) << 0x10;
28	undefined2 local_58;
28	*param_3 = uVar3;
28	psVar10 = psVar10 + 1;
28	uVar8 = uVar8 - 1;
28	param_5[3] = 0;
28	param_5[5] = 0;
28	undefined4 param_10)
28	short sVar15;
28	param_3 = param_2;
28	if (uVar9 != 0) {
28	if (0 < param_5) {
28	uVar10 = 2;
28	iVar4 = (int)param_2;
28	sVar5 = *(short *)(iVar2 + 0x10);
28	sVar2 = FUN_21142800(param_1);
28	FUN_21185130(*(undefined4 *)(param_1 + 0xc),4,(int)(short)uVar16);
28	if (sVar5 < 0) {
28	iVar5 = param_3;
28	else if ((short)param_2 == 1) {
28	undefined1 local_20 [8];
28	u64::u64((u64 *)&local_38,puVar4);
28	uVar4 = param_3;
28	switch(iVar7) {
28	*param_1 = puVar2;
28	*param_1 = iVar1;
28	return CONCAT22(uVar2,0xd8ed);
28	param_2 = 1;
28	undefined1 local_2c [32];
28	iVar4 = (int)(short)param_1;
28	sVar1 = -0x2abc;
28	return iVar9;
28	float10 fVar6;
28	if (bVar4) {
28	if (param_9 != 0) {
28	if (param_7 != 0) {
28	sVar3 = *psVar1;
28	FUN_211850f0(*(undefined4 *)(param_2 + 0xc),0x19,0);
28	FUN_21185030(*(undefined4 *)(param_2 + 0xc),9);
28	psVar2 = psVar2 + 1;
28	*(undefined1 *)(param_1 + 0x158) = 1;
28	return -0x2a5d;
28	bVar4 = FUN_21185030(*(undefined4 *)(param_1 + 0xc),0);
28	uVar8 = ftol(2);
28	local_22 = param_1;
28	} while (uVar6 != 0);
28	if (!bVar4) {
28	_param_1 = _param_1 + -1;
28	} while (_param_1 != 0);
28	short local_2a;
28	undefined1 local_18 [6];
28	*param_3 = local_1c;
28	local_28 = param_3;
28	byte local_5;
28	else if (param_4 == 0) {
28	undefined4 extraout_ECX_00;
28	undefined2 *local_8;
28	switch(*(undefined2 *)(&DAT_2120f8de + (short)param_1 * 0x7a)) {
28	bVar5 = false;
28	local_7 = '\0';
28	1);
28	sVar2 = (short)param_3;
28	return uVar5 & 0xffff;
28	return sVar12;
28	iVar7 = (int)(short)param_1;
28	param_1 = 2;
28	iVar7 = (int)sVar3;
28	uint local_74;
28	if ((short)param_4 == 1) {
28	iVar1 = *param_3;
28	if (bVar8) {
28	uVar3 = extraout_var_00;
28	if (local_c == 1) {
28	piVar9 = piVar9 + 1;
28	*piVar4 = 0;
28	pcVar4 = pcVar4 + 1;
28	} while (local_14 != 0);
28	return 0xffffd75d;
28	iVar2 = (int)sVar3;
28	local_8 = uVar1;
28	if (iVar1 != 2) {
28	if (param_3 != 3) {
28	FUN_21082dd0();
28	case 0x532b:
28	case 0x532c:
28	if ((short)uVar1 < 0) {
28	return 0xffffd698;
28	if (local_28 == 0) {
28	iVar8 = *piVar6;
28	cVar3 = cVar3 + '\x01';
28	*param_4 = 0x14;
28	case '\x06':
28	param_1[1] = iVar1;
28	FUN_21082470();
28	*(undefined4 *)(in_ECX + 0x14) = 0;
28	*(undefined4 *)(in_ECX + 0x10) = 0;
28	*(undefined4 *)(in_ECX + 0x28) = 0;
28	tTimerTimeUnit tVar3;
28	if (*(int *)(in_ECX + 0x14) != 0) {
28	undefined4 uStack_4c;
28	undefined4 uStack_48;
28	iVar2 = *param_3;
28	return (uint)uVar4 << 0x10;
28	local_44 = 3;
28	void *pvVar6;
28	if ((lVar5 == 0) &&
28	lVar6 = tPIMMblockReferenceBase::allocateMemory
28	if ((lVar6 == 0) &&
28	local_10 = (undefined2 *)0x0;
28	sVar7 = (short)local_8;
28	if (0 < iVar5) {
28	in_ECX[0xb] = 0;
28	in_ECX[0xc] = 0;
28	in_ECX[0xf] = 0;
28	in_ECX[0x11] = 0;
28	bool bVar11;
28	if (pvVar2 == (void *)0x0) {
28	piVar3 = piVar2;
28	local_8 = 0xffffd5d0;
28	return 0xffffd8e6;
28	*param_3 = local_14;
28	FUN_21183e60(5,2);
28	float10 fVar9;
28	undefined4 uStack_28;
28	if (sVar3 < 1) {
28	FUN_21183e60(5,1);
28	goto LAB_21097f9a;
28	u64 *this;
28	ulong uVar6;
28	local_8 = -0x28a3;
28	uVar2 = *puVar8;
28	return iVar7;
28	uVar9 = 10;
28	switch((undefined2)param_2) {
28	if (local_8 < 1) {
28	iVar1 = *piVar3;
28	uVar4 = 0x80;
28	uStack_14 = 0;
28	short *in_ECX;
28	uVar10 = 5;
28	uVar5 = FUN_210a0260(*(undefined4 *)(in_ECX + 0x11));
28	iVar6 = FUN_210a02f0(uVar5,uVar9,uVar10);
28	tIterator *ptVar4;
28	int local_64;
28	return param_10 & 0xffff;
28	piVar8 = param_4;
28	*piVar1 = -0x28cc;
28	if (pvVar3 != (void *)0x0) {
28	in_ECX[0x14] = 0;
28	*(undefined4 *)param_3 = 0;
28	piVar6 = *(int **)(in_ECX + 0x10);
28	*param_3 = -0x2713;
28	param_3[1] = (int)s_j__drvsrc_ALL_nidaq_e_series_wal_212090e8;
28	if (-1 < *piVar1) {
28	param_3 = 0x20;
28	iVar4 = **(int **)(in_ECX + 0x138);
28	undefined4 local_98;
28	if (-1 < iVar3) {
28	case 0x100:
28	case 0x101:
28	case 0x52:
28	case 0x42:
28	case 0xef:
28	if ((lVar4 == 0) &&
28	pvVar3 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_8);
28	iVar1 = -0x2a3a;
28	FUN_210befb0();
28	undefined4 local_24 [4];
28	local_24[1] = *(undefined4 *)(in_ECX + 0x18);
28	local_24[0] = *(undefined4 *)(*(int *)(in_ECX + 0x20) + 0x2e);
28	local_24[3] = param_1;
28	local_30[0] = *(undefined4 *)(*(int *)(in_ECX + 0x20) + 0x2e);
28	local_30[1] = *(undefined4 *)(in_ECX + 0x18);
28	puVar3 = local_30;
28	undefined4 local_28 [4];
28	local_28[0] = *(undefined4 *)(*(int *)(in_ECX + 0x20) + 0x2e);
28	local_28[3] = param_1;
28	local_28[1] = *(undefined4 *)(in_ECX + 0x18);
28	case 0x66:
28	case 0xc4cc:
28	case 0xc4d6:
28	return uVar1 & 0xffff;
28	uVar2 = 2;
28	iVar7 = FUN_21058a50();
28	u64 *puVar3;
28	iVar7 = 1;
28	if (param_3 != 0x69aa) {
28	if (((short)param_2 < 0) || (7 < (short)param_2)) {
28	(**(code **)(*local_8 + 0x5c))();
28	if (0 < iVar3) {
28	if (0 < (int)uVar1) {
28	if ((int)uVar3 < 1) {
28	FUN_21183f50();
28	if ((int)uVar2 < 1) {
28	uint local_6c;
28	if (1 < param_1) {
28	uVar4 = uVar4 >> 1;
28	return -0x272a;
28	(**(code **)(**(int **)(in_ECX + 0x32 + iVar3 * 4) + 0x20))
28	(**(code **)(**(int **)(in_ECX + 0x32 + iVar3 * 4) + 0x24))
28	if (*(int *)(in_ECX + 0x38) != 0) {
28	if (((short)param_1 < 1) || (2 < (short)param_1)) {
28	_param_2 = 0;
28	iVar1 = **(int **)pdVar4;
28	float *pfVar5;
28	return 0xffffd8d6;
28	iVar5 = **(int **)(in_ECX + 0x1f6);
28	local_c = uVar4;
28	iVar1 = *(int *)(in_ECX + 0x1c + param_2 * 0x58);
28	iVar4 = in_ECX + param_2 * 0x58;
28	uVar4 = uVar5 & 0xffff;
28	case 0x3435:
28	case 0x343f:
28	case 0x3444:
28	case 0x343a:
28	case 0x3458:
28	iVar6 = param_2 * 0x50 + in_ECX;
28	goto LAB_210e606d;
28	goto LAB_210e6770;
28	if ((lVar5 != 0) ||
28	(**(code **)(**(int **)(in_ECX + 8) + 0x24))
28	sVar1 = (**(code **)(*in_ECX + 0x6ac))(param_2);
28	return 0xd8e7;
28	double dVar11;
28	return (float10)1.0;
28	local_c = (undefined4 *)0x0;
28	float local_c;
28	case 0x3e:
28	puVar17 = param_8;
28	pdVar9 = pdVar9 + (int)param_3;
28	(**(code **)(**(int **)((int)in_ECX + 0x163) + 0x20))
28	pvVar4 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&param_2);
28	if ((*(short *)(in_ECX + 0x2c) != 0x140) && (*(short *)(in_ECX + 0x2c) != 0x141)) {
28	*(undefined4 *)(this + 8) = 0;
28	} while (uVar2 < uVar1);
28	param_1 = uVar2;
28	return 0xd8dd;
28	} while (uVar6 < 0x4000);
28	if (pcVar4 == (char *)0x0) {
28	float10 extraout_ST1;
28	(**(code **)(iVar4 + 0x24))();
28	local_8 = FUN_21115650();
28	return -0x4005fff4;
28	(in_ECX,param_1,param_2,param_3,param_4,param_5,param_6);
28	iVar2 = (int)param_3;
28	local_8 = sVar4;
28	iVar3 = puVar1[4];
28	FUN_211850f0(uVar3,iVar11,5);
28	if (-1 < sVar7) {
28	if (psVar4 == (short *)0x0) {
28	(daqDevice *this,short param_1,short param_2,short param_3,short param_4)
28	(daqDevice *this,short param_1,char *param_2,long param_3,long param_4,long param_5,
28	return (int)local_10;
28	if (uVar12 == 0) {
28	return (undefined2 *)0x0;
28	memDelete(local_8);
28	for (local_1c = 0; local_1c < 4; local_1c = local_1c + 1) {
28	if ((*param_4 != 0) && (*param_4 != 1)) {
28	local_5c = sVar3;
28	uVar1 = FUN_21153556(param_1);
28	if ((param_2 < 1) || (*(short *)(local_10 + 0x10) < param_2)) {
28	local_10 = -0x292c;
28	*(undefined4 *)((int)local_1c + param_3 * 8 + 0x215) = param_4._0_4_;
28	*(int *)((int)local_1c + param_3 * 8 + 0x219) = param_4._4_4_;
28	if (local_8 < 0xffff) {
28	sVar6 = ftol();
28	uVar1 = 0xd6d4;
28	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0xdf;
28	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0xbf;
28	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0x7f;
28	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0xef;
28	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 0x40;
28	if (*(int *)(param_2 + 5) == 8) {
28	if ((local_8 & 0xff) == 9) {
28	local_24 = (float)(double)CONCAT44(param_7,param_6);
28	local_20 = (float)(double)CONCAT44(param_9,param_8);
28	CONCAT22((short)((uint)iVar2 >> 0x10),local_1c),local_404,0,
28	return 0xd88e;
28	if (*(int *)(param_1 + 0x10) == 0) {
28	puVar8 = local_10;
28	FUN_21185a40(local_8);
28	case 0x7a:
28	param_11 = 0;
28	} while (sVar3 < sVar4);
28	return -0x273a;
28	switch(*(undefined2 *)((int)pfVar14 + -0x16)) {
28	iVar8 = *local_c;
28	bVar12 = iVar6 == 0;
28	if (0x27 < param_6) {
28	goto LAB_211cf4f3;
28	refnum is the reference number of the open file.
28	uVS
28	COM1
28	COM2
28	COM3
28	COM4
28	LPT1
28	LPT2
28	LPT3
28	statusM
28	4/0
28	Oldest compatible LabVIEW.W
28	ESR Calibration
28	Ringer Calibration
28	code is the number identifying an error or warning. If status is TRUE, code is a non-zero error code. If status is FALSE, code can be zero or a warning code. Use the error handler VIs to look up the meaning of this code and to display the corresponding error message.
28	TPTH0
28	hPTH0
28	Error\FC Out(F)@0
28	Load SelectPTH0
28	Selection Start
28	Selection End
28	1_^[
28	:_^[
28	RPQS
28	Ph@
28	USV
28	U0Rf
28	h6"!
28	Next range
28	QRhh&h
28	QRhh+h
28	QRhh,h
28	QRhh'h
28	existing file
28	new or existing fileexisting dir
28	new dir
28	new or existing dir
28	existing file (use LLBs)
28	new file (use LLBs)
28	new or existing file (use LLBs)
28	QRhh h
28	QRhh.h
28	dup refnum
27	uint in_AX;
27	undefined4 uVar15;
27	uVar3 = FUN_1000_081e();
27	undefined2 local_2a;
27	byte *pbVar2;
27	10V Ref Calibration
27	Set Calibration Date
27	LLabl
27	O$,
27	dup refnum is a flow-though parameter with the same value as refnum.
27	errorPTH0
27	x?bffffff
27	codeHD"
27	\FTAB
27	Strings [4]$@@
27	COM6
27	COM7
27	COM8
27	COM9
27	LPT4
27	COM5
27	4>0
27	,PTH0
27	\PTH0
27	Devicei4
27	Cal Markt
27	Status_Glob.viZ
27	...Failed
27	...Passed
27	Pass or Fail GlobalPTH0
27	Array IndexPTH0&
27	measurement6@P
27	QRhh-h
27	path
27	d$P
27	t hhU
27	mfguser
26	undefined2 local_3a;
26	uVar2 = (*pcVar1)();
26	param_1[1] = 0;
26	byte bVar8;
26	if ((short)param_1 == 0) {
26	short local_20 [2];
26	ushort uVar16;
26	local_10 = 0x1e;
26	uint uVar17;
26	puVar2 = param_5;
26	if (-1 < sVar6) {
26	uVar9 = extraout_var;
26	if ((short)local_20 == 0) {
26	psVar13 = psVar13 + 1;
26	else if (sVar5 == 2) {
26	uVar7 = 4;
26	ulong uVar8;
26	uint uVar16;
26	FUN_21185130(*(undefined4 *)(param_2 + 0xc),0,(int)*(short *)(param_2 + 0x41b));
26	char *pcVar3;
26	} while (local_1c != 0);
26	if ((sVar2 == 0) &&
26	char *pcVar9;
26	bool bVar16;
26	return local_5c;
26	if ((short)uVar7 < 0) {
26	iVar9 = (int)sVar8;
26	*param_3 = 0x10;
26	undefined4 local_c0;
26	param_6 = (int *)0x0;
26	local_5c = 1;
26	sVar4 = (short)param_3;
26	local_14 = uVar5;
26	if (sVar3 != 0) break;
26	local_28 = 0.0;
26	param_3);
26	ssprintf(s__s__s__s__2120a584,s_j__drvsrc_ALL_nidaq_e_series_wal_2120a590,
26	pvVar2 = (void *)0x0;
26	*param_3 = 8;
26	*param_3 = 9;
26	*param_3 = 0x14;
26	*param_3 = 0x16;
26	int local_6c;
26	undefined1 local_3c [8];
26	uVar13 = 2;
26	tMemBlockReferenceBase::allocate
26	if (*param_5 == 0) {
26	case 0x4434:
26	case 0xc620:
26	case 0xc4c2:
26	case 0xc576:
26	case 0xc558:
26	return -0x28dd;
26	local_1c = (double *)0x0;
26	short local_7c;
26	if ((ushort)local_18 == 0) {
26	uVar2 = 0xd6d4;
26	float local_20;
26	if (*(int *)(param_2 + 0x94e) == 0) {
26	local_c = 0xe0;
26	local_c = 0x78;
26	local_c = 0xd8;
26	local_c = 0x98;
26	FUN_21185a40();
26	iVar16 = 0;
26	Current Source Calibration
26	Some error codes returned by the serial port VIs are platform-specific. Please refer to your system documentation for a list of error codes.
26	ffffff
26	Ring
26	Label
26	$Instr Parse Instrument Descriptor.vi
26	4D0
26	4M0
26	port numberM
26	111333333
26	x?bf>
26	4LIbd
26	HBDHP
26	\VICD
26	pCPTM
26	xLIfp
26	0ICON
26	error out<
26	A unique reference to an instrument I/O session.  It identifies which device to communicate with and all configuration information to perform the I/O.  An instr handle is returned from the Instr Open VI or the Initialize VI of an instrument driver.1-(bool) status: TRUE if an error has occurred."
26	error out<P@
26	PPTH0
26	Calibration Unstamp
26	Leakage Current Test
26	Calibration Stamp
26	8>?~
26	source messages
26	mark after read is the location of the file mark after the read; it points to the character in the file following the last character read.
26	Ind. Standard Vals.
26	$SVW
26	RPj!
26	jPQh
26	PQVW
26	QRVW
26	p'!!
26	Uf3
26	E f=
26	UPQRV
26	l6"!
26	d5"!f
26	LVINLBVWy
26	Voltage Reading@
26	QRhh1h
26	QRhh2h
26	fff3f3
26	3f333
26	Platform
26	system.llb
25	int in_BX;
25	undefined2 local_6;
25	SetCINArraySize, elmtNum %ld out of range 0 <= elmtNum < %ldnon-array detected
25	source is a string that indicates the origin of the error, if any. Usually source is the name of the VI in which the error occurred.
25	Inductor Range ary
25	MQj
25	Pj j
25	LVCT
25	MQR
25	Oldest compatible LabVIEW.X
25	mark after write (bytes)0
25	;F8B8
25	y?~>
25	4+0
25	swwww
25	error outH
25	\DSTM
25	BEEP30
25	GlobStat.viS
25	9When you use the serial port VIs under Windows, the port number parameter can have the following values:
25	When you use the serial port VIs on a Sun SPARCstation, the port number parameter is 0 for /dev/ttya, 1 for /dev/ttyb, and so on.
25	On the Macintosh, port 0 is the modem, using the drivers .ain and .aout. Port 1 is the printer, using the drivers.bin and .bout. To get more ports on a Macintosh, you must install other boards, with the accompanying drivers.
25	output errorPTH0
25	(PTH0
25	NFCQ
25	UUT Comm.viV
25	xVICD
25	lPTH0
25	Error\FC OutH
25	offset
25	QRhh*h
25	QRhh6h
25	QRhh:h
25	oldhP
25	Input Terminator
25	DTHPDH
24	FUN_1000_b296();
24	FUN_1000_b2ee();
24	uVar1 = 0x1030;
24	uVar1 = uVar2;
24	sVar2 = strlen(local_6c);
24	undefined1 local_30 [32];
24	ushort *puVar5;
24	puVar5 = local_8;
24	FUN_21185030(*(undefined4 *)(param_1 + 0xc),10);
24	if ((short)uVar6 < 0) {
24	sVar1 = param_2;
24	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),1,0);
24	local_14 = param_3;
24	undefined2 in_stack_0000002e;
24	char *param_6)
24	short *param_6,short *param_7)
24	double *param_6)
24	*param_2 = sVar1;
24	local_10 = 0x80;
24	FreeLibrary(hModule);
24	return -0x2864;
24	undefined4 in_stack_00000018;
24	*param_3 = *(undefined4 *)local_d4.Buffer;
24	local_d4.BufferLength = 0x18;
24	local_d4.MaxCount = param_10;
24	*(ULONG_PTR *)((uint)(local_d4.Buffer + 3) & 0xfffffffc) = param_5;
24	NdrConvert(&local_d4,"N\x0fN\x06Q\x01\x06");
24	local_d4.Buffer = local_d4.Buffer + 0xe;
24	*(undefined4 *)(local_d4.Buffer + 0x10) = param_7;
24	local_d4.Buffer = local_d4.Buffer + 0x12;
24	*param_4 = *(undefined4 *)local_d4.Buffer;
24	local_d4.MaxCount = param_9;
24	local_d4.MaxCount = (uint)param_4;
24	FUN_21185a40(local_10);
24	double *pdVar8;
24	char *local_28;
24	*param_19 = 0;
24	*param_20 = 0;
24	uVar1 = FUN_2100dee0(in_ECX[1]);
24	if ((short)param_3 != 0) {
24	local_30 = local_38;
24	undefined4 local_28 [3];
24	uVar3 = 5;
24	param_10,param_11,param_12,param_13,param_14,param_15);
24	undefined4 uStack_1c;
24	return 0xffffffff;
24	sVar2 = *psVar1;
24	return 10;
24	if (param_2 == 0x52da) {
24	iVar3 = param_4;
24	if (uVar11 == 0) {
24	return 0xd633;
24	undefined1 local_28 [32];
24	if ((short)local_8 < 0) {
24	if (sVar2 == 4) {
24	return 0xffffd5d0;
24	FUN_21185070(*puVar1,2);
24	FUN_21185030(*puVar1,2);
24	FUN_21185030(*puVar1,3);
24	return 0xd8c3;
24	return 0xd8c4;
24	uVar8 = extraout_var_01;
24	if ((short)local_10 == 1) {
24	iVar2 = *param_1;
24	if (-1 < sVar5) {
24	iVar9 = local_c;
24	lpInBuffer = &local_54;
24	local_40 = (uint)param_2;
24	DWORD DVar3;
24	byte bVar10;
24	if (sVar1 != 0x12) {
24	puVar1[3] = 0;
24	uVar7 = 0xd68f;
24	if ((short)param_4 != 0) {
24	iVar1 = (int)param_2;
24	if (param_2 != 3) {
24	ushort *puVar6;
24	undefined8 local_14;
24	*local_1c = *local_1c & ~(ushort)local_20;
24	if ((short)local_c == 0x1a) {
24	sVar6 = (short)param_4;
24	*param_11 = 2;
24	if (*psVar2 == 0) {
24	local_8 = 4;
24	undefined2 *puVar12;
24	iVar8 = (int)(short)param_1;
24	*param_4 = iVar4;
24	if (-1 < (short)local_10) {
24	sVar13 = 0;
24	else if (uVar7 == 2) {
24	iVar4 = local_14;
24	param_5[4] = 0;
24	iVar1 = *(int *)(&DAT_2120f937 + iVar1);
24	if (sVar10 == 0) {
24	param_4[2] = 0;
24	param_4[3] = 0;
24	param_4[5] = 0;
24	DVar17 = 0x50;
24	DVar13 = 0xabcd201c;
24	puVar3[3] = 0;
24	goto LAB_2104c36d;
24	if ((short)local_c == 1) {
24	uVar9 = uVar9 | 0x20;
24	iVar1 = *(int *)(param_1 + 0x59);
24	case 0xffff:
24	else if (cVar1 == '\x02') {
24	sVar9 = (short)param_2;
24	return CONCAT22(uVar4,0xd8e9);
24	local_48 = 1;
24	uVar6 = param_4;
24	(ulonglong)(uint)(int)(short)local_14)] == (short)local_18) &&
24	uVar5 = local_8;
24	if (sVar1 == 0x12) {
24	uVar6 = local_8;
24	uVar3 = FUN_21136310(iVar4);
24	return CONCAT22(uVar4,0xd8ed);
24	if (sVar7 < 0) {
24	uVar6 = 6;
24	sVar8 = (short)param_1;
24	local_30 = param_3;
24	if (sVar9 < 0) {
24	return 0xd68c;
24	uVar16 = uVar16 | 0x8000;
24	uVar5 = uVar5 | 2;
24	uVar7 = extraout_var;
24	iVar9 = (int)(short)param_1;
24	return -0x28d5;
24	local_4c = 1;
24	uVar7 = param_3;
24	*param_3 = 0x6658;
24	if ((double)CONCAT44(param_7,param_6) < 0.0) {
24	iVar5 = *piVar4;
24	if (param_3 == 0xc35a) {
24	tBufferFactory local_c [8];
24	puVar4 = u64::operator%=(puVar4);
24	puVar4 = u64::operator/=(puVar4);
24	ulong local_10;
24	local_18 = local_8;
24	uVar4 = ftol(2);
24	*param_2 = *puVar1;
24	puVar1 = puVar1 + 1;
24	(**(code **)*puVar1)(1);
24	return (uint)puVar2 & 0xffff0000;
24	if ((param_3 != 0x98bc) && (param_3 != 0x6658)) {
24	if (-1 < (short)uVar4) {
24	uVar12 = 2;
24	if (param_1 != 2) {
24	undefined1 local_44 [32];
24	uVar17 = uVar17 - 1;
24	else if (0 < (short)param_2) {
24	if (sVar5 != 0) goto LAB_2105e44d;
24	goto LAB_2105e44d;
24	*param_2 = 3;
24	*param_2 = 4;
24	FUN_21185030(*(undefined4 *)(param_2 + 0xc),0x19);
24	sVar5 = (short)local_8;
24	iVar10 = iVar10 + 1;
24	case -3:
24	if (*(short *)(param_1 + 0x14a) == 0) {
24	uVar7 = ftol(2);
24	*puVar2 = *puVar2 + 1;
24	FUN_2104a3a0(param_1);
24	uVar6 = extraout_var;
24	puVar2[1] = param_2;
24	sVar2 = FUN_2106aa40(param_1,2,DAT_21219160,0x57e,puVar1);
24	psVar1 = param_1;
24	local_34[0] = param_1;
24	local_2a = param_2 + -1;
24	uVar1 = *(ushort *)(param_1 + 0x2c);
24	local_5 = 0;
24	bVar3 = FUN_21185030(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x32));
24	bVar17 = false;
24	pcVar10 = (char *)FUN_2104a6a0(param_1 + -1);
24	pcVar9 = pcVar10;
24	param_11._0_2_ = -0x2a65;
24	if (*(short *)(iVar16 + 0x10e) != 0) {
24	sVar6 = (short)uVar2;
24	if (0 < (int)uVar14) {
24	switch((short)local_14) {
24	} while ((int)uVar7 < (int)sVar5);
24	uVar14 = (uint)((ulonglong)uVar17 >> 0x20);
24	iVar6 = local_c;
24	uVar8 = param_2;
24	iVar6 = local_10;
24	sVar3 = 2;
24	switch(sVar3) {
24	iVar4 = (int)sVar3;
24	uVar9 = 2;
24	piVar11 = piVar11 + 1;
24	if ((short)local_8 != 0) break;
24	iVar7 = (int)sVar5;
24	uint *puVar12;
24	if (2 < sVar3) {
24	piVar12 = local_a0;
24	piVar12 = (int *)*local_3c;
24	bVar1 = *(byte *)((int)piVar12 + 10);
24	cVar2 = *(char *)local_40;
24	iVar9 = FUN_21183e00(local_c4);
24	if ((undefined1 *)(int)sVar11 == local_18) {
24	puVar15 = puVar15 + sVar11;
24	if (*local_28 == '\x05') {
24	uVar10 = FUN_2104ca00(param_1,local_24,local_10);
24	if (cVar1 == '\x02') {
24	iVar3 = *piVar4;
24	psVar6 = psVar6 + 1;
24	int *local_1c;
24	iVar3 = iVar3 + 4;
24	if (sVar1 != 3) {
24	*param_2 = param_1;
24	sVar2 = FUN_210795d0(param_1,local_44);
24	if (sVar3 == 3) {
24	if (-1 < param_1) {
24	if (((short)param_1 < 1) || (0x40 < (short)param_1)) {
24	*param_2 = sVar3;
24	if ((-1 < param_3) && (param_3 < 8)) {
24	if (((short)param_3 < 0) || (7 < (short)param_3)) {
24	undefined4 local_ac;
24	uint local_88;
24	if (iVar1 != 1) {
24	goto LAB_2107c008;
24	if (param_2 < 0x7b71) {
24	FUN_2107ccb0(param_1);
24	uVar2 = FUN_2107d1d0(param_1);
24	*(undefined4 *)(param_1 + 0x1c1) = 0;
24	*(undefined4 *)param_5 = 0;
24	sVar3 = _STCMgrControlUser_12(uVar5);
24	return -0x271b;
24	*param_3 = 0x5e24;
24	iVar1 = *param_4;
24	iVar6 = param_5;
24	*(undefined4 *)(in_ECX + 8) = 0;
24	*(undefined4 *)(in_ECX + 0x1c) = param_2;
24	param_3 = &local_8;
24	if ((param_3 == (long *)0x0) || (-1 < *param_3)) {
24	lVar6 = FUN_21082330();
24	local_1c = local_1c - 1;
24	local_1c = local_14;
24	*(undefined4 *)(in_ECX + 0x3a) = 0;
24	param_3 = (short *)0x0;
24	if (0 < _numSCXIchassis) {
24	FUN_211850f0(*(undefined4 *)(*(int *)(in_ECX + 0x2c) + 9),0xd,0);
24	if (local_14 == 1) {
24	if (-1 < iVar5) {
24	uVar3 = (**(code **)(*piVar2 + 0x7c))();
24	uVar1 = 0xffffd8ed;
24	return 0xffffd5cb;
24	u64 *puVar6;
24	param_4 = &local_8;
24	puVar3 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_8);
24	puVar2 = param_1;
24	return 0xffffd68f;
24	if (param_8._3_1_ == '\0') {
24	tTimerTimebaseEfficient::getResolutionTimeUnit(local_50,(long *)&param_1);
24	puVar4 = (u64 *)FUN_21058950();
24	iVar8 = local_10;
24	return 0xd89a;
24	puVar5 = puVar5 + 2;
24	FUN_210978c0(psVar2,1,0x80);
24	*(undefined4 *)(iVar2 + 0x4b1) = 0x698c;
24	if (*(int *)(iVar2 + 0x2b9) != 0) {
24	sVar5 = FUN_210908d0(psVar2,0x7d6,0,0,(undefined4)local_34,local_34._4_4_,uVar7,local_8);
24	sVar5 = FUN_210908d0(psVar2,0x7d2,0,0,0,0,uVar7,local_a);
24	sVar5 = FUN_210908d0(psVar2,0x7d5,0,0,0,0,uVar7,local_c);
24	FUN_21097770(psVar2,0,0);
24	iVar7 = iVar7 + 1;
24	goto switchD_21090b21_default;
24	local_1c = (double)CONCAT44(uStack_10,local_14);
24	if (param_1 == local_8) {
24	param_7 = (undefined2 *)0x0;
24	busDeleteBusObject(&param_1);
24	return 3;
24	piVar3 = param_2;
24	if (param_1 != (int *)0x0) {
24	*piVar1 = 0;
24	*puVar2 = uVar4;
24	FUN_21098c40(&local_c,&local_10);
24	iVar2 = param_4;
24	local_8 = (int)sVar5;
24	if (0 < (int)local_8) {
24	psVar5 = param_3;
24	(param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
24	iVar3 = ftol();
24	*(undefined4 *)((int)param_12 + 4) = 0xbff00000;
24	if (param_2 != 6) {
24	*param_6 = -0x28dd;
24	*param_6 = -0x2713;
24	lVar1 = tPIMMblockReferenceBase::allocateMemory((tPIMMblockReferenceBase *)&local_8,4,1,8);
24	*piVar1 = (int)sVar2;
24	return 0xffffd828;
24	local_c = -0x28cc;
24	local_c = (double)fVar4;
24	FUN_2109ee40(0x32);
24	pvVar8 != (void *)0x0)) {
24	local_10 = uVar5;
24	if (pvVar5 == (void *)0x0) {
24	uVar2 = uVar2 - 1;
24	} while (uVar2 != 0);
24	undefined1 local_7c [4];
24	short local_58;
24	if (puVar2 != (undefined4 *)0x0) {
24	puVar2[1] = 0;
24	iVar2 = *in_ECX;
24	if (local_48 == 0) {
24	if ((int)local_18[0] < 0) {
24	local_8);
24	if (iVar2 != 2) {
24	if (param_3 == (int *)0x0) {
24	in_ECX[5] = param_1;
24	case '\x04':
24	case '\x05':
24	(**(code **)(*in_ECX + 0x10))
24	param_1 = &local_8;
24	if (local_18[0] < 0) {
24	local_c[0] = 0;
24	(*(undefined4 *)(in_ECX + 0x10),local_c + 1,&param_1,piVar4);
24	*param_1 = -0x2713;
24	float10 fVar3;
24	iStack_8 = 0;
24	dVar2 = 0.0;
24	pcVar7 = (char *)piVar6[1];
24	cVar2 = *pcVar7;
24	uVar4 = *(undefined4 *)(in_ECX + 8);
24	iVar8 = piVar3[1];
24	*(undefined4 *)(iVar8 + 5) = param_1;
24	iVar7 = *(int *)(in_ECX + 0x1c);
24	*(undefined4 *)(iVar4 + 0x15) = 1;
24	*(undefined4 *)(in_ECX + 0x1c) = 0;
24	if (lVar6 == 0) {
24	in_ECX[6] = 0;
24	(pvVar2 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_c),
24	(**(code **)(iVar6 + 0x10))(&param_7);
24	*param_3 = -0x2896;
24	if (*piVar9 < 0) {
24	undefined4 local_b8;
24	uVar2 = extraout_var_00;
24	if (-1 < *param_1) {
24	param_2 = (undefined4 *)0x1;
24	tIterator *ptVar3;
24	puVar6 = param_1;
24	iVar1 = *(int *)(in_ECX + 0xc);
24	if (local_c != (int *)0x0) {
24	((tPIMMblockReferenceBase *)&local_8,
24	case 0xc4a4:
24	case 0xc51c:
24	case 0xc530:
24	return 0xd5cd;
24	u64 local_74 [8];
24	*param_3 = sVar2;
24	uVar1 = local_8 & 0xffff;
24	else if (param_4 == 1) {
24	if (param_4 == 3) {
24	if ((int)uVar4 < 1) {
24	uVar2 = uVar4;
24	if (0 < (int)uVar4) {
24	if (ptVar2 == (tBuffer *)0x0) {
24	iVar2 = (**(code **)(*local_8 + 0x4c))(0xb);
24	float fVar5;
24	iVar5 = local_c;
24	undefined4 uStack_58;
24	undefined4 uStack_60;
24	if ((lVar2 != 0) ||
24	iVar1 = FUN_210b2be0(0x48,1,8);
24	if (param_2 == 0x2f8a) {
24	uVar1 = 2;
24	uVar7 = 3;
24	if (((param_1 == 0) ||
24	((param_1 == 1 && (sVar1 = FUN_21006ba0(param_2,0x3bc4,&param_2), sVar1 == 0)))) &&
24	if (param_7 == param_1) {
24	*param_2 = param_8;
24	if (param_13 == param_1) {
24	*param_2 = param_14;
24	if (param_19 == param_1) {
24	*param_2 = param_20;
24	if (param_25 == param_1) {
24	*param_2 = param_26;
24	if (param_31 == param_1) {
24	*param_2 = param_32;
24	return 0xffffd637;
24	iVar8 = 1;
24	(**(code **)(**(int **)((int)in_ECX + iVar10 * 4 + 0x32) + 0x20))
24	local_10);
24	if ((param_1 < 0) || (*(short *)(in_ECX + 8) <= param_1)) {
24	if ((-1 < param_1) && (param_1 < *(short *)(this + 8))) {
24	iVar1 = **(int **)(iVar3 + *(int *)(this + 0x18));
24	(**(code **)(iVar2 + 0x24))(3,0xfe,uVar4);
24	(**(code **)(iVar2 + 0x44))(0xb,uVar4);
24	FUN_210dbf10();
24	ptVar8 = NIBS100::tBufferFactory::makeBuffer
24	NIBS100::tBuffer::~tBuffer(ptVar8);
24	_memDelete(ptVar8);
24	goto LAB_210df08e;
24	iVar5 = **(int **)(in_ECX + 0x1da + uVar6 * 4);
24	if (*param_5 != 0) {
24	(**(code **)(**(int **)(in_ECX + 0xc) + 0x14))(param_2,&param_2,local_c,local_8);
24	if (param_2 == 0x122) {
24	if (param_2 != 0x1a2) {
24	return -0x2789;
24	if (*(short *)(in_ECX + 0x1e) == 0) {
24	if ((local_c == 0xd3) && ((local_10 >> 1 & 0x7ffffffc) != (local_18 & 0xfffffffc))) {
24	goto switchD_210e2ff5_caseD_c62a;
24	in_ECX[local_c * 0x14 + 6] = 5;
24	if (in_ECX[local_c * 0x14 + 0xf] == 0) {
24	ppiStack_98 = (int **)CONCAT22(sVar3 >> 0xf,*(undefined2 *)(in_ECX + 0x3c));
24	sVar3 = (**(code **)(**(int **)(in_ECX + 0x38) + 0x14))();
24	uVar7 = (uVar7 - 1 | 0xfffffffe) + 1;
24	float *pfVar8;
24	double dVar22;
24	iVar6 = local_14;
24	double *pdVar11;
24	double *local_c;
24	if (1 < iVar8) {
24	*puVar18 = 0;
24	dVar1 = pdVar28[1];
24	uVar8 = ftol();
24	lVar2 = tPIMMblockReferenceBase::allocateMemory((tPIMMblockReferenceBase *)&local_10,0x8000,0,8);
24	(0x9a,0xbb,*(undefined4 *)(in_ECX + 0x14f),&local_8);
24	(**(code **)(*piVar2 + 0x40))(*(undefined4 *)(in_ECX + 0x14f),&local_8);
24	(**(code **)(**(int **)(in_ECX + 0x157) + 0x4c))(*(undefined4 *)(in_ECX + 0x14f),&local_8);
24	tTimerTimebaseEfficient *this;
24	(**(code **)(**(int **)((int)in_ECX + 0x157) + 0x4c))
24	pdVar3 = pdVar3 + 1;
24	pdVar9 = pdVar9 + param_3;
24	pdVar8 = pdVar8 + param_3;
24	uVar15 = param_3;
24	uVar15 = uVar15 - 1;
24	local_5c = 0.0;
24	iVar15 = iVar15 + -1;
24	} while (iVar15 != 0);
24	local_34 = (double *)((int)local_34 + -1);
24	} while (local_34 != (double *)0x0);
24	local_8 = local_8 + param_3;
24	if (param_2 != (undefined4 *)0x0) {
24	(**(code **)(**(int **)((int)in_ECX + 0x157) + 0x20))
24	iVar3 = FUN_21117dc0(param_2);
24	local_48 = (double *)0x0;
24	((tPIMMblockReferenceBase *)&stack0xffffffec,0x98,0,0);
24	local_30 = 3.86203234040165e-312;
24	iVar6 = FUN_210f6710();
24	if (((iVar6 == 0) && (iVar6 = FUN_210f4e70(), iVar6 == 0)) && (iVar6 = FUN_210f5650(), iVar6 == 0)
24	iVar6 = -0x28cc;
24	_memDelete(pdVar12);
24	(**(code **)(**(int **)((int)extraout_ECX + 0x163) + 0x50))();
24	*(undefined4 *)((int)extraout_ECX + 0x1e1) = 0;
24	*(undefined4 *)((int)extraout_ECX + 0x1d9) = 0;
24	local_30 = 3.840812382492e-312;
24	local_30 = 3.8832522983113e-312;
24	case (tBuffer *)0x0:
24	case (tBuffer *)0x1:
24	case (tBuffer *)0x2:
24	case (tBuffer *)0x3:
24	case (tBuffer *)0x4:
24	case (tBuffer *)0x5:
24	case (tBuffer *)0x6:
24	(pvVar8 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&param_2),
24	uVar1 = FUN_210039d0((int)param_1);
24	(**(code **)(*piVar2 + 0x44))(0x19,local_c,&local_8);
24	(**(code **)(**(int **)(in_ECX + 4) + 0x20))(0x1b,0,&local_8,param_1);
24	(**(code **)(**(int **)(in_ECX + 8) + 0x34))(0x88,&param_1,local_8,piVar1);
24	*piVar1 = iVar2;
24	if (local_58 == 0) {
24	float fVar6;
24	uVar13 = param_2;
24	if ((param_8 == 0) || (param_9 == 0)) {
24	piVar7 = (int *)0xfffffff4;
24	pvVar3 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&param_2);
24	*piVar1 = iVar4;
24	(**(code **)(**(int **)(in_ECX + 0x1b3) + 0x20))
24	local_8 = FUN_21115650(param_1,25000000,0x4000);
24	local_80 = 0;
24	_memDelete(ptVar6);
24	(**(code **)(**(int **)((int)in_ECX + 0x15f) + 0x24))
24	if (iVar2 != 3) {
24	iVar1 = FUN_21117dc0(param_2);
24	*param_3 = 0x78;
24	if (*(int *)(this_00 + 0x14) != 0) {
24	local_24[3] = 0;
24	undefined2 *param_6)
24	return 0xd8c6;
24	*(undefined2 *)(in_ECX + 0x34) = 0;
24	if (0 < *psVar5) {
24	fVar6 = (float)ftol();
24	FUN_21184ec0(*param_1);
24	if ((sVar4 != 0) && (local_8 == 0)) {
24	if (((short)uVar3 != 0) && ((short)uVar2 == 0)) {
24	tIterator * __thiscall
24	return (tIterator *)0x0;
24	FUN_21127cb0(*(undefined4 *)(this + 0x44));
24	if (*(int *)(this + 4) == 0) {
24	iVar2 = *(int *)this;
24	iVar4 = *(int *)(this + 0x14);
24	iVar5 = *(int *)(this + 0x10);
24	psVar14[0x13] = 1;
24	FUN_211850f0(uVar3,iVar11,0xd);
24	FUN_211850f0(uVar3,iVar11,9);
24	iVar1 = FUN_21069ae0();
24	uVar2 = FUN_2112a3d0(iVar1,param_1,&local_8);
24	return uVar6 & 0xffff0000;
24	ushort local_8;
24	*param_6 = *param_6 + 1;
24	(daqDevice *this,short param_1,short param_2,short param_3)
24	(daqDevice *this,short param_1,short param_2,short *param_3)
24	*puVar2 = uVar6;
24	local_16 = param_2;
24	DWORD local_1a;
24	uVar7 = (param_8 & 0xff) * 2 + 6;
24	iVar8 = (int)uVar7 >> 3;
24	iVar8 = (int)sVar5;
24	if (param_1 == (undefined4 *)0x0) {
24	iVar1 = param_1[8];
24	*piVar4 = (int)puVar6;
24	cVar4 = *pcVar10;
24	if (*piVar3 != 0) {
24	return 0xd57c;
24	short local_84;
24	FUN_21136340(local_18);
24	*(undefined4 *)((int)local_1c + 0x6d5),0,local_1c[1],
24	FUN_21136340(local_44);
24	uVar3 = FUN_21136300(local_44);
24	*(uint *)(local_30 + 0x3d6) & 0xfffffff7;
24	(local_24 = FUN_21156d95(param_1,param_2,1,local_50), local_24 != 0))
24	for (local_68 = 0; local_68 < param_2; local_68 = local_68 + 1) {
24	local_a4 = (ushort)uVar5;
24	FUN_21136340(local_70);
24	uVar6 = FUN_21136300(local_70);
24	for (local_20 = 0; local_20 < 4; local_20 = local_20 + 1) {
24	undefined2 *local_18;
24	if (param_3[local_40] <= *(short *)(local_70 + 0x10)) {
24	local_14 = param_3[local_40] + -1;
24	local_50 = (short *)(local_70 + 0x16 + local_14 * 0xa8d);
24	sVar2 = FUN_21166bd9(*(undefined4 *)(local_50 + 5));
24	local_24 = FUN_21129b00(param_1,*local_50,1,local_50[3],(int)local_50 + 0x6d5,0,
24	for (local_94 = 0; local_94 < 4; local_94 = local_94 + 1) {
24	FUN_21136340(local_48);
24	uVar6 = FUN_21136300(local_48);
24	sVar1 = -0x2730;
24	return -0x29f4;
24	return -0x273b;
24	*(undefined4 *)(local_1c + 0x615 + local_18 * 4) =
24	*(undefined4 *)(param_2 + 0x3e + local_18 * 6);
24	*(undefined2 *)(param_2 + 0x42 + local_18 * 6);
24	*(undefined2 *)(param_2 + 0x10 + local_18 * 2);
24	FUN_211431c0((int)*(short *)(param_2 + 0xe + local_18 * 4),
24	*(undefined2 *)(param_2 + 0x10 + local_18 * 4)),iVar3);
24	local_8 = (short)uVar2;
24	if ((param_2 < 1) || (*(short *)(local_10[0] + 0x10) < param_2)) {
24	iVar1 = local_10[0] + 0x16 + (param_2 + -1) * 0xa8d;
24	local_c = -0x292c;
24	*(undefined4 *)((int)local_1c + (uint)bVar3 * 8 + 0x215) = param_4._0_4_;
24	*(int *)((int)local_1c + (uint)bVar3 * 8 + 0x219) = param_4._4_4_;
24	local_8 = (double *)auStack_138f0;
24	if (sVar1 != 0) goto LAB_2115c052;
24	if (iVar7 != 0) goto LAB_2115c052;
24	uVar4 = (uVar4 - 1 | 0xfffffffe) + 1;
24	uVar3 = (int)param_3 & 0x80000001;
24	sVar4 = -0x2730;
24	local_24 = FUN_2115966a();
24	*(uint *)(local_90 + local_988 * 8 + 0x4ae) =
24	((local_24 = FUN_2115966a(), local_24 == 0 &&
24	if (sVar2 == -0x272f) {
24	*(uint *)(param_1 + 0x959 + (short)local_c * 0x10) =
24	uVar8 = (int)(short)param_2 & 0x80000001;
24	*(uint *)(param_1 + 0x959 + sVar5 * 0x10) =
24	*(uint *)(param_1 + 0x95c + (short)local_c * 0x10) =
24	*(uint *)(param_1 + 0x95c + sVar5 * 0x10) =
24	*(ushort *)((int)local_24 + 0x791) =
24	*(uint *)(param_1 + 0x79e) = uVar2;
24	*(byte *)(param_1 + 0x789 + (int)local_8) =
24	*(ushort *)(param_1 + 0x798) = *(ushort *)(param_1 + 0x798) & 0xf100;
24	local_8 = (short)*(int *)(param_1 + 10);
24	*(byte *)(param_1 + 0x6d6) = *(byte *)(param_1 + 0x6d6) | 0x80;
24	*(byte *)(param_1 + 0x6d6) = *(byte *)(param_1 + 0x6d6) & 0xbf;
24	*(uint *)(param_1 + 0x8fe + param_2 * 4) =
24	*(uint *)(param_1 + 0x8fe + param_2 * 4) | 1 << (param_4 & 0x1f);
24	if (iVar4 != 2000) {
24	CONCAT31((int3)cVar2,(undefined1)local_8),3);
24	iVar2 = *(int *)(*(int *)(param_2 + 0x94e) + param_3 * 4);
24	FUN_2117f44e(&local_30,&local_24,4);
24	FUN_2117f44e(local_2c,&local_20,4);
24	local_14 = sVar3;
24	iVar7 = *(int *)(*(int *)(param_2 + 0x94e) + 4);
24	local_20 = 1.0;
24	local_24 = (float)*(double *)
24	(*(int *)(*(int *)(param_2 + 0x94e) + local_8c * 4) + local_28 * 0x10);
24	local_20 = (float)*(double *)
24	if (local_14 < 0) break;
24	local_8 = (ushort)uVar2;
24	if (uVar7 == 1) {
24	((((0x3f < param_7 && (param_7 != 0x2010)) && (param_7 != 0x2012)) && (param_7 != 0x2011)
24	((((0x3f < param_7 && (param_7 != 0x2000)) && (param_7 != 0x2010)) &&
24	((param_7 != 0x2012 && (param_7 != 0x2011)))))) {
24	pcVar4 = operator*=_exref;
24	puVar3 = (u64 *)u64::u64(local_14,(u64 *)&param_2);
24	psVar2 = DAT_212191c0;
24	int *in_stack_0000002c;
24	puVar7 = puVar1 + (int)param_4;
24	puVar7 = puVar7 + uVar2;
24	if ((param_8 & 0xffff) == 2) {
24	param_4 = (float)ftol();
24	} while (uVar2 < local_10);
24	goto switchD_21188e96_caseD_b;
24	goto LAB_2118a552;
24	local_4e4,1,&local_8,local_a,
24	*param_13 = 0.0;
24	iVar11 = FUN_21185a00((local_8 & 0xffff) << 2);
24	iVar11 = FUN_21185a00((local_8 & 0xffff) << 1);
24	sVar4 = FUN_2100a860((short)puVar2[0x14],&local_44);
24	return puVar9;
24	if (param_5 == -1.0) {
24	if (iVar12 == 0) {
24	case 0x68:
24	*param_5 = 5e-05;
24	case 0x69:
24	case 0x6a:
24	return sVar23;
24	if ((short)uVar15 < 0) goto LAB_21199c81;
24	setI32Attribute(*(undefined4 *)(iVar3 + 0x1b2),*(undefined4 *)(iVar12 + 0x98),0x1e,
24	local_68[0] = 4;
24	uVar10 = FUN_2100a860(iVar2,local_68);
24	} while (uVar10 < *(uint *)(iVar3 + 0x124));
24	if (*(int *)(iVar3 + 0x184) == 1) {
24	local_70[0] = 4;
24	param_5 = (int *)((int)param_5 + 1);
24	sVar12 = (short)psVar7;
24	case 0x3d:
24	local_c = (char *)0x0;
24	sVar5 = (short)uVar6;
24	if (psVar1 == (short *)0x0) {
24	return -0x2798;
24	} while (uVar15 < uVar16);
24	bVar18 = uVar16 == 0;
24	param_18 = (uint *)0x0;
24	(**(code **)(*local_c + 8))(local_c);
24	param_17 = (int *)0x4;
24	param_15 = (int *)0x8;
24	if (*(int *)(local_8 + 0x1ca) != 0) {
24	*param_10 = param_4;
24	*(int *)(local_8 + 0x1ba) * iStack_18,
24	if (iVar13 == 0) goto LAB_211bd7df;
24	setI32Attribute(uVar9,*(undefined4 *)(iVar13 + 0x98),0x1e,param_15);
24	uVar9 = FUN_2104c0b0(param_1,*(undefined4 *)(iVar3 + 0x1c),param_14,param_18,param_19);
24	FUN_211b8970(&local_44);
24	*(double *)(local_8 + 0x1f6) =
24	(double)CONCAT44(uStack_40,local_44) -
24	if (((*(int *)(local_8 + 0x1da) == 0) && (local_c == 0)) && ((bVar12 & 0xf) != 6)) {
24	puVar11 = &param_17;
24	&local_14,&param_16,puVar11);
24	param_17 = param_17 + iVar13 * param_3;
24	uVar4 = *param_1;
24	iVar20 = (int)(short)iVar19;
24	FUN_211c07e0(param_10,iVar19);
24	} while (sVar6 < psVar2[5]);
24	puVar12 = local_18;
24	*param_5 = *param_5 + 1;
24	local_48 = 0.0;
24	local_4c = CONCAT31(local_4c._1_3_,1);
24	local_c = FUN_21150ea4(psVar18,uVar13,0);
24	&local_50);
24	(double)*(float *)(*(int *)(*(int *)(puVar14 +
24	if ((short)uVar15 != 0) goto LAB_211c3149;
24	local_c = uVar15;
24	*(ushort *)(local_14 + 6) =
24	*(undefined4 *)(iVar1 + 0x2e) = 0;
24	FUN_21006ba0(param_1,0xc729,&param_1);
24	uVar12 = (ushort)uVar2;
24	goto LAB_211cf01f;
24	puVar25 = param_14;
24	goto LAB_211d4700;
24	uStack_60 = 0;
24	uStack_5f = 0;
24	else if (*local_10 == 3) {
24	local_3c = CONCAT22((short)((uint)((int)local_24 * 0x17) >> 0x10),*puVar26);
24	local_44 = CONCAT22((short)((uint)*(int *)(puVar26 + 3) >> 0x10),
24	*(undefined2 *)(*(int *)(puVar26 + 3) + (int)local_30 * 2));
24	(*(int *)(*(int *)(puVar26 + 0xf) + (int)local_30 * 4) +
24	sVar4 = *(short *)(*(int *)(*(int *)(*(int *)(*(int *)(psVar19 + 0x3f) + 2) + 0x1e +
24	(int)local_24 * 0x2e) + (int)local_c * 4) +
24	(int)local_30 * 2);
24	if ((sVar4 < 0) || (7 < sVar4)) goto LAB_211d1434;
24	sVar4 = FUN_21171bda(CONCAT22(uVar20,*puVar26),&local_8);
24	*(undefined2 *)((int)local_8 + iVar12 * 0xa8d + -0xa77)));
24	local_24 = (ushort *)
24	*param_12 = (double)(int)local_24;
24	uVar13 = CONCAT22(uVar20,uVar8);
24	sVar4 = FUN_21171bda(local_3c,&local_24);
24	if ((*local_10 == 4) && (local_14 = (uint *)0x0, local_28 != (uint *)0x0)) {
24	CONCAT44(param_6,param_5);
24	puVar26 = (undefined2 *)(*(int *)(*(int *)(psVar19 + 0x3f) + 2) + (int)local_1c * 0x2e);
24	uVar20 = (undefined2)((uint)local_20 >> 0x10);
24	sVar4 = FUN_2117eae6(iVar11,local_58,uVar15);
24	(undefined1)param_9;
24	local_18 = *(uint **)(local_10 + 0x3d);
24	if ((*local_10 == 4) && (local_14 = (uint *)0x0, 0 < (short)local_34)) {
24	pack(disabled)
24	Structure u64 {
24	Length: 0 Alignment: 1
24	1-(bool) status: TRUE if an error has occurred."
24	Leakage Voltage Calibration
24	Doub Click Numm
24	Low Value Inductance Box
24	ctlMenu
24	Oldest compatible LabVIEW.H
24	4)0
24	lFPHP
24	LVINLBVW1
24	lLIvi
24	4=0
24	LPTH0
24	PhdvUh
24	470
24	PVICD
24	dCPTM
24	xLIds
24	,DLDR
24	TFTAB
24	Trigger Mode"
24	statusHD"
24	Gain Calibration
24	D/A Test
24	Leakage Voltage Test
24	IST_WT_A.VIU
24	force re-open
24	terminator@
24	Timeout`
24	ReadQ
24	ABORT?.viS
24	SER_SET.VIV
24	[exception action] (none:0)&
24	CALB_SET.VIW
24	CAP_CAL.VIV
24	Disk Rev#
24	@ Error\FC Out>
24	E_f
24	t(!!
24	QRPj
24	E_^[
24	MRPQV
24	!!h~
24	M_f
24	QRWP
24	E0Pf
24	command
24	LLIvi
24	IND MSG
24	QRhh8h
24	True V
24	DevicePTH0
24	instr handle out@@P
24	VISA session (for class)
24	66666666666666
24	ETQRP
23	if (cVar4 == '\0') {
23	*param_3 = uVar8;
23	undefined2 local_46;
23	undefined2 local_34;
23	local_24 = local_2c;
23	undefined1 in_CF;
23	int param_7)
23	*param_2 = *param_1;
23	Inductance Box Cal Data File
23	Error Conditions (Bit 15 = 1)
23	Read protocol error
23	Bus error occurred during transfer
23	Multiple query error occurred during transfer
23	status is a Boolean array in which each bit describes a state of the GPIB Controller. If an error occurs, the GPIB VIs set bit 15. GPIB error is valid only if bit 15 of status is set.
23	GPIB error is valid only if bit 15 of status is set.
23	-file system error
23	-GPIB bus error (commands)
23	0 = The specified information was returned
23	[W(string) source:  an indication of where an error occurred, usually the name of the VI.
23	No error ini
23	Range: 0 to 30 (31 NONE)
23	[W(string) source:  an indication of where an error occurred, usually the name of the VI.1-(bool) status: TRUE if an error has occurred."
23	fConnect the UUT and/or DVM leads to
23	[error code] (0)0
23	2&fU&gf
23	Cosmetic
23	daqtabls.lsb
23	PLVIN
23	Oldest compatible LabVIEW.Q
23	countM
23	44N3
23	xCPTM
23	|FTAB
23	Input Terminatorm
23	error out.
23	?233
23	#333
23	error outRD
23	QRVP
23	ESR Value
23	QRhh/h
23	QRhh3h
23	QRhh5h
23	QRhh0h
23	oldXP
23	ZXVW
23	mfguser(
23	8BDPW
23	G<QR
23	PLTE
22	undefined2 local_16;
22	long lVar7;
22	FUN_21185a40(local_2c);
22	if ((short)local_40 != 0) {
22	undefined1 local_28 [12];
22	undefined2 uVar15;
22	sVar4 = (short)local_8;
22	sVar1 = (short)param_1;
22	undefined1 local_c [2];
22	if (iVar6 < 0) {
22	int extraout_ECX;
22	if (sVar11 == 1) {
22	sVar5 = (short)local_10;
22	*param_4 = -1;
22	param_5 = 1;
22	local_18 = 2;
22	iVar3 = (int)local_18;
22	local_24 = local_c;
22	ushort uVar15;
22	param_4 = 1;
22	uVar6 = 4;
22	local_1c = local_1c + -1;
22	case 0x4f:
22	uVar4 = 3;
22	uVar4 = uVar4 & 0xffff0000;
22	switch((short)local_10) {
22	sVar2 = 1;
22	short sVar14;
22	if (sVar12 == 0) {
22	undefined4 uVar17;
22	int local_80;
22	local_30 = local_10;
22	undefined4 uStack_74;
22	undefined8 local_18;
22	*(undefined4 *)((int)param_12 + 4) = 0;
22	undefined4 local_a0;
22	undefined4 local_88;
22	*piVar8 = 0;
22	if (param_1 == 0x2c88) {
22	case 0x4e:
22	*param_3 = 0xc;
22	*param_3 = 0xf;
22	case 0x118:
22	case 0x136:
22	switch(local_10) {
22	case 0x443e:
22	case 0x4440:
22	case 0x4442:
22	*param_4 = 0xc;
22	double *local_20;
22	undefined4 uStack_68;
22	double *local_10;
22	double local_44;
22	else if (param_3 == 1) {
22	local_c);
22	float *pfVar11;
22	case 0x133:
22	undefined4 *local_24;
22	param_6 = (uint *)0x0;
22	return uVar6 & 0xffff;
22	if (iVar7 == 1) {
22	if (sVar5 == 4) {
22	uint local_80;
22	if (local_24 < 0) {
22	undefined2 extraout_var_17;
22	undefined2 extraout_var_18;
22	undefined1 local_68 [4];
22	short local_5c;
22	local_24[4] = 0;
22	local_24[5] = 0;
22	for (local_34 = 0; local_34 < 4; local_34 = local_34 + 1) {
22	for (local_3c = 0; local_3c < 4; local_3c = local_3c + 1) {
22	CONCAT22((short)((uint)iVar3 >> 0x10),local_1c[2]));
22	0xfffffffb;
22	if ((param_3 < -1) || (7 < param_3)) {
22	local_c = 0x1e0;
22	else if (iVar7 == 2) {
22	FUN_21185a60(0);
22	if (param_6 == 0.0) {
22	*param_11 = 1;
22	param_11 = param_11 + 1;
22	TPsource is in most cases the name of the VI or function that produced the error.
22	Reads data from a device.  The data read is stored in the buffer represented by read buffer.  This operation returns when the transfer terminates.
22	VFor most applications, you only need to connect wires to the controls and indicators displayed in bold.
22	ZFor most applications, you only need to connect wires to the controls and indicators displayed in bold.
22	This VI reads the port identified by task ID and returns the pattern read.
22	For most applications, you only need to connect wires to the controls and indicators displayed in bold.
22	This VI establishes a port configuration. You can use the task ID that this VI returns only in digital port VIs.
22	.error code. If error code is non-zero, an error occurred. Refer to Appendix C, Error Codes, for a list of error codes.
22	start of read offset (chars.:0 )
22	u(&gf
22	vi.lib
22	XLabl
22	,LVIN
22	LVSB0|gg
22	file path (
22	(U16)
22	Transfer mode bit vector
22	Bit 0
22	Bit 1
22	Number of bytes actually transferred
22	(bit vector)
22	Bit 14
22	Write Ready protocol violation during transfer
22	Bit 13
22	Read Ready protocol violation during transfer
22	Bit 12
22	Data Out Ready protocol violation
22	Bit 11
22	Data In Ready protocol violation
22	Bit 10
22	Bit 9
22	Device did not recognize the command
22	Bit 8
22	Bit 7
22	Bit 6
22	Bit 5
22	Invalid la specified
22	Successful Transfer (Bit 15 = 0)
22	All bytes received
22	Any one of the termination received
22	- Successful transfer
22	(string)
22	retcount&
22	<LIfp
22	488.2 timeout"
22	not mac
22	sync
22	async
22	refnumfnu
22	>L>l
22	J8JX
22	NTMpJ
22	0{d}
22	4882TMO.vi"
22	timeout (488.2 global)(
22	numeric GPIB status$
22	final count"
22	system error"
22	4%0
22	B\\_
22	address (NOADDR)&0
22	?p 5
22	async I/O?46
22	timeout (488.2 global)T
22	FFFFFFFFR
22	numeric GPIB statusM
22	dataL
22	GPIB errorM
22	final countM
22	system errorM
22	@system error
22	Oldest compatible LabVIEW.\D
22	TRec4
22	#bff>
22	GPIB Error:
22	-No error
22	-Function requires GPIB to be CIC
22	-No listeners detected on write
22	-Controller not addressed correctly
22	-Invalid argument(s)
22	(perhaps bad address string????)
22	-Function requires GPIB to be SC
22	-I/O operation aborted
22	-hardware not present
22	-DMA error
22	-DMA bus timeout
22	-New I/O attempted while I/O in
22	progress
22	-function not implemented
22	-shareable board exclusively owned
22	-Serial Poll Byte Lost
22	-SRQ line cannot be cleared
22	-Unrecognized commandEAbyte count refers to the number of bytes that pass over the GPIB.
22	7lE~
22	(c1j
22	#l/r
22	addressM
22	GPIB errorgencode.cGenDispatchEntry
22	statusgencode.cGenCopyProcs3
22	bus
22	8mD}8nD}
22	K5]n
22	data(
22	4(09X<
22	4(09X=
22	4-0TU
22	0/?b
22	data,5
22	busaddress list,5
22	8000MD
22	modeM
22	busM
22	model coded4
22	@@Ft
22	20OD
22	256V
22	VIDS#Instr Read Model Code (GPIB-VXI).vi
22	@GPIB addresse
22	````
22	Field identification number
22	Information for that field^Z(I16)
22	-1 = Device not found
22	-2 = Invalid field
22	field '
22	Dicl4
22	Xicl8
22	LVINLBVW3
22	:BJRP
22	G4hP
22	J8eM
22	P=UF
22	@RCUF
22	UCYF
22	UCYH
22	instr handle inX
22	DQ>TEQ?^E
22	instr handle in'
22	LVCCLBVW*
22	source*
22	status'
22	xCPST
22	LVCCLBVW
22	Oldest compatible LabVIEW.o
22	LVCCLBVW)
22	x?"bf
22	?*,3
22	A unique reference to an instrument I/O session.  It identifies which device to communicate with and all configuration information to perform the I/O.  An instr handle is returned from the Instr Open VI or the Initialize VI of an instrument driver.ZV(bool) status: TRUE if an error has occurred. If status is TRUE, this VI does nothing.
22	instr handle out4
22	4B3"
22	4C3-
22	8CN
22	J| E
22	statusP
22	source ("")[D
22	Jq= Jq
22	Valid IDMD
22	no errorM
22	source ("") @
22	byte countgencode.cGenDispatchEntry
22	VVVVVVVVVVV
22	+V#+#+
22	+++V+V++V+
22	2 et
22	\( ;
22	4A3)
22	bus&B
22	0D?F
22	JJl D
22	w0 F
22	Ba l
22	4H3b
22	GPIB addrr
22	|HIST
22	source0
22	instr handle out@
22	source ("")<
22	(! -
22	B'|4
22	%` 1
22	470>
22	B9$h
22	kd0>G
22	N0,@
22	k0HE
22	\4P0
22	b$ `
22	84j0
22	x4r0
22	44s3
22	VXI logical addr4x
22	VXI logical addr&x
22	"l x
22	.H0yG
22	VXI base addrDzc
22	p4|3
22	p4|b
22	VTL Global.viY
22	VTL Global.viMD
22	LVIN#Instr Read Model Code (GPIB-VXI).vi
22	error outw
22	source ("")<P@
22	##+++
22	primary addressPTH0
22	UFfQ
22	4/0@
22	400E
22	"R$W
22	@Q\
22	410]
22	430s
22	D0>E
22	<0TE
22	D  T
22	GPIB term char en r
22	send mode"r
22	timeout&r
22	10000MD
22	VIDS$Instr Parse Instrument Descriptor.vi
22	INSTR{VXI
22	+VVVVVVVVVVVVVV
22	V#####
22	x?"">
22	instr handle outns
22	LVIN$Instr Parse Instrument Descriptor.vi
22	+VVVV+
22	GlobStat.viMD
22	Error\FC OutW
22	Initial Cal Factors
22	Reading Command@
22	GPIB AddressPTH0
22	DVM Resistance
22	UUT Comm.viO
22	Press to
22	Status Message
22	Double-Click
22	$A!!
22	t)!!
22	RPQV
22	test data in
22	66666666
22	QRhh4h
22	QRhh9h
22	[exception code](
22	IHDR
22	u0QRP
21	undefined2 in_AX;
21	undefined2 local_3e;
21	unaff_CS = 0x1008;
21	Capacitance Box Cal Data File
21	333Short the UUT leads to the
21	status is TRUE if an error occurred. If this value is FALSE, then the error handler assumes that no error occurred according to the error in, and then checks the error code.
21	source. In case of an error, most VIs that use the error in and error out clusters set source to the name of the VI or function that produced the error.
21	Ef;
21	False
21	)error out is a cluster of three elements (status, code, and source) that describe the error state following the execution of the VI. If an incoming error does not exist, the VI executes normally and error out describes the VI's error state; if an incoming error exists, error out equals error in.
21	*error in is a cluster of three elements (status, code, and source) that describe the upstream error state, that is, the existence of any error proceeding the execution of the VI. The VI executes normally only if no incoming error exists; otherwise it merely passes the error in value to error out.
21	HBUF
21	4-0
21	03333
21	LBDHP
21	#T#
21	lCPTM
21	Establishes a communication session with a remote instrument based on the instrument descriptor.  Instr Open creates an instr handle that is used by all other VISA Transition Library VIs to perform operations on that session.
21	This VI writes the value in pattern to the port identified by task ID.
21	You can connect error code to one of the error handler VIs. These VIs furnish you with a description of the error, and give you options on how to proceed when an error occurs. For more information on using the error handler VIs, refer to Chapter 18, Error Handler VIs, of your LabVIEW user manual.
21	;K,C
21	4JTj
21	4JTZDR
21	delay break ?PTH0
21	error codePTH0
21	a=q?
21	4 0
21	Cal Number
21	IST_WT_A.VIV
21	CLRPARW
21	4J0
21	1This error handler is used primarily to inform the user if an input error exists, to describe the error, and to identify where it occurred.  The information for this is derived from the inputs error in, error code, and error source, and from an internal error description table.  The table describes all errors that can be created by LabVIEW or its associated I/O operations.  The handler has provisions to take alternative actions, such as to cancel or set an error status, and to test for and describe user-defined errors.  See instruction on the front panel.
21	The Write to Digital Port VI outputs a pattern (in binary) to a specified digital port.
21	You can control the number of lines in a port by the parameter port width.  You also have the option of not reconfiguring the port as an output port with each iteration of the VI by setting the iteration control to a non-zero value.
21	The Read from Digital Port VI reads a user configured digital port.  The reading is displayed as a binary number in [pattern].
21	You have the option to not reconfigure the port as an input port by setting the iteration control to a non-zero value. You can also concatenate multiple ports to operate as one large port by using the port width paramter.
21	5Generalized DIO96 control.
21	Device:  Card ID.
21	Port Number: (0-11); APA=0, APB=1,APC=2,BPA=3,...
21	Port Width: Width of port in # of bits.
21	Initialize: If zero, port will be initialized.
21	Input: Data, if any, to be written to the port.
21	Read/Write: Bool., F=Read, T=Write.
21	Item Symbols
21	-'zZ
21	Pass = True
21	GPIB Address8
21	Leakage Supply TestV
21	QRhh>h
21	QRhh7h
21	<DTHP
21	ETQRPQ
21	x&pf
21	""")))UUUMMMBBB999
20	piVar2 = piVar2 + 1;
20	iVar1 = *piVar2;
20	undefined2 in_CX;
20	*param_1 = uVar2;
20	psVar4 = psVar4 + 1;
20	iVar3 = (short)param_1 * 0x7a;
20	uVar5 = extraout_var_00;
20	*(short *)(param_1 + 0xaf8) = *(short *)(param_1 + 0xaf8) + 1;
20	if ((*(short *)(param_1 + 0x10) == 0x21) &&
20	*(short *)(param_1 + 0xaf8) = *(short *)(param_1 + 0xaf8) + -1;
20	if (iVar1 == 4) {
20	BOOL BVar3;
20	local_12 = param_3;
20	DWORD local_1c;
20	local_1c = param_1;
20	local_c = param_5;
20	local_c = param_6;
20	param_11,param_12,param_13,param_14,param_15,param_16,param_17,param_18);
20	undefined4 param_17,undefined4 param_18,undefined4 param_19)
20	undefined4 param_21)
20	undefined4 param_13,undefined4 param_14,undefined4 param_15,undefined4 param_16)
20	undefined2 in_stack_00000036;
20	short,short) */
20	ulong param_6)
20	if (iVar4 != 1) {
20	DWORD DVar5;
20	undefined4 in_stack_00000010;
20	return in_stack_00000010;
20	undefined4 in_stack_00000020;
20	return in_stack_00000020;
20	undefined4 param_5,int param_6)
20	*param_4 = *(undefined4 *)(local_d4.Buffer + 4);
20	*(ULONG_PTR *)local_d4.Buffer = UVar1;
20	*(ULONG_PTR *)local_d4.Buffer = param_6;
20	*(ULONG_PTR *)((int)local_d4.Buffer + 8) = param_8;
20	NdrGetBuffer(&local_d4,0x18,param_1);
20	*(undefined2 *)(local_d4.Buffer + 8) = param_4;
20	NdrConformantArrayUnmarshall(&local_d4,(uchar **)&param_5,"\x1b\x03\x04",'\0');
20	*(ULONG_PTR *)local_d4.Buffer = param_4;
20	*(ULONG_PTR *)((int)local_d4.Buffer + 8) = param_6;
20	*(ULONG_PTR *)local_d4.Buffer = param_8;
20	*param_12 = *(undefined2 *)local_d4.Buffer;
20	undefined2 param_4,undefined2 param_5,undefined2 *param_6)
20	NdrConvert(&local_d4,"N\x0fN\x06N\x06N\x06N\x06Q\x01\x06");
20	*(undefined2 *)(local_d4.Buffer + 10) = param_7;
20	NdrConvert(&local_d4,"N\x0fN\bQ\x01\x06");
20	undefined4 param_4,undefined4 param_5,undefined4 param_6,undefined4 param_7,
20	*param_9 = (short)*(ULONG_PTR *)((int)local_d4.Buffer + 8);
20	NdrPointerBufferSize(&local_d4,param_6,"\x12");
20	NdrPointerMarshall(&local_d4,param_6,"\x12");
20	*param_9 = *(undefined2 *)local_d4.Buffer;
20	*pUVar1 = param_5;
20	NdrConvert(&local_d4,"N\x0fN\x06N\x06Q\x01\x06");
20	*param_7 = *(ULONG_PTR *)local_d4.Buffer;
20	sVar1 = -0x28cc;
20	sVar1 = -0x2a3a;
20	FUN_21185a40(local_28);
20	uVar4 = FUN_2100dee0(*(undefined4 *)(in_ECX + 4));
20	uVar5 = ((param_1 >> 0x18 & 0xf) << 8 | param_1 >> 0x10 & 0xf) << 0x10 |
20	if (sVar2 == 2) {
20	uint local_24 [2];
20	uVar2 = (uint)*(ushort *)(in_ECX + 0x2c);
20	iVar4 = param_4;
20	(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
20	undefined4 param_4,undefined4 param_5,undefined4 param_6,undefined4 param_7
20	uStack_1c = 0;
20	CloseHandle(pvVar4);
20	return 999;
20	if (iVar3 < 0) {
20	return -0x2a68;
20	if (param_2 == 0x5311) {
20	bool bVar18;
20	bool bVar19;
20	if (*(short *)(param_1 + 0xa6) == 0) {
20	if ((short)param_2 < 0) {
20	if ((short)local_18 < 0) {
20	switch(sVar5) {
20	FUN_21185130(*(undefined4 *)(local_8 + 0xc),0,(int)*(short *)(local_8 + 0x41b));
20	FUN_21185130(*(undefined4 *)(local_8 + 0xc),0xc,0);
20	if (*(short *)(iVar1 + 0x128) != 2) {
20	if (0 < iVar6) {
20	*param_3 = uVar7;
20	iVar5 = (short)param_1 * 0x7a;
20	if ((sVar2 != 0) &&
20	puVar10 = &local_58;
20	iVar4 = param_3;
20	sVar2 = *(short *)(&DAT_2120f8de + (short)param_1 * 0x7a);
20	sVar5 = sVar5 + -1;
20	FUN_21185130(*(undefined4 *)(local_c + 0xc),6,(int)*(short *)(local_c + 0x421));
20	lpOutBuffer = &local_54;
20	if ((short)uVar17 < 0) {
20	local_c = uVar6;
20	if ((param_4 & 1) != 0) {
20	param_4 = 4;
20	sVar3 = FUN_210450c0(uVar1,iVar2,param_1,iVar5);
20	sVar5 = FUN_2104a3a0(param_1);
20	uVar2 = DAT_21219160;
20	iVar8 = 3;
20	uVar4 = local_10;
20	undefined8 local_1c;
20	*param_7 = sVar3;
20	uVar5 = (undefined2)((uint)in_ECX >> 0x10);
20	bVar3 = bVar3 + 1;
20	return puVar2;
20	param_3 = 2;
20	*local_18 = *local_18 & ~(ushort)local_24;
20	param_2 = (uint)(ushort)((ushort)param_2 >> 1);
20	local_3c = local_3c + 1;
20	if ((short)local_14 != 0) {
20	_param_1 = _param_1 + 1;
20	if ((short)iVar5 != 0) {
20	undefined1 local_54 [4];
20	*local_18 = *local_18 & ~local_20[0];
20	FUN_21185130(uVar1,local_24 & 0xffff,*local_18);
20	*param_16 = 0;
20	psVar2 = param_2;
20	undefined1 uVar5;
20	undefined2 *puVar10;
20	int local_56;
20	puVar12 = &local_58;
20	DVar13 = 0x50;
20	puVar2 = (undefined4 *)((int)puVar2 + 2);
20	if (sVar1 != 1) {
20	iVar1 = param_1 + -1;
20	uVar12 = extraout_var_01;
20	uVar12 = extraout_var_02;
20	uVar12 = extraout_var_03;
20	uVar5 = local_28;
20	iVar4 = local_18;
20	uVar7 = param_1;
20	undefined4 unaff_ESI;
20	param_4[4] = 0;
20	param_5[1] = 0;
20	return (uint)param_5 & 0xffff0000;
20	puVar3[5] = 0;
20	param_1 = (undefined4 *)0x0;
20	if (sVar5 == 6) {
20	if (sVar15 != 0) {
20	return uVar8 & 0xffff0000;
20	sVar2 = *(short *)(iVar3 + 0x1e2);
20	else if (sVar2 == 1) {
20	uVar7 = uVar7 | 0x20;
20	puVar2 = param_6;
20	uVar7 = 8;
20	iVar3 = (int)(short)param_1;
20	if (param_2._3_1_ == '\0') {
20	uVar10 = local_10;
20	return (int)(short)local_1c;
20	if (puVar3 != (undefined4 *)0x0) {
20	return sVar10;
20	iVar10 = iVar10 + local_14;
20	return CONCAT22(uVar4,0xd75d);
20	if (-1 < (short)local_c) {
20	*puVar1 = uVar4;
20	ushort *local_10;
20	if ((param_2 < 0) || (1 < param_2)) {
20	return 0x2973;
20	sVar3 = param_3;
20	local_c = 0x2975;
20	*param_3 = (ushort)bVar1;
20	local_14 = 3;
20	if (sVar6 < 0) {
20	iVar6 = param_2;
20	*param_7 = (short)(char)param_4[4];
20	uVar16 = uVar16 & 0xfbff;
20	uVar16 = uVar16 & 0xf7ff;
20	sVar15 = sVar15 + 1;
20	FUN_21185130(*(undefined4 *)(param_1 + 0xc),0x14,(int)(short)uVar5);
20	FUN_21185130(*(undefined4 *)(param_1 + 0xc),0,(int)(short)uVar8);
20	FUN_21185130(*(undefined4 *)(param_1 + 0xc),2,(int)(short)uVar7);
20	else if ((short)param_5 == 1) {
20	*(ushort *)(param_1 + 0x101) =
20	uVar6 = FUN_21185070(*(undefined4 *)(param_1 + 0xc),0);
20	FUN_21185130(*(undefined4 *)(param_1 + 0xc),4,*(undefined2 *)(param_1 + 0xa3));
20	sVar9 = 0x2975;
20	if (*(short *)(&DAT_2120f8de + (short)param_1 * 0x7a) == 4) {
20	local_24 = local_1c;
20	*param_5 = local_18;
20	*param_6 = local_c;
20	u64 local_40 [8];
20	param_1[1] = param_3;
20	undefined4 uStack_70;
20	u64 local_50 [8];
20	puVar4 = (u64 *)u64::u64(local_48,local_40);
20	iVar3 = local_8;
20	int local_2a;
20	local_24 = local_14;
20	local_20 = local_10;
20	if (param_4 == 50000) {
20	puVar1 = (undefined1 *)*param_1;
20	iVar1 = (int)param_1;
20	return (uint)puVar3 & 0xffff0000;
20	sVar1 = *param_1;
20	iVar7 = 10;
20	iVar5 = (int)sVar6;
20	iVar2 = (int)(short)param_1;
20	local_c = 5;
20	local_8 = 3;
20	return uVar10 & 0xffff;
20	uVar12 = 1;
20	uVar2 = FUN_210039d0((int)(short)param_1);
20	iVar2 = 10;
20	uint uVar18;
20	byte bVar12;
20	puVar11 = (undefined4 *)((int)puVar11 + 2);
20	return -0x298c;
20	iVar4 = FUN_21183e00(local_24);
20	*(undefined4 *)(param_2 + 0x266) = 0;
20	local_20 = local_30;
20	if (sVar5 < 1) {
20	return param_1 & 0xffff;
20	undefined2 *param_10)
20	iVar3 = param_9;
20	FUN_21183d20(local_2c,uVar8);
20	local_c = local_1c;
20	switch(uVar4) {
20	case 0x45:
20	uVar5 = 3;
20	local_1e = param_3;
20	piVar6 = param_2;
20	sVar4 = (short)uVar5;
20	sVar2 = strlen(param_2);
20	puVar1[1] = param_3;
20	return -0x2866;
20	uVar14 = *puVar1;
20	iVar18 = 0;
20	sVar1 = *(short *)(&DAT_2120f8de + param_1 * 0x7a);
20	if ((*(byte *)((uint)param_2 + param_3) & local_5) == 0) {
20	local_5 = local_5 >> 1;
20	if ((local_5 == 0) && (param_2 != 0)) {
20	uVar2 = **(ushort **)(param_1 + 0x26);
20	uVar2 = uVar2 | param_3;
20	uVar2 = uVar2 & ~param_3;
20	if (param_3 == 0) break;
20	else if ((param_3 == 2) && (*param_4 == 0)) break;
20	if (local_8 == 50000) break;
20	return -0x2abc;
20	sVar3 = *(short *)(param_1 + 0x14);
20	in_ECX = extraout_ECX;
20	bVar1 = 0;
20	_STCMgrControlUser_12(uVar3);
20	*DAT_212191c0 = 0xe;
20	param_8 = param_8 + 1;
20	byte *pbVar4;
20	int iVar19;
20	char *local_1c;
20	if (uVar15 == 0) {
20	*piVar3 = iVar4;
20	iVar4 = iVar4 + 0x51;
20	sVar5 = 2;
20	if (local_20 != 0) {
20	iVar5 = (int)param_2;
20	if (bVar16) {
20	undefined2 uStack_a;
20	if (*(char *)(param_2 + 0xa86) != '\0') {
20	return -0x276d;
20	iVar8 = (int)sVar3;
20	cVar8 = '\0';
20	if (*param_3 != 0) {
20	undefined4 uVar16;
20	undefined1 local_4c [4];
20	iVar12 = (int)sVar5;
20	iVar7 = iVar7 + 0x51;
20	iVar7 = ftol();
20	if (local_38 == 0) {
20	uVar17 = 0;
20	if (iVar9 != 0) break;
20	sVar2 = *param_3;
20	short local_a;
20	local_14 = *(int **)(local_20 + 0xcf);
20	goto LAB_210728ed;
20	FUN_21185030(*(undefined4 *)(param_2 + 0xc),0x1f);
20	return uVar12 & 0xffff0000;
20	FUN_21185130(*(undefined4 *)(param_2 + 0xc),4,(int)*(short *)(param_2 + 0x41f));
20	if ((*(char *)(*param_3 + 0x44) == '\x01') || (*(char *)(param_3[1] + 0x44) == '\x01')) {
20	if ((*(char *)(*param_3 + 0x44) == '\x02') || (*(char *)(param_3[1] + 0x44) == '\x02')) {
20	piVar5 = param_3;
20	uVar7 = uVar2;
20	if (bVar6) {
20	iVar2 = (int)sVar4;
20	puVar6 = &local_8;
20	iVar2 = palStatusMapStatusValue(uVar3);
20	if (cVar1 == '\0') break;
20	sVar1 = FUN_210797b0(param_1,&param_1);
20	iVar2 = FUN_21079340(param_1);
20	uint *puVar9;
20	CloseHandle(DAT_2121a070);
20	*param_3 = param_1;
20	return 0xffffd8eb;
20	local_c = in_ECX;
20	if (sVar2 != -1) {
20	undefined4 local_dc;
20	undefined4 local_d8;
20	undefined4 local_d4;
20	undefined4 local_c4;
20	local_a8 = 0;
20	local_94 = 0;
20	else if (iVar1 == 2) {
20	sVar5 = (short)param_3;
20	*param_4 = 0x1ff;
20	bVar2 = 1;
20	puVar2 = puVar1;
20	void *_Dst;
20	*param_5 = iVar2;
20	param_1 = *(int *)(param_1 + 6);
20	} while (*(short *)(param_1 + 4) != 0);
20	FUN_210829b0(param_1,param_2,param_3);
20	case 0x52ef:
20	case 0x52f0:
20	case 0x52f1:
20	case 0x52f2:
20	case 0x52f4:
20	case 0x52f5:
20	case 0x52f6:
20	case 0x52f7:
20	case 0x52f9:
20	case 0x52fa:
20	case 0x52fb:
20	case 0x52fc:
20	case 0x5312:
20	case 0x5313:
20	case 0x5314:
20	case 0x5315:
20	case 0x5317:
20	case 0x5318:
20	case 0x5319:
20	case 0x531a:
20	case 0x532d:
20	case 0x532e:
20	case 0x5320:
20	if (*(char *)(param_1 + 0xb0) == '\x01') {
20	*(undefined4 *)(param_1 + 0x1be) = 0;
20	local_8 = (int *)0x0;
20	cVar2 = cVar2 + '\x01';
20	local_1c = 3;
20	tTimerTimebaseEfficient local_50 [4];
20	u64 local_44 [8];
20	if (param_6 < 0.0) {
20	if (!bVar1) break;
20	uVar2 = local_30;
20	puVar7 = (u64 *)FUN_21058950();
20	local_8 = param_3;
20	undefined4 uStack_c;
20	*(undefined4 *)(in_ECX + 4) = 0;
20	*(undefined4 *)(in_ECX + 0xc) = 0;
20	*(undefined4 *)(in_ECX + 0x18) = param_1;
20	*(undefined4 *)(in_ECX + 0x20) = param_3;
20	*(undefined4 *)(in_ECX + 0x28) = 1;
20	FUN_21082350(&local_14);
20	long local_c [2];
20	mdsSimpDIGInterpreter *this;
20	*(undefined4 *)(in_ECX + 0x5e) = 0;
20	puVar3 != (undefined4 *)0x0)) {
20	*(undefined4 *)(in_ECX + 0x82) = 0;
20	_memDelete((void *)0x0);
20	sVar2 = (**(code **)(*in_ECX + 0x560))
20	param_8,param_9);
20	setNumReadingsAndSrcIndex
20	if (fVar1 == 0.0) {
20	if (0 < (short)param_3) {
20	sVar2 = FUN_21082970(param_1,&param_1);
20	if (*(char *)(param_1 + 3) != '\0') {
20	*(undefined4 *)(param_1 + 0x33d) = 1;
20	iVar1 = FUN_210884f0(*(undefined4 *)(in_ECX + 0x14),in_ECX + 0x7e);
20	iVar1 = *(int *)(in_ECX + 0x2c);
20	*param_3 = local_10;
20	else if (local_c == 0) {
20	sVar2 = _STCMgrControlUser_12(uVar4);
20	sVar2 = -0x2a3a;
20	in_ECX[2] = param_2;
20	uVar1 = *puVar4;
20	in_ECX[0xe] = 0;
20	in_ECX[0x13] = 0;
20	puStack_3c = (undefined4 *)local_24;
20	uVar1 = *in_ECX;
20	sVar2 = FUN_210990b0(param_1);
20	uVar4 = 6;
20	int param_6,int param_7)
20	puVar4 = param_8;
20	if (0 < (short)local_8) {
20	sVar3 = (short)uVar4;
20	param_1 = FUN_21082330();
20	uStack_18 = 0;
20	_STCMgrControlUser_12(uVar6);
20	*(int *)(iVar2 + 0x4ad) = iVar1;
20	iVar3 = (int)(short)param_2;
20	param_3 = uVar6;
20	FUN_210918a0(param_1,param_4,local_8,_param_2,uVar6,param_6,&local_14);
20	uStack_4c = 0;
20	uStack_3c = 0;
20	uStack_28 = 0;
20	param_1 = iVar5;
20	if (param_2 != 0x3b60) {
20	if (param_3 != 0x89e4) {
20	if ((iVar1 == 0) && (local_8 != -0x6d63)) {
20	if ((iVar1 == 0) && (local_c != -0x6d63)) {
20	return -(uint)(iVar1 != 0) & 0xffffd7fd;
20	(in_ECX,param_1,param_2,param_3,param_4,param_5);
20	,undefined4 param_6)
20	psVar3 = psVar3 + 1;
20	(ulonglong)(uint)(int)(short)local_20)] == (short)local_10) &&
20	uVar9 = local_c;
20	u64 local_14 [8];
20	ulong uVar5;
20	*(byte *)(param_1 + 0x3b1) = bVar1;
20	local_8 = 0xffffd5c6;
20	iVar2 = ftol();
20	if (param_2._2_2_ == 0) {
20	u64 local_38 [8];
20	if (local_8 != 0) goto LAB_2109abd8;
20	FUN_2109a030(iVar9,&param_2,1);
20	puVar8 = (undefined2 *)((int)&param_2 + 2);
20	puVar8 = puVar8 + -1;
20	*(undefined2 *)(param_9 + (uVar10 % param_4) * 2) = uVar2;
20	*puVar3 = *puVar3 + 1;
20	param_6 = param_6 + -1;
20	if (param_4 == 4) {
20	tBufferFactory local_18 [8];
20	return 0xffffd89a;
20	local_10 = uVar4;
20	uVar4 = FUN_2109eaa0(*(undefined4 *)(in_ECX + 0x11));
20	iVar5 = FUN_2109eb30(uVar4,uVar8,uVar9);
20	tBuffer *ptVar3;
20	local_10 = local_8;
20	_memDelete(ptVar3);
20	void *pvVar8;
20	if (*(int *)(in_ECX + 1) != 0) {
20	long *plVar8;
20	undefined2 local_34 [5];
20	if (2 < param_3) {
20	in_ECX = local_8;
20	return param_5;
20	*param_5 = local_8[0];
20	return (-(uint)(iVar1 != 0) & 0x28cc) - 0x28cc;
20	pcVar10 = pcVar10 + 1;
20	return local_18[0];
20	*(double *)((int)psVar1 + 0x2b) =
20	if (sVar5 != 2) {
20	*(undefined4 *)param_4 = 0;
20	if (*(char *)(*(int *)(in_ECX + 0xa7) + 0x17e) == '\x02') {
20	uVar5 = ftol(2);
20	sVar1 = (**(code **)(*in_ECX + 0x6a4))(param_1,local_38);
20	else if (sVar1 == 2) {
20	return local_10[0] & 0xffff;
20	sVar2 = *(short *)(iVar4 + 0x10);
20	if (*piVar5 == 0) {
20	iVar4 = in_ECX[6];
20	_memDelete((void *)in_ECX[1]);
20	in_ECX[0x15] = 0;
20	piVar1 = *(int **)(in_ECX + 0xc);
20	(**(code **)(**(int **)(in_ECX + 0xc) + 0x10))(0xffff0008,0,param_1);
20	iVar7 = **(int **)(in_ECX + 0xc);
20	int iStack_8;
20	local_2c = 0.0;
20	pdVar4 = pdVar4 + 1;
20	*(undefined4 *)((int)param_3 + 4) = 0;
20	*(undefined4 *)(in_ECX + 0x1c),param_3);
20	,param_3);
20	*(undefined4 *)(in_ECX + 0x20) = 0;
20	_memDelete(*(void **)(in_ECX + 4));
20	in_ECX[0x17] = 0;
20	*(undefined1 *)(in_ECX + 0x60) = 0;
20	FUN_211d8680();
20	local_4c = 0.0;
20	} while (uVar3 < 8);
20	iVar1 = *(int *)(in_ECX + 4);
20	if (-1 < *param_6) {
20	if (iVar1 == 0) break;
20	goto LAB_210b3a6d;
20	iVar6 = *param_7;
20	iVar6 = **(int **)(in_ECX + 0x138);
20	if (param_5 != (int *)0x0) {
20	piVar3 = param_5;
20	else if (param_2 == 0) {
20	piVar1 = param_4;
20	if (*param_4 < 0) {
20	if (-1 < *param_5) {
20	*param_5 = -0x2a58;
20	iVar3 = *param_6;
20	*in_ECX = iVar1;
20	piVar4[1] = (int)s_j__drvsrc_ALL_nidaq_e_series_wal_2120a994;
20	if (lVar8 == 0) {
20	uVar5 = local_20;
20	local_8 = in_ECX + 0x3b;
20	local_22 = param_2;
20	*param_2 = 0xffffd734;
20	if (-1 < iVar7 + -1) {
20	local_c = *(undefined4 *)(in_ECX + 0x20);
20	local_c = (int *)0x0;
20	local_24[2] = 0;
20	local_c = pvVar7;
20	local_8 = *(int *)(iVar1 + 0xc);
20	pvVar7 = local_c;
20	undefined4 local_30 [8];
20	local_c = *(int *)(iVar1 + 0xc);
20	case 0xc4f4:
20	*param_3 = 0x6dc4;
20	tBuffer::~tBuffer(this);
20	FUN_210c4bd0();
20	*param_5 = iVar1;
20	if (*param_6 == 0) {
20	case 0x131:
20	case 0x132:
20	iVar2 = param_3;
20	fVar4 = 0.0;
20	if ((int)uVar5 < 1) {
20	*param_15 = 0;
20	*(undefined4 *)(in_ECX + 0x4c) = 0;
20	if (iVar1 != 0) goto LAB_210cac22;
20	uVar1 = local_10;
20	uVar3 = 4;
20	if (iVar1 != 0) goto LAB_210cb238;
20	__16slotInitMap = __16slotInitMap | (ushort)(1 << ((char)param_1 - 1U & 0x1f));
20	0xffffffff,0x5a,0xffffffff,0x5a,0xffffffff,0x5a,0xffffffff,0x5a,0xffffffff,
20	long local_44 [2];
20	long local_3c [2];
20	param_4 = (int *)0x0;
20	*(undefined4 *)(in_ECX + 0x48) = 0;
20	if (param_2 == 0x7d64) {
20	FUN_210cfc20(0x300,uVar3);
20	_param_2 = _param_2 + -1;
20	} while (_param_2 != 0);
20	FUN_210d13e0(0,&local_8);
20	if (param_3 == param_1) {
20	*param_2 = param_4;
20	if (param_5 == param_1) {
20	*param_2 = param_6;
20	if (param_9 == param_1) {
20	*param_2 = param_10;
20	if (param_11 == param_1) {
20	*param_2 = param_12;
20	if (param_15 == param_1) {
20	*param_2 = param_16;
20	if (param_17 == param_1) {
20	*param_2 = param_18;
20	if (param_21 == param_1) {
20	*param_2 = param_22;
20	if (param_23 == param_1) {
20	*param_2 = param_24;
20	if (param_27 == param_1) {
20	*param_2 = param_28;
20	if (param_29 == param_1) {
20	*param_2 = param_30;
20	*param_2 = param_34;
20	FUN_210d6620();
20	uVar1 = (**(code **)(iVar3 + 0x7c))(&local_8);
20	local_c = (double)(ulonglong)param_2;
20	bVar11 = local_8 < 0;
20	*param_2 = 0x6720;
20	if ((-1 < param_1) && (param_1 < *(short *)(in_ECX + 8))) {
20	if (param_3 == (short *)0x0) {
20	local_8 = (long *)0x0;
20	return (int)local_8;
20	sVar3 = _STCMgrControlUser_12(*(undefined4 *)(in_ECX + 0x14),0x2003,&local_34);
20	uVar1 = (**(code **)(iVar2 + 0x7c))(&local_8);
20	float local_8;
20	psVar12 = param_3;
20	uVar7 = (**(code **)((int)param_7 + 0x7c))(&local_8);
20	return 0xffffd79b;
20	} while (local_10 < *(uint *)(in_ECX + 0x38));
20	iVar1 = **(int **)(in_ECX + 0x1da + iVar5 * 4);
20	case 0x13f:
20	case 0x147:
20	puVar4[0xc] = 0;
20	case 0xc58a:
20	local_8 = -0x278b;
20	local_8 = -0x2968;
20	if ((iVar1 != 4) && (iVar1 != 5)) {
20	if (*(int *)(iVar4 + 0x40) == 0) {
20	iVar4 = *(int *)(in_ECX + 0x1c + param_2 * 0x58);
20	if ((iVar4 != 4) && (iVar4 != 5)) {
20	case 0xc486:
20	case 0xc580:
20	iVar7 = *piVar3;
20	return 0xd875;
20	*param_2 = (undefined2)local_8;
20	local_8 = (void *)0x0;
20	if (*param_1 == (int **)0x0) {
20	case 0x43d0:
20	case 0x43da:
20	case 0xc562:
20	case 0xc56c:
20	goto switchD_210efc65_caseD_3412;
20	double *pdVar14;
20	} while (uVar18 < 0x40000);
20	goto switchD_210f1dca_caseD_4;
20	_memDelete(pdVar5);
20	puVar7 = local_c;
20	local_8 = (undefined4 *)0x0;
20	(**(code **)(*piVar2 + 0x20))(0x2f,0x52,*(undefined4 *)(in_ECX + 0x14f),&local_8);
20	iVar1 = **(int **)(in_ECX + 0x157);
20	(**(code **)(**(int **)(in_ECX + 0x15b) + 0x24))
20	uVar1 = *(undefined4 *)(in_ECX + 0x14f);
20	uStack_c = 0;
20	local_20 = (double *)0x0;
20	(**(code **)(**(int **)((int)in_ECX + 0x163) + 0x20))();
20	local_8 = (**(code **)(*in_ECX + 0x454))();
20	if (in_ECX[3] == 0x4a) {
20	} while (uVar5 != 0);
20	double *pdVar12;
20	pdVar7 = param_5;
20	dVar1 = *pdVar7;
20	double local_4c;
20	piVar1 = (int *)(**(code **)(**(int **)(in_ECX + 0x153) + 0x14))(0xe,0,&local_8);
20	(2,*(undefined4 *)((int)in_ECX + 0x14f),&local_8);
20	(**(code **)(**(int **)((int)in_ECX + 0x157) + 0x30))
20	(**(code **)(**(int **)((int)in_ECX + 0x157) + 0x24))
20	(**(code **)(*piVar1 + 0x40))(*(undefined4 *)((int)in_ECX + 0x14f),&local_8);
20	if (param_1 < 1) {
20	DownloadInterpreter *in_ECX;
20	switch(*(undefined2 *)(in_ECX + 0x2c)) {
20	sVar3 = -0x28a3;
20	if ((local_c == 0) &&
20	param_3 = (double *)0x0;
20	*piVar1 = local_c;
20	if (local_c < 0) {
20	if (*(int **)(in_ECX + 8) != (int *)0x0) {
20	(**(code **)(**(int **)(in_ECX + 4) + 0x38))(4,0,local_10,&local_8);
20	if (this != (tTimerTimebaseEfficient *)0x0) {
20	*(undefined4 *)(this + 4) = 0;
20	tTimerTimebaseEfficient local_6c [4];
20	int *in_stack_00000030;
20	if (piVar4 == (int *)0x0) {
20	if (*(short *)(param_4 + 0xb0) == 2) {
20	if (&stack0x00000000 == (undefined1 *)0xfffffffc) {
20	ushort *in_ECX;
20	FUN_2110e470(0xfa);
20	iVar3 = (param_1 & 0xffff) * 4;
20	iVar5 = local_10;
20	if (0 < (short)uVar2) {
20	uVar2 = 0xffffd5d0;
20	(**(code **)(**(int **)((int)in_ECX + 0x1b3) + 0x24))
20	if (pcVar4 != (char *)0x0) {
20	(*(undefined4 *)(in_ECX + 0x14f),&local_8);
20	(**(code **)(**(int **)((int)in_ECX + 0x163) + 0x40))
20	float *pfVar1;
20	else if (iVar2 == 2) {
20	local_14 = &local_8;
20	local_10 = 0xfffffff0;
20	(**(code **)(*piVar3 + 0xa0))(0x42415421,0xc,&local_14,&param_2);
20	short local_18 [2];
20	_Dst = (double *)((int)_Dst + 1);
20	local_8 = -0x28dd;
20	if ((short)param_2 == 5) {
20	(**(code **)(**(int **)(in_ECX + 0x50) + 0x4c))(0xb);
20	undefined4 *local_18;
20	NIBS100::tBuffer::~tBuffer(local_8);
20	if (((short)uVar5 != 0) && (bVar15 = (short)local_8 == 0, bVar15)) {
20	*,struct timeStruct *) */
20	*,unsigned long),void *,unsigned long,unsigned long *,struct timeStruct *) */
20	*,void *,unsigned long),void *,unsigned long) */
20	if (in_ECX[1] == 0) {
20	FUN_211850f0(uVar3,iVar11,*pbVar2);
20	if (((*(uint *)(iVar6 + 0x28) | uVar12) >> (bVar7 & 0x1f) & 2) != 0) {
20	if ((short)param_8 == 2) {
20	else if (uVar3 == 2) {
20	case '\t':
20	if (-1 < sVar9) {
20	return 0xd864;
20	psVar3 = param_5;
20	local_8 = sVar1;
20	*param_5 = param_3;
20	uVar8 = param_4;
20	(daqDevice *this,short param_1,ulong param_2,ulong param_3)
20	*,short *) */
20	(daqDevice *this,short param_1,ulong param_2,ulong param_3,ulong param_4)
20	short local_50 [2];
20	local_1a = (int)param_1;
20	int *local_44;
20	iVar13 = iVar8;
20	iVar13 = iVar8 + 1;
20	cVar3 = (char)iVar8;
20	else if (param_1 == 2) {
20	else if (param_1 == 4) {
20	if (iVar6 == 1) {
20	piVar2 = (int *)*piVar2;
20	palStatusMapStatusValue(uVar4);
20	param_8 = param_8 + uVar4;
20	uVar9 = 0x8980;
20	nOutBufferSize = 10;
20	nInBufferSize = 10;
20	dwIoControlCode = 0xabcd2014;
20	} while (!bVar9);
20	if (_SCXIchassis != (short *)0x0) {
20	local_c = (short *)0x0;
20	} while (!bVar5);
20	return (undefined2 *)0xd5c6;
20	sVar16 = 0;
20	char *local_10;
20	local_8 = FUN_21171bda(param_1,&local_c);
20	if ((param_3 & 0x8000) == 0) {
20	for (local_28 = 0; local_28 < 4; local_28 = local_28 + 1) {
20	local_8 = FUN_21171bda(param_1,&local_1c);
20	local_8 = (short)puVar1;
20	return puVar1;
20	if ((-1 < sVar2) && (sVar3 = local_10, sVar2 != 0)) {
20	if ((local_10 == -0x272f) && (local_10 = FUN_21146c41(param_1), local_10 == 0)) {
20	switch((undefined2)local_14) {
20	local_10 = (undefined2 *)(local_14 + 0x16 + (param_2 + -1) * 0xa8d);
20	sVar2 = local_10;
20	uVar4 = (int)param_3 & 0x80000001;
20	local_c = (undefined2 *)(local_10 + 0x16 + (param_2 + -1) * 0xa8d);
20	sVar1 = FUN_21166c24(*(undefined4 *)(local_c + 5));
20	local_8 = FUN_21146493(param_1,*local_c,1,local_c[3],*(undefined4 *)((int)local_c + 0x6d5),0
20	return -0x288f;
20	if (sVar3 == -0x272f) {
20	sVar2 = FUN_21146c41(param_1);
20	return CONCAT22(uVar5,0xd675);
20	*(undefined1 *)(param_1 + 0x6d5) = 1;
20	*(undefined4 *)(param_1 + 0x79a) = 0;
20	return CONCAT22((short)(uVar5 >> 0x10),0xd8e9);
20	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 2;
20	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0xf7;
20	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0xe7;
20	uVar5 = 1 << ((byte)local_14 & 0x1f);
20	local_c = (uint)((param_4 & uVar5) != 0);
20	float local_24;
20	puVar1 = *(undefined4 **)(*(int *)(param_2 + 0x94e) + param_3 * 4);
20	FUN_211737b9(CONCAT22((short)((uint)local_34 >> 0x10),param_5),local_3c,local_1c,local_34);
20	local_c = local_c + param_3 * 8;
20	local_c = 0xe8;
20	local_c = 0x174;
20	else if (iVar2 == 3) {
20	*(char *)(param_2 + 0x6d5) = (char)uVar1;
20	*(byte *)(param_2 + 0x6d5) = *(byte *)(param_2 + 0x6d5) | 8;
20	return *(short *)((int)DAT_212191c0 + 1);
20	uVar11 = local_8;
20	puVar3 = (u64 *)u64::u64(local_1c,(u64 *)&param_2);
20	return (tPIMMblockReferenceBase *)0x0;
20	param_4 = (int *)((int)param_4 + uVar2);
20	} while (param_4 < uVar12);
20	return -0x271e;
20	sVar4 = -0x28a3;
20	FUN_21185a40(local_5c);
20	FUN_21185a40(0);
20	if (param_7 == -1.0) {
20	iVar11 = *(int *)(iVar11 + 0x94);
20	iVar6 = FUN_21185a00((int)param_2 * 8);
20	sVar2 = (short)iVar3;
20	iVar5 = *(int *)(iVar5 + 0x94);
20	setI32Attribute();
20	switch(uVar5) {
20	param_1 = (undefined4 *)param_1[0x25];
20	puVar9 = (undefined2 *)
20	if ((short)puVar9 != 0) {
20	if (param_4 == -1.0) {
20	uVar2 = *(uint *)(param_1 + 0x124);
20	if (uVar2 != 1) {
20	if (fVar1 < *(float *)(*(int *)(param_1 + 0x136) + uVar4 * 4)) {
20	fVar1 = *(float *)(*(int *)(param_1 + 0x136) + uVar4 * 4);
20	if (fVar1 == 500.0) {
20	*param_4 = 0x46b4;
20	return (uint)uVar5 << 0x10;
20	if ((int)param_2 <= param_1) {
20	goto LAB_21197730;
20	float *pfVar9;
20	iVar8 = iVar8 + param_6;
20	uVar15 = 0xffffd734;
20	sVar6 = FUN_2118c180();
20	sVar2 = strlen(_Dest);
20	if (param_8 != (undefined2 *)0x0) {
20	FUN_21185a40(param_8);
20	uVar1 = FUN_211a0e40(param_1,local_14,local_10,&local_8,local_c,(int)&param_1 + 2);
20	sVar4 = FUN_210077d0(uVar2,param_4,param_8,param_13);
20	iVar3 = iVar3 + iVar2;
20	sVar14 = sVar14 + 1;
20	} while (sVar3 < param_3);
20	if (0 < *(short *)(DAT_212233e0 + 2)) {
20	*param_14 = 0.0;
20	goto LAB_211a5898;
20	if (*(short *)(local_c + 4) != 1) {
20	if ((uVar8 != 0) || (uVar7 != 0)) goto joined_r0x211add5a;
20	if (DAT_21223784 == 0) {
20	psVar9 = local_3c;
20	pfVar5 = pfVar5 + 0xf;
20	uVar1 = param_6[4];
20	*param_5 = uVar6;
20	if ((((short)uVar5 < 0) || (bVar14 = (short)local_8 == 0, bVar14)) &&
20	(local_8 = uVar5, (short)uVar5 < 0)) {
20	*psVar1 = 8;
20	case 0x6d:
20	goto LAB_211cfb05;
20	8 LVARLBVW
20	Measure volts, amps, or ohms.  Select one of 6 functions.  Select range or use auto range.  Select trigger mode.  Slow reading rate is used for accuracy.                                         version a.0
20	(**(code **)(*piVar1 + 0x40))(*(undefined4 *)(local_8 + 0x14f),param_2);
20	u0&g
20	E$gf
20	OBDP
20	COSM
20	Pj=hO
20	LMLbl
20	+++++
20	TLVIN
20	4l0
20	@0default name@0
20	O$0
20	HBIN
20	4'0
20	errorM
20	port number4
20	,HIST
20	CPRF
20	(BDHP
20	400
20	4!0
20	8LIbd
20	range (auto:0)<@P
20	measurement2@P
20	~DD|
20	instr handle out<@P
20	GlobStat.vi`
20	4LIvi
20	x?bf
20	@ Error\FC Outut
20	CAPSETUP.viW
20	TEST FAILED!H
20	GlobStat.viV
20	8LIfp
20	INSTRUCTIONS:
20	Normal Use:  When using subVIs that incorporate the error in/error out (or error I/O) structure, place this handler where you want to inform the user of an error, typically at the end of the I/O data path, as the last action of the program.  If the error in status is ERROR, the handler creates a message describing the error and its source.  If the type of dialog = 1 (default), the message is displayed to the user, who can only acknowedge it.  If the type = 2, the user can acknowledge the message or abort execution; aborting a program with active I/O is not recommended.  If the type = 0, no message is displayed; this is used to process the error programmatically, and the error out cluster elements are wired to individual terminals for that reason.
20	Other Uses:
20	local testing.  To test the error code of a subVI or function that does not have the error I/O structure, you can wire its error code and a source string to the local error code and error source inputs.  If error in status indicates no error and error code is not equal to 0, the local code and source are substituted for the error in values, and the status is set TRUE (ERROR).
20	user-defined codes.  The error handler has tables of error codes and descriptions for all LabVIEW I/O operations (file, GPIB, DAQ, etc.).  You can augment the tables with the user-defined arrays.  Codes from 5000 to 9999 are reserved for user assignments.
20	When port width is greater than the physical width of a digital port, the following restrictions apply. The port width must be an integral multiple of the physical port width, and the port numbers in the combined port must begin with the port named by port number and must increase consecutively. For example, if port number is 3 and port width is 24 (bits), the VI uses ports 3, 4, and 5.
20	)port number specifies the port this VI configures. A port number value of 0 signifies port 0, a port number of 1 signifies port 1, and so on. If you use a digital SCXI module, use the SCx!MDy!0 syntax, where x is the chassis ID and y is the module device number, to specify the port on a module.
20	source out.
20	"See Get Info for more information.H
20	devicePTH0
20	task IDPTH0
20	MessageL
20	Presently
20	Test Software Version
20	@Rj
20	j Rh
20	RPQW
20	PQR
20	jRPj
20	_[^]
20	Rjgh
20	D!!f
20	LVARLBVW
20	0test data in
20	QRhh;h
20	Abort?b
20	udfP!
20	GPRFd:\automated\lv51\lvsource\gencode.cGenRangeCheck
20	3QRP
20	CPCT
20	Cal Mark
20	Pwrtest.llb
20	oldP2
20	<LVSR
20	SND_CF&V.viPTH0
19	iVar1 = local_c;
19	bool bVar13;
19	undefined2 local_40;
19	undefined2 local_32;
19	undefined2 local_26;
19	*puVar4 = uVar3;
19	)%status is TRUE if an error occurred.
19	prompt is the message that appears below the list of files and directories in the file dialog.
19	default name is the initial file name that appears in the selection box of the file dialog.
19	start path is the path name to the initially displayed directory in a file dialog.  The default value is Not A Path, which is the path to the last directory shown in a file dialog.
19	refnum is the reference number of the open file.  The value is Not A Refnum if the file cannot be opened.
19	at the beginning of the file plus pos offset.
19	pos offset specifies in characters how far from the location specified by pos mode that the operation begins.  The default value is 0.
19	- sources: `Source_LV5_1_103f_cal.llb.strings.txt, Source_LV6_103f_cal.llb.strings.txt`
19	SQVW
19	Ff;u
19	\MLbl
19	XMLbl
19	#fffffff>
19	O$@
19	x?""
19	#@P
19	4icl4
19	$STRG
19	code4#
19	source4&
19	$=t
19	error out is a cluster that describes the error status after this VI executes. If an error occurred before this VI was called, error out is the same as error in. Otherwise, error out shows the error, if any, that occurred in this VI. Use the error handler VIs to look up the error code and to display the corresponding error message. Using error in and error out clusters is a convenient way to check errors and to specify execution order by wiring the error output from one subVI to the error input of the next.
19	INDO
19	GlobStat.vib
19	4N0
19	Lkg. Vlt. Target
19	Readings
19	Devicei0
19	DIO_R-W.VI\
19	Status_Glob.viW
19	@D$4
19	hBDPW
19	Y_^VW
19	QRhh<h
19	QRhh=h
19	Messagep0
19	!6@P
19	QRP
19	\BDPW
19	BDPW
19	Messagex0
19	ext4 P
19	MessageH
19	exthP
18	return 0xffff;
18	*puVar3 = uVar2;
18	if ((param_3 & 1) != 0) {
18	FUN_21185a40(local_30);
18	*param_23 = 0;
18	*param_24 = 0;
18	*param_25 = 0;
18	*param_26 = 0;
18	*param_27 = 0;
18	byte bVar15;
18	ushort uVar17;
18	FUN_21185030(*(undefined4 *)(iVar3 + 0xc),2);
18	FUN_21185030(*(undefined4 *)(iVar3 + 0xc),3);
18	FUN_21185070(*(undefined4 *)(iVar3 + 0xc),2);
18	uVar11 = FUN_2103d030(param_4);
18	FUN_21185130(*(undefined4 *)(iVar3 + 0xc),0x1c,(int)*(short *)(iVar3 + 0x425));
18	FUN_211850f0(*(undefined4 *)(iVar3 + 0xc),0xe,0);
18	FUN_211850f0(*(undefined4 *)(iVar3 + 0xc),0x1e,0);
18	FUN_21185130(*(undefined4 *)(iVar3 + 0xc),0xe,0);
18	FUN_21185130(*(undefined4 *)(iVar3 + 0xc),0x18,4);
18	FUN_211850f0(*(undefined4 *)(iVar3 + 0xc),0xc,0);
18	if ((sVar8 == 0xd) || (sVar8 == 0xe)) {
18	FUN_21185030(*(undefined4 *)(iVar3 + 0xc),0x19);
18	if (sVar8 != 0x12) {
18	FUN_21185130(*(undefined4 *)(iVar3 + 0xc),0xc,0);
18	if ((short)uVar17 != 0) {
18	if (sVar4 == 6) {
18	param_5 = 4;
18	ushort *local_c;
18	switch(sVar6) {
18	short *local_1c;
18	sVar3 = sVar3 + -1;
18	if ((*(short *)(iVar2 + 0x10) == 0x21) && (*(short *)(iVar2 + 0xaf8) == 0)) {
18	undefined *local_20;
18	ushort local_c;
18	return -0x2721;
18	iVar10 = local_c;
18	ushort *puVar12;
18	return -0x2a38;
18	float10 extraout_ST0_00;
18	*param_4 = uVar3;
18	puVar9 = (undefined4 *)((int)puVar9 + 2);
18	if (*(short *)(local_20 + 0x42) == 0) {
18	if (param_11 == 0) {
18	*(byte *)(iVar2 + 0xae0) = bVar16;
18	FUN_211850f0(*(undefined4 *)(iVar2 + 0xc),2,(int)(char)bVar16);
18	local_54[4] = 0xffff;
18	sVar4 = (short)param_9;
18	if ((short)uVar9 != 0) {
18	FUN_21185130(*(undefined4 *)(param_2 + 0xc),0xc,0);
18	return local_34 & 0xffff;
18	case 0x46:
18	short local_22;
18	uVar7 = extraout_var_01;
18	undefined1 *puVar6;
18	if ((short)param_11 != 0) goto LAB_2106cf49;
18	param_8._0_2_ = (short)pcVar10;
18	iVar7 = local_34;
18	if ((short)param_11 == 0) {
18	if ((short)param_11 == 1) {
18	param_11._0_2_ = 0;
18	else if ((short)param_11 != 0) goto LAB_2106cf49;
18	if ((short)param_11 < 0) goto LAB_2106cbb2;
18	if (((short)param_11 == 1) && ((short)local_10 != 0)) goto LAB_2106cbb9;
18	if ((short)iVar7 != (short)param_8) goto LAB_2106cf42;
18	local_24 = local_24 - 1;
18	char local_8;
18	local_8 = '\0';
18	uVar7 = local_c & 0xffff;
18	if ((short)local_28 == -1) {
18	if (*param_3 == 1) {
18	if (0 < (short)local_24) {
18	if (local_8 != '\0') {
18	*piVar12 = iVar17;
18	iVar17 = iVar17 + 0x51;
18	local_20 = (int *******)((int)local_18 * 2);
18	local_10 = local_1c + *(short *)(iVar17 + 0x49) * 2;
18	iVar9 = iVar9 + sVar11 * 2;
18	if (local_6 != false) {
18	puVar5 = local_38;
18	if (local_70 == 6) {
18	int *piVar14;
18	uint local_b8;
18	undefined4 extraout_EDX;
18	local_28 = 4;
18	if (param_6 == (int *)0x0) {
18	if (iVar5 < 0) {
18	sVar5 = FUN_21091a60(psVar2,0x3ef,0,100,param_2,0,0x3ff00000,&local_3c);
18	sVar5 = FUN_21091a60(psVar2,0x3ef,0,100,uVar7,0,0x3ff00000,&local_3c);
18	sVar5 = FUN_210908d0(psVar2,0x7d1,0,0,0,0,param_2,local_e);
18	sVar5 = FUN_210908d0(psVar2,0x7d7,0,0,(undefined4)local_34,local_34._4_4_,uVar7,
18	sVar5 = FUN_210908d0(psVar2,0x7d3,0,0,(undefined4)local_34,local_34._4_4_,uVar7,local_6);
18	uStack_40 = 0;
18	if (iVar3 == 2) {
18	if (param_2 == 0x4e84) {
18	if (param_2 == 0x51a4) {
18	_memDelete(param_2);
18	if ((lVar4 != 0) ||
18	short local_50;
18	uVar13 = 1;
18	uVar8 = extraout_var_03;
18	*piVar9 = -0x2899;
18	goto LAB_210b5d44;
18	iVar5 = FUN_210b55f0(iVar4,5,*piVar9,piVar9[1],piVar9[2]);
18	goto LAB_210b6815;
18	undefined4 local_c8;
18	undefined4 local_b4;
18	undefined4 local_b0;
18	piVar3 = puVar7 + 2;
18	} while (*piVar3 != 0);
18	local_10 = (int *)0x0;
18	*param_2 = 0x67;
18	if (param_1 == 0x7bd4) {
18	if (param_1 == 0x6e8c) {
18	if (param_1 == 0x701c) {
18	if (param_1 == 0x7b70) {
18	*param_3 = 0x13;
18	*param_3 = 0xd;
18	if (param_1 == 0x7c38) {
18	*param_3 = 0xe;
18	*param_3 = 0x11;
18	*param_3 = 0x17;
18	*param_3 = 0x1a;
18	*param_3 = 0x1e;
18	case 0x73:
18	short *psVar12;
18	if (uVar13 != 0) {
18	if (param_4 < 0x7c39) {
18	(**(code **)(*piVar2 + 0x20))
18	if ((iVar3 != 0) && (iVar3 != 100)) {
18	goto switchD_210eb28f_caseD_c620;
18	*param_4 = 0xd;
18	*param_4 = 0xe;
18	*param_4 = 0xf;
18	*param_4 = 0x10;
18	*param_2 = 0x1a2;
18	double dVar20;
18	undefined4 uStack_30;
18	undefined4 *puVar17;
18	double *local_1c;
18	local_34 = param_3;
18	_memDelete(param_8);
18	local_14 = local_1c;
18	local_28 = (double *)((int)local_28 + -1);
18	} while (local_28 != (double *)0x0);
18	local_34 = local_34 + 1;
18	local_5c = local_5c - local_88;
18	iVar6 = FUN_210f3920();
18	iVar6 = FUN_210f4f70();
18	((tMemBlockReferenceBase *)((int)extraout_ECX + 0x1d1),(long *)0x0);
18	((tMemBlockReferenceBase *)((int)extraout_ECX + 0x1cd),(long *)0x0);
18	fVar21 = (float10)FUN_210f4db0();
18	pdVar19 = pdVar19 + 1;
18	param_2 = (tBuffer *)((int)param_2 + 1);
18	uVar13 = (**(code **)(*extraout_ECX + 0x6a8))();
18	return uVar13;
18	pdVar12 = local_68;
18	} while (param_2 != (tBuffer *)0x0);
18	ptVar15 = *(tBuffer **)((int)extraout_ECX + 0x1d9);
18	if (ptVar15 != (tBuffer *)0x0) {
18	NIBS100::tBuffer::~tBuffer(ptVar15);
18	_memDelete(ptVar15);
18	(**(code **)(**(int **)((int)extraout_ECX + 0x163) + 0x34))();
18	ptVar20 = (tMemBlockReferenceBase *)0x41;
18	ptVar20 = (tMemBlockReferenceBase *)0x44;
18	ptVar20 = (tMemBlockReferenceBase *)0x3e;
18	local_38 = puVar25;
18	this = *(tMemBlockReferenceBase **)((int)extraout_ECX + 0x14f);
18	case 0x4a:
18	if (extraout_AX != 0) {
18	undefined1 local_14;
18	local_10 = 8;
18	short sVar16;
18	short local_78;
18	local_c = FUN_21171bda(param_1,&local_24);
18	for (local_30 = 0; local_30 < 4; local_30 = local_30 + 1) {
18	for (local_38 = 0; local_38 < 4; local_38 = local_38 + 1) {
18	*(char *)((int)&local_10 + iVar3) =
18	(char)((int)(uint)(ushort)local_1c[0x3cc] >>
18	((byte)((int)local_78 << 3) & 0x1f));
18	((byte)((int)local_7c << 3) & 0x1f));
18	((byte)((int)local_80 << 3) & 0x1f));
18	undefined1 local_50 [4];
18	local_44 = FUN_211362e0(0x2040,2);
18	local_20 = -0x292c;
18	*(uint *)(local_4c + 0x3d6) =
18	if ((*(int *)(local_30 + 5) == 0x16) && (local_1c[0] == 0x23)) {
18	if ((local_4c != (undefined2 *)0x0) &&
18	(*(int *)(local_4c + 5) == 0x16)) {
18	FUN_2117183f(local_54);
18	if (local_28[0] == 0x23) {
18	local_18 = param_3[local_68] + -1;
18	local_78 = (short *)((int)local_9c + local_18 * 0xa8d + 0x16);
18	uVar5 = ((int)*(short *)(param_5 + local_68 * 2) & 0x7fffU) +
18	(char)(*(uint *)(local_78 + 0x3d6) >>
18	sVar2 = FUN_21146493(param_1,*local_78,6,4,local_b8,0,local_78[1],
18	if (local_84 == 0) {
18	return -0x286e;
18	local_28 = '\x01';
18	local_60 = (undefined2 *)(local_70 + 0x16 + (local_78[0] + -1) * 0xa8d);
18	local_24 = FUN_21146493(param_1,*local_50,0x37,4,local_30,0,local_50[1],
18	local_24 = FUN_21156d95(CONCAT22((short)((uint)local_64 >> 0x10),param_1),
18	FUN_211431c0(*(undefined4 *)(param_2 + 0x6e + local_18 * 6),
18	*(undefined2 *)(param_2 + 0x72 + local_18 * 6)),iVar3);
18	uVar2 = FUN_2116d665(local_10);
18	*(undefined2 *)(local_1c + 0xa89) = uVar2;
18	if (iVar3 == *(ushort *)(local_1c + 0xa89) - 1) {
18	uVar2 = (undefined2)((uint)puStack_13910 >> 0x10);
18	local_8 = (double *)0x1;
18	local_14 = puStack_13910;
18	local_18._0_2_ = param_5;
18	local_14 = (undefined2 *)((int)puStack_13910 + sStack_138e8 * 0x10 + 0x957);
18	local_18 = (short *)0x10;
18	local_1c = (undefined2 *)(sStack_138e8 * 2 + 8);
18	puStack_20 = (undefined8 *)CONCAT22(sStack_138e8 >> 0xf,*puStack_13910);
18	puStack_24 = (undefined2 *)CONCAT22((short)((uint)local_1c >> 0x10),param_1);
18	local_8 = (double *)uStack_13904;
18	local_10 = (double)CONCAT44(uStack_13908,0x40790000);
18	local_18 = (short *)local_44;
18	local_1c = (undefined2 *)auStack_18778;
18	puStack_20 = (undefined8 *)auStack_1877c;
18	puStack_24 = auStack_18850;
18	sVar1 = FUN_21007510();
18	local_8 = adStack_138d8;
18	local_10 = (double)CONCAT44(auStack_18778,local_44);
18	dStack_13924 = 0.0;
18	for (sStack_13914 = 0; (uint)(int)sStack_13914 < local_44;
18	sStack_13914 = sStack_13914 + 1) {
18	dStack_13924 = dStack_13924 / (double)local_44;
18	FUN_21005ab0();
18	undefined2 extraout_var_19;
18	undefined2 extraout_var_20;
18	undefined2 extraout_var_21;
18	undefined2 extraout_var_22;
18	undefined2 extraout_var_23;
18	undefined2 extraout_var_24;
18	local_90[2]);
18	puVar1 = (undefined4 *)((int)local_90 + local_988 * 0x10 + 0x957);
18	puVar1 = (undefined4 *)((int)local_90 + local_988 * 0x10 + 0x95f);
18	iVar6 = local_988 * 2 + 8;
18	local_24 = FUN_21129b00(CONCAT22((short)((uint)iVar6 >> 0x10),param_1),
18	CONCAT22(local_988 >> 0xf,*local_90),iVar6,0x10,
18	(int)local_90 + local_988 * 0x10 + 0x957,0,local_90[1],
18	local_84 = local_84 + 1;
18	(local_24 = FUN_2115966a(), local_24 == 0)) &&
18	*(uint *)(param_1 + 0x79a) =
18	(*(char *)(local_24 + 9) == '\0')) {
18	*(int *)param_9 = param_5;
18	*(int *)((int)param_9 + 4) = param_6;
18	*(byte *)((int)local_24 + (local_c & 0xff) + (local_1c & 0xff) * 0x10 + 0x957) |
18	*(byte *)((int)local_24 + (local_c & 0xff) + (local_1c & 0xff) * 0x10 + 0x957) &
18	if (*(uint *)(param_1 + 10) < 0x10000) {
18	else if (iVar4 == 1000) {
18	else if (iVar4 == 500) {
18	cVar2 = FUN_211525de(*(undefined4 *)(param_2 + 10));
18	if (((cVar2 != '\0') && (*(int *)(param_2 + 10) != 0x2d)) && (*(int *)(param_2 + 10) != 0x2f)) {
18	iVar5 = *(int *)(*(int *)(param_2 + 0x94e) + 4);
18	local_c = local_c + (short)iVar5;
18	uStack_94 = 0x40240000;
18	local_98 = 0x9999999a;
18	uStack_94 = 0x3fb99999;
18	for (; 0 < local_2c; local_2c = local_2c + -1) {
18	CONCAT31((int3)(char)((ushort)local_38 >> 8),
18	(double)fVar10;
18	iVar7 = (int)param_3;
18	else if (iVar7 == 3) {
18	for (local_13c = 0; local_13c < 2; local_13c = local_13c + 1) {
18	*(undefined4 *)(iVar7 + 8) = 0;
18	*(undefined4 *)(iVar7 + 0xc) = 0x3ff00000;
18	CONCAT31((int3)((uint)iVar7 >> 8),(undefined1)local_8),
18	local_2c * 2 + 9);
18	(double)local_20;
18	local_2c = 0x40;
18	(*(int *)(*(int *)(param_2 + 0x94e) + local_8c * 4) + 8 + local_28 * 0x10
18	local_24 = (float)**(double **)(*(int *)(param_2 + 0x94e) + local_8c * 4);
18	local_20 = (float)*(double *)(*(int *)(*(int *)(param_2 + 0x94e) + local_8c * 4) + 8);
18	sVar4 = sVar5;
18	if (pcVar7 == (char *)0x0) {
18	FUN_21185a40(local_38);
18	strcat(pcVar3,&DAT_2120b9bc);
18	sVar4 < 0)) ||
18	FUN_21185a40(local_20);
18	FUN_21185b20(0);
18	local_38 = 0x2b2f;
18	local_30 = (-(uint)(local_10 != 1) & 0xffffef7f) + 0x3b92;
18	*param_10 = fStack_20;
18	if (*(int *)(iVar3 + 0x124) != 0) {
18	param_1 = local_10;
18	goto LAB_2119e9d6;
18	} while (param_5 < *(uint *)(param_4 + 0x124));
18	uVar15 = ftol(2);
18	iVar5 = FUN_21183d20(local_b8,uVar15);
18	psVar7 = (short *)0x2a30;
18	psVar7 = (short *)0xffffd5d0;
18	return -0x2720;
18	piVar17 = local_14;
18	param_18 = (uint *)((int)param_18 + 1);
18	while (sVar4 == 1) {
18	if (piVar17 == (int *)0x0) {
18	uVar19 = 0;
18	uVar19 = uVar19 + 1;
18	if (*piVar8 == *(int *)(iVar13 + 0x120)) break;
18	} while (param_11 < param_3);
18	setI32Attribute(uVar9,*(undefined4 *)(iVar13 + 0x98),0x1f,param_11);
18	setI32Attribute(uVar9,*(undefined4 *)(iVar13 + 0x98),0x1f,
18	*(undefined4 *)(iVar13 + 0x120));
18	setBufferAttrs(uVar9,*(undefined4 *)(iVar13 + 0x98),**(undefined4 **)(param_11 + 6),
18	*(int *)(param_11 + 0x1c),
18	*(int *)(param_11 + 0x1c) * *(int *)(param_11 + 10));
18	sVar4 = FUN_211bee70(param_1,uVar9);
18	} while ((short)uVar9 != 0);
18	sVar4 = FUN_211be880(param_14,&local_3c);
18	iVar13 = FUN_21183e00(param_12);
18	local_14 = *(undefined4 *)(*(int *)(iVar3 + 6) + param_14[3] * 4);
18	param_14[1] = 0;
18	param_14[2] = 0;
18	param_14[4] = 0;
18	param_14[5] = 0;
18	iVar9 = *param_10;
18	if ((char)local_2c != '\0') {
18	if (sVar16 == 0) {
18	local_18[(short)iVar19] = 1;
18	iVar9 = (int)sVar16;
18	(*(short *)(*(int *)(puVar12 + iVar19 * 0x17 + 3) + iVar20 * 2) ==
18	*(short *)(*(int *)(puVar12 + iVar19 * 0x17 + 3) + 2 + iVar20 * 2))) &&
18	if (0 < (short)puVar14[2]) {
18	uVar5 = local_14 + 1;
18	uVar15 = local_c;
18	uVar15 = *(uint *)(puVar14 + 5);
18	local_8._2_2_ = (undefined2)(local_8 >> 0x10);
18	local_20) +
18	local_c = FUN_2116b142(psVar18,uVar13,local_8,1,
18	if (((short)local_40 != 0) || ((short)local_50 != 0)) {
18	} while ((short)local_1c < (short)local_2c);
18	local_8 = CONCAT22((short)((uint)*(int *)(puVar14 + 0xf) >> 0x10),
18	0x15) +
18	&local_40);
18	(*(int *)(*(int *)(puVar14 + 0xf) +
18	uVar15 = FUN_2115846a();
18	local_8 = CONCAT22(local_8._2_2_,
18	+ local_20) +
18	if ((char)local_4c == '\0') {
18	if (0 < *(int *)(param_4 + 1)) {
18	*(undefined2 *)(*(int *)(param_4 + 6) + param_7 * 2));
18	sVar10 = strlen(s_WalrusChWzHack_2120c9e8);
18	goto switchD_211d2f9b_caseD_5;
18	uStack_5e = 0;
18	goto joined_r0x211d27ec;
18	puVar26 = (undefined2 *)(*(int *)(*(int *)(local_10 + 0x3f) + 2) + (int)local_24 * 0x2e);
18	sVar4 = FUN_2116ab53(local_3c,local_44,
18	*param_12 = (double)(float)local_4c;
18	puVar25 = param_11;
18	if (bVar27) {
18	if (*(short *)(*(int *)(puVar26 + 0x13) + (int)local_c * 4) != 0x33) {
18	case (uint *)0x0:
18	case (uint *)0x1:
18	sVar5 = (short)local_54;
18	case (uint *)0x2:
18	local_c = (uint *)(uint)uVar8;
18	uVar13 = local_2c;
18	case (uint *)0x3:
18	case (uint *)0xb:
18	case (uint *)0xc:
18	uVar8 = (ushort)param_9;
18	sVar4 = FUN_21146c41(local_3c);
18	local_c = (uint *)0x0;
18	sVar4 = FUN_211492d2(local_3c,local_44,&local_18,(int)&local_28 + 2,
18	(int)&local_28 + 2);
18	local_c = local_c + 6;
18	if (*local_10 == 3) {
18	local_3c = CONCAT22(uVar21,*puVar26);
18	sVar4 = FUN_211492d2(local_3c,local_44,&local_18,(int)&local_28 + 2,(int)&local_28 + 2);
18	if (((local_18 != (uint *)0x1) && (cVar3 = FUN_21152619(local_18), cVar3 == '\0')) &&
18	local_3c = CONCAT22(uVar20,*puVar26);
18	uVar8 = (ushort)param_7;
18	((int)local_8 +
18	if (*(short *)(*(int *)(puVar26 + 0x13) + (int)local_c * 4) == 0x31) {
18	local_1c[uVar13 / (uint)local_18] = (int)(short)(ushort)param_9;
18	cVar3 = FUN_21152619(local_8);
18	puVar22 = local_18;
18	((int)local_18 +
18	if (*(short *)(*(int *)(puVar26 + 0x13) + (int)local_c * 4) != 0x31) goto LAB_211d0f61;
18	iVar4 = (uVar5 * 0xf + -0xf + uVar6) * 0x1f0;
18	if (param_2 != 0xc92c) {
18	if (param_6 < 10) {
18	goto switchD_211d5ea7_caseD_c83c;
18	Doub Click Num
18	lVar1 = tPIMMblockReferenceBase::allocateMemory((tPIMMblockReferenceBase *)&param_3,0xc,1,8);
18	(pvVar2 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&param_3),
18	(**(code **)(**(int **)(param_1 + 0x138) + 0x10))(&param_5);
18	StdBoolDisp
18	UserItem
18	Keyboard Mode
18	#Instr Read Model Code (GPIB-VXI).vi
18	don't display
18	pattern is the match pattern specification to display only certain types of files or directories.  See the description of the File Dialog function for more information.
18	file size is the size of the file in bytes; it is also the location of the end of file.
18	Miles S. Mondt$
18	Open File
18	character string is the data the VI writes to the file.
18	*.cal
18	input XON/XOFF @
18	output XON/XOFF @
18	4<0
18	TLIvi
18	hDLDR
18	|LVIN
18	#bffffff>
18	LVINLBVWH
18	,icl4
18	@FTAB
18	x?"bfffff
18	x?"""
18	4HIST
18	$FPHP
18	H4N3
18	pwww
18	Oldest compatible LabVIEW.S
18	+#+#+##++##+###+
18	++#++#+#+#+++#++
18	+#+#+##+++#++#++
18	+++++#+#+##++#++
18	#+++V
18	++++++++++++++++
18	++#+
18	+#+#+#+##++#+#++
18	++#++#+#+#+###++
18	+#+#+#+#+#+###++
18	+++++#+##++#+#++
18	p8F8
18	4Z<j8b
18	coder4
18	wwwww
18	DuDu
18	Communications ErrorS
18	ABORT?.viV
18	4W0
18	______________________________________
18	<PTH0
18	0Leakage Data
18	5.5
18	Path to Cap Box DataD
18	Path to Ind Box Dataa
18	F(Pj
18	SPQRW
18	!_^3
18	!u*f
18	HRQ
18	RPQj
18	MPQj
18	jPj
18	RPVQ
18	N*WQR
18	MPQR
18	PQWR
18	NWh
18	QWRP
18	,SVW
18	R _f3
18	QPh9
18	E,Pf
18	M@;
18	p !P
18	RQPW
18	>> endobj
18	UUT Comm.viH
18	DIO_R-W.VIH
18	HCheck if measured value is within tolerance
18	Test Voltage Array
18	P-`/
18	66666666666666666666666666666666666666666666666
18	66666666666666666666666666666666
18	66666666666666666666666666666666666666666
18	QRhh?h
18	DBDPW
18	s|8>?
18	port numberp0
18	old8 P
18	T_Setup.viRE
18	$hhh
18	u#QR
18	2PTH0*
18	Test NameH
17	pcVar1 = (code *)swi(0x2f);
17	undefined2 unaff_SS;
17	undefined2 *in_BX;
17	undefined2 local_30;
17	iVar2 = 0x1010;
17	),
17	error in (no error)M
17	error in (no error)<
17	General Error HandlerMD
17	_^Y]
17	MLbl
17	###########
17	monnie%Displayed scrollbar in source string.
17	HCPTM
17	pDFDS
17	ADir
17	0FTAB
17	G8~>
17	DDFDS
17	0HIST
17	+*****
17	xFPHP
17	33333333333333
17	4O0
17	44P3
17	p|<>
17	T
17	tLIfp
17	Oldest compatible LabVIEW.V
17	VZjn
17	flow control etc.@
17	LZTjPb
17	0333333
17	4^0
17	GlobStat.viO
17	dMxa
17	jX~l
17	# Smpl*
17	Message@
17	Scrollbar Visible
17	Symbols Visible@
17	Top Row
17	QRSP
17	This VI loads the addressing information about the instrument into the Open VXI Instrument VI and returns the instrument ID.  You can reset the instrument by setting the front panel reset control.  You must run this VI before using any of the instrument driver VIs for this instrument.
17	Output: Data written to or read from port.
17	<F$4
17	Fail = False
17	$9$4
17	Pass/Fail4
17	exdP2
17	(QRP
17	?!|x
17	dCPST
17	{0t$QR
17	ext8 P
16	undefined2 unaff_ES;
16	undefined2 unaff_SI;
16	bVar5 = 0;
16	FUN_1000_f1fe();
16	if (RVar1 == 0) {
16	undefined1 local_34 [32];
16	ushort *local_8;
16	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),2,0);
16	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),8,0);
16	param_1 + 0x273);
16	iVar1 = FUN_21184de0();
16	return 0xffffd7fb;
16	local_20 = 7;
16	local_20 = 8;
16	local_10 = param_4;
16	lpOutBuffer = &local_28;
16	nOutBufferSize = 0x24;
16	lpInBuffer = &local_28;
16	nInBufferSize = 0x24;
16	local_1c = param_2;
16	*(undefined4 *)(this + 4) = *(undefined4 *)(param_1 + 4);
16	*(undefined4 *)(this + 8) = *(undefined4 *)(param_1 + 8);
16	*(undefined4 *)(this + 0xc) = *(undefined4 *)(param_1 + 0xc);
16	*(undefined4 *)(this + 0x10) = *(undefined4 *)(param_1 + 0x10);
16	return in_ECX;
16	undefined4 param_25,undefined4 param_26,undefined4 param_27,undefined4 param_28,
16	undefined4 param_25,undefined4 param_26,undefined4 param_27,undefined4 param_28)
16	(piVar1,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
16	piVar4 = param_2;
16	undefined2 in_stack_0000002a;
16	(daqDevice *this,short param_1,ushort param_2,ushort param_3)
16	short *) */
16	*,unsigned long *) */
16	param_18);
16	param_9,param_10);
16	sVar1 = *param_2;
16	HMODULE hModule;
16	if (sVar4 != 1) {
16	int in_stack_00000024;
16	*param_5 = *(undefined2 *)(local_d4.Buffer + 8);
16	ULONG_PTR param_5,ULONG_PTR param_6,uchar *param_7,ULONG_PTR param_8,
16	NdrPointerBufferSize(&local_d4,param_10,"\x12");
16	local_d4.MaxCount = UVar1;
16	*(ULONG_PTR *)((int)local_d4.Buffer + 4) = param_9;
16	NdrPointerMarshall(&local_d4,param_10,"\x12");
16	NdrConvert(&local_d4,"N\x0fN\bN\x06N\x06M\x01z");
16	NdrPointerBufferSize(&local_d4,param_9,"\x12");
16	NdrPointerMarshall(&local_d4,param_9,"\x12");
16	local_d4.MaxCount = param_12;
16	undefined2 *param_12)
16	*(undefined2 *)(local_d4.Buffer + 8) = param_5;
16	*(undefined4 *)(local_d4.Buffer + 0x10) = param_8;
16	*param_10 = *(undefined2 *)local_d4.Buffer;
16	*(undefined4 *)(local_d4.Buffer + 0x14) = param_7;
16	local_d4.BufferLength = 0x14;
16	*param_5 = *(undefined2 *)(local_d4.Buffer + 4);
16	*(undefined4 *)(local_d4.Buffer + 4) = param_4;
16	*param_8 = *(undefined4 *)local_d4.Buffer;
16	*param_8 = *(ULONG_PTR *)((int)local_d4.Buffer + 4);
16	local_d4.MaxCount = (int)param_3;
16	local_d4.MaxCount = param_3;
16	local_d4.Buffer = (uchar *)((ushort *)((uint)(local_d4.Buffer + 1) & 0xfffffffe) + 1);
16	&local_24);
16	undefined4 param_14,undefined4 param_15,undefined4 param_16,undefined4 param_17,
16	int *local_18;
16	local_10 = 0xffffd734;
16	iVar4 = local_40 * iVar2;
16	else if (sVar3 == 2) {
16	param_1 & 0xffff;
16	local_1c = &stack0xffffffc4;
16	return local_30;
16	uVar4 = CONCAT22(extraout_var,*(undefined2 *)(in_ECX + 0x2c));
16	if ((short)local_2c[0] != 0) {
16	if ((short)local_24 == 0) {
16	puVar8 = local_28;
16	puVar6 = &local_2c;
16	iVar3 = sVar1 + 1;
16	undefined1 *puVar4;
16	puVar7 = param_7;
16	(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9,param_10);
16	sVar1 = (short)uVar2;
16	UINT UVar2;
16	return 0xffffff9c;
16	BOOL BVar1;
16	DWORD DVar2;
16	puVar4[4] = 0;
16	uVar3 = (uint)param_1;
16	return 5;
16	if (param_2 == 0x52ee) {
16	if (param_2 == 0x52f3) {
16	if (param_2 == 0x52f8) {
16	if (param_2 == 0x5302) {
16	if (param_2 == 0x532a) {
16	if ((short)uVar16 < 0) {
16	sVar5 = 1;
16	if (sVar5 == 10) {
16	iVar18 = CONCAT31(uVar14,*(char *)(local_8 + 0x348));
16	if ((*(char *)(local_8 + 0x348) != '\0') ||
16	if (*(char *)(local_8 + 0xa86) != '\0') {
16	if ((*(short *)(local_8 + 0x10) == 0x21) && (*(short *)(local_8 + 0xaf8) == 0)) {
16	if ((*(char *)(param_1 + 0x348) == '\0') && (*(char *)(param_1 + 0x399) == '\0')) {
16	if (*(char *)(param_1 + 0x344) == '\x01') {
16	FUN_21183d20(local_28,1,3);
16	iVar9 = FUN_21183e00(local_28);
16	FUN_211850f0(*puVar1,1,0);
16	if ((sVar2 == 1) || (sVar2 == 0xf)) {
16	if (sVar1 != 4) {
16	uVar4 = FUN_2103d030(param_2);
16	double *pdVar13;
16	local_14 = 0xffffd8e4;
16	sVar1 = (short)iVar4;
16	uVar10 = extraout_var;
16	if (sVar4 == 8) {
16	if ((int)uVar6 < 0) {
16	uVar6 = extraout_ECX;
16	uVar6 = FUN_2103d030(iVar5);
16	FUN_211850f0();
16	if (param_4 == 5) {
16	if ((short)param_2 == -1) {
16	uVar3 = 0xd8ed;
16	param_2 = 5;
16	param_2 = 4;
16	return 0xd759;
16	if (sVar3 == 10) {
16	sVar7 = 2;
16	uVar4 = 4;
16	local_44 = 0x80;
16	local_42 = 0x80;
16	local_3c = param_3;
16	DWORD DVar7;
16	LPOVERLAPPED p_Var9;
16	pDVar8 = (LPDWORD)&param_3;
16	puVar6 = &local_54;
16	DVar7 = 0x50;
16	puVar4 = &local_54;
16	DVar5 = 0x50;
16	DVar3 = 0xabcd201c;
16	pvVar2 = (HANDLE)FUN_21002400();
16	DeviceIoControl(pvVar2,DVar3,puVar4,DVar5,puVar6,DVar7,pDVar8,p_Var9);
16	return local_3a;
16	short local_3a;
16	uint extraout_EDX;
16	*param_2 = -1;
16	case 0x54:
16	iVar5 = (int)(short)param_1;
16	if ((short)iVar2 < 0) {
16	puVar5 = param_3;
16	if (*psVar4 != 0) {
16	param_1 = param_5;
16	param_1 = 8;
16	iVar5 = 8;
16	} while ((short)iVar3 < 4);
16	sVar3 = FUN_2104a3a0(param_1);
16	local_14);
16	if ((sVar1 == 0) &&
16	*param_11 = sVar1;
16	if ((uVar2 & 1) != 0) {
16	sVar3 = FUN_21045170(uVar1,iVar2,param_1,*puVar6);
16	iVar7 = param_4;
16	uVar5 = extraout_var_01;
16	*pbVar1 = bVar2 | 0x80;
16	FUN_211850f0(param_1,0x1c,(int)(char)(bVar2 | 0x80));
16	bVar4 = *pbVar2;
16	bVar3 = *pbVar2;
16	bVar3 = 7;
16	switch(*param_1) {
16	puVar1 = param_6;
16	return 0xd827;
16	} while (local_34 != 0);
16	char cVar8;
16	local_38 = local_38 + 1;
16	*param_12 = param_3;
16	uVar9 = extraout_var_00;
16	*param_2 = puVar1;
16	FILE *_File;
16	if (_File == (FILE *)0x0) {
16	if (cVar1 != -1) {
16	iVar1 = Ordinal_17(&local_8);
16	DWORD DVar13;
16	FUN_21136340(uVar11);
16	return uVar10 & 0xffff0000;
16	else if ((sVar3 == 0xd) || (sVar3 == 0xe)) {
16	else if (uVar7 == 1) {
16	uVar9 = 0xffffffff;
16	uVar9 = param_1;
16	DWORD DVar15;
16	local_c = *(int *)(&DAT_2120f937 + iVar1);
16	*(undefined2 *)(param_4 + 6) = 0;
16	iVar11 = local_8;
16	p_Var19 = (LPOVERLAPPED)0x0;
16	sVar6 = (short)puVar3[6];
16	local_7c = 1;
16	short local_46;
16	nOutBufferSize,lpBytesReturned,lpOverlapped);
16	uVar5 = 0x80;
16	*(undefined1 *)(iVar4 + 0x1b8) = 1;
16	if (*param_4 != 0) {
16	uint *local_58;
16	local_40 = local_8;
16	if (param_1._3_1_ == '\0') {
16	if (uVar10 < param_4) {
16	if (*(short *)((int)local_c + 0x13a) != 2) {
16	return 0xd737;
16	puVar7 = (undefined4 *)((int)puVar7 + 2);
16	puVar13 = (undefined4 *)((int)puVar13 + 2);
16	else if (sVar2 == 6) {
16	if (sVar7 == 1) {
16	undefined4 param_5,undefined4 param_6,undefined2 param_7)
16	iVar2 = param_5;
16	sVar3 = sVar4;
16	switch(*(undefined2 *)(&DAT_2120f8de + iVar1)) {
16	return 0x2a5e;
16	*psVar1 = 0;
16	local_1c = 0x2a5e;
16	local_c = local_14;
16	local_1c = 0xffffd5a2;
16	short local_2e;
16	short *local_18;
16	if (sVar11 == 2) goto switchD_210508a6_caseD_21050e7f;
16	if ((short)local_c < 0) {
16	if (1 < sVar9) {
16	if (param_3 != 0) goto switchD_210508a6_caseD_21050e7f;
16	sVar6 = (short)local_10;
16	bVar3 = (byte)param_3;
16	lpBytesReturned = (LPDWORD)&param_4;
16	local_40 = param_3;
16	if (7 < sVar3) {
16	uVar5 = 2;
16	return (int)(short)local_c;
16	iVar1 = (short)param_1 * 0x7a;
16	if ((param_3 < 0) || (3 < param_3)) {
16	switch(uVar7) {
16	if (sVar13 != 0) {
16	FUN_21185130(*(undefined4 *)(local_8 + 0xc),0xe,0);
16	if (sVar12 == 1) {
16	if (sVar12 != 2) {
16	return -0x2738;
16	if (*(short *)(param_1 + 0xad) == 4) {
16	if ((bVar1 & 1) != 0) {
16	*(ushort *)(param_1 + 0xa3) =
16	undefined2 local_50;
16	if (sVar8 == 1) {
16	FUN_21185130(*(undefined4 *)(iVar4 + 0xc),2,(int)(short)uVar12);
16	ushort local_14;
16	if ((ushort)param_3 == 1) {
16	uVar2 = uVar2 | 2;
16	local_20 = local_18;
16	if (((param_3 != 0xc364) && (param_3 != 0xc35a)) && (param_3 != 50000)) {
16	else if (sVar2 == 2) {
16	uVar6 = ftol(2);
16	undefined1 local_48 [8];
16	return -0x2727;
16	iVar9 = iVar10;
16	local_2c = local_34;
16	local_24 = local_34;
16	local_28 = local_38;
16	iVar5 = param_4;
16	if (uVar1 == 1) {
16	*param_6 = local_10;
16	undefined1 local_6c [32];
16	undefined2 local_4c [4];
16	undefined1 local_30 [6];
16	int local_22;
16	,&local_8);
16	uVar2 = *param_3;
16	iVar1 = *(int *)(&DAT_2120f937 + iVar2 * 0x7a);
16	return CONCAT22(uVar5,0xd8ed);
16	undefined *puVar1;
16	return CONCAT22(uVar3,0xd8ed);
16	iVar7 = iVar7 + 2;
16	if (*(int *)(param_1 + 4) != 0) {
16	param_1 = 3;
16	case 0x4025:
16	uVar12 = 3;
16	case 0x4026:
16	case 0x4029:
16	case 0x402a:
16	*(undefined2 *)(&DAT_21213588 + sVar7 * 2) = 0;
16	case 0x402c:
16	if (param_2[3] != 0) {
16	if (local_c == 3) {
16	puVar2 = puVar2 + 2;
16	FUN_2105bd60(0xef,2,param_2);
16	undefined1 *puVar3;
16	iVar1 = 5;
16	uVar5 = param_4;
16	param_1[7] = 0;
16	iVar1 = param_1 * 0x7a;
16	uVar6 = local_c;
16	puVar5 = (undefined4 *)((int)puVar5 + 1);
16	if (-1 < sVar8) {
16	return local_14 & 0xffff;
16	iVar6 = local_8;
16	if (param_1 == 0.0) {
16	*param_5 = uVar3;
16	if ((0 < param_1) && (param_1 < 0x41)) {
16	return -0x2761;
16	if (param_11 != 0) {
16	*param_2 = 5;
16	sVar9 = (short)param_5;
16	if (sVar6 != 1) {
16	if (*(short *)(param_2 + 0x10) != param_1) {
16	*(short *)(param_2 + 0x10) = param_1;
16	if (*(short *)(param_3 + 0x10) != param_1) {
16	*(short *)(param_3 + 0x10) = param_1;
16	*(undefined2 *)(param_3 + 4) = 0x17;
16	uVar7 = *(undefined4 *)(param_2 + 0x26a);
16	*(undefined4 *)(param_2 + 0x26a) = 0;
16	*(undefined2 *)(param_2 + 0x264) = 0;
16	if (param_8 == 1) {
16	if ((short)param_10 == 0) {
16	if ((short)local_20 != 0) {
16	uVar6 = *(undefined4 *)(param_2 + 0xc);
16	pbVar1 = (byte *)(iVar3 + (uint)uVar5 * 2);
16	short *local_14;
16	if ((short)iVar2 == 0) {
16	puVar2 = param_8;
16	bVar3 = FUN_21185030(param_8[3],0);
16	return -0x2a35;
16	puVar7 = (undefined2 *)(uint)bVar4;
16	iVar3 = *param_2;
16	goto switchD_2106447a_default;
16	case 0x43:
16	return local_1e;
16	iVar9 = 2;
16	uVar1 = *puVar5;
16	if (((short)uVar5 == 0) &&
16	local_10 = uVar6;
16	uVar4 = extraout_var_00;
16	puVar1[1] = param_2;
16	uVar1 = param_4;
16	iVar10 = 0x38;
16	*puVar1 = *puVar1 | uVar14;
16	return -0x2974;
16	_param_1 = 0x1c;
16	uVar1 = uVar1 << 1;
16	param_3[1] = 0x40240000;
16	sVar2 = -0x28a3;
16	short *local_24;
16	param_4 = param_4 + 2;
16	iVar1 = *(int *)(&DAT_2120f937 + param_1 * 0x7a);
16	iVar4 = 2;
16	FUN_211850f0(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x2a),uVar5);
16	bVar3 = bVar3 >> 1;
16	FUN_211850f0(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x2a),uVar4);
16	FUN_211850f0(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x2a),uVar6);
16	bVar4 = bVar4 >> 1;
16	**(ushort **)(param_1 + 0x26) = uVar2;
16	iVar3 = 0x10;
16	if (*param_1 == 5) {
16	if ((param_3 == 0) ||
16	uint in_ECX;
16	bVar1 = 0x80;
16	return (uint)puVar1 & 0xffff0000;
16	else if (param_5 == 1) {
16	char *local_44;
16	iVar19 = 1;
16	uVar3 = (uint)param_3;
16	piVar3 = local_2c;
16	ushort extraout_var;
16	local_8 = 0x271c;
16	return 0xd694;
16	if (local_28 != 0) {
16	iVar11 = iVar11 + 0x51;
16	if ((short)param_5 == 1) {
16	if (sVar10 == 2) {
16	switch(local_c) {
16	puVar8 = local_64;
16	uVar6 = local_64[uVar11];
16	} while (uVar11 < uVar5);
16	if (sVar12 != 0) {
16	uVar4 = (undefined2)((uint)iVar2 >> 0x10);
16	iVar10 = (int)(short)param_1;
16	piVar12 = (int *)*piVar12;
16	piVar6 = local_2c;
16	iVar5 = iVar5 + 0x51;
16	iVar2 = *piVar6;
16	piVar9 = (int *)*piVar9;
16	return (int)sVar6;
16	local_10 = -0x2a5b;
16	local_10 = local_30;
16	piVar7 = local_48;
16	*(undefined2 *)(param_2 + 0x32) = 0;
16	iVar7 = (int)sVar8;
16	if (param_4 == (char *)0x0) {
16	uVar16 = 0;
16	uVar8 = 6;
16	iVar12 = 1;
16	} while ((short)local_8 == 0);
16	uVar1 = uVar1 - 1;
16	piVar10 = local_60;
16	iVar11 = (int)sVar5;
16	undefined1 local_c8 [4];
16	undefined1 local_a4 [4];
16	int *local_3c;
16	*(byte *)(param_2 + 0x41d) = *(byte *)(param_2 + 0x41d) & 0xf7;
16	if ((short)uVar12 != 0) {
16	param_1 = param_1 - 1;
16	FUN_21185130(*(undefined4 *)(param_2 + 0xc),0x14,0);
16	FUN_211850f0(*(undefined4 *)(param_2 + 0xc),0x14,0);
16	*(ushort *)(param_2 + 0x41d) = *(ushort *)(param_2 + 0x41d) & 0x7fff;
16	if (*(char *)(*param_3 + 0x43) == '\0') {
16	param_1 = param_3;
16	uVar3 = extraout_var_01;
16	if (*(char *)(*param_3 + 0x43) != '\0') {
16	undefined2 *local_20;
16	if (*(char *)(param_2 + 0x42b) == '\0') {
16	*(byte *)(param_2 + 0x42b) = *(byte *)(param_2 + 0x42b) | 2;
16	if (*(char *)(param_2 + 0x42b) == '\x02') {
16	*(byte *)(param_2 + 0x42b) = *(byte *)(param_2 + 0x42b) & 0xfd;
16	local_44 = 1;
16	sVar2 = *psVar3;
16	piVar4 = param_3;
16	local_10 = local_10 - 1;
16	if ((sVar4 < 1) || (0x40 < sVar4)) {
16	else if (param_1 == 1) {
16	DAT_2121b21c = 1;
16	pvVar1 = (HANDLE)FUN_21002400();
16	return piVar2;
16	DVar1 = GetCurrentProcessId();
16	iVar2 = tPIMMblockReference_getPointer(&local_8);
16	tPIMMblockReference_freeMemory(&local_8);
16	puVar5 = &param_1;
16	if (param_1 == (char *)0x0) {
16	undefined2 local_1f;
16	return (uint)(ushort)(sVar1 >> 0xf) << 0x10;
16	return (int)(short)iVar1;
16	if (iVar1 != 3) {
16	local_14 = iVar6;
16	if ((param_2 < 0) || (7 < param_2)) {
16	local_1e = (&DAT_21207de8)[param_2];
16	if (param_2 < 0x3841) {
16	return -0x27da;
16	if (iVar1 == 2) {
16	if ((param_2 < 0) || (3 < param_2)) {
16	uVar1 = (uint)param_3;
16	else if (param_5 == 2) {
16	if (param_5 != 4) {
16	return 0xffffd5a6;
16	sVar1 = FUN_2107d200(param_1,uVar2);
16	*(uint *)(param_1 + 0x2a) = uVar3;
16	uVar1 = *(ushort *)(param_1 + 0x4a);
16	iVar3 = (int)(short)uVar4;
16	case 0x52db:
16	case 0x52dc:
16	case 0x52dd:
16	case 0x52de:
16	case 0x52f3:
16	case 0x5311:
16	case 0x5316:
16	if (*(char *)(param_1 + 0xb0) != '\x03') {
16	*(undefined1 *)(param_1 + 0x166) = 0;
16	local_c = (int)sVar3;
16	sVar2 = FUN_21080930(iVar1,param_2);
16	sVar2 = FUN_210809e0(iVar1,param_3);
16	sVar2 = FUN_2107e320(iVar1,1,&param_2,&param_3,0,0);
16	param_3[1] = 0x3ff00000;
16	if (param_6 == (char *)0x0) {
16	case 0x5302:
16	undefined4 local_30 [3];
16	sVar1 = FUN_2100a800(*param_1);
16	local_1c = (int)param_2;
16	local_30[0] = 4;
16	FUN_2100a860(*param_1,local_30);
16	int *extraout_ECX;
16	double local_60;
16	double local_50;
16	uVar7 = (**(code **)(*piVar6 + 0x584))
16	param_1 = (undefined2 *)0x0;
16	*(undefined4 *)param_5 = 0x9999999a;
16	_STCMgrControlUser_12(uVar4);
16	&local_6);
16	*param_3 = 0x46b4;
16	int *param_5)
16	*param_4 = 0xfffe;
16	local_14 = 0xffffffff;
16	undefined4 local_6c [2];
16	u64 local_60 [8];
16	undefined1 local_4c [8];
16	if (-1 < (int)*ptVar9) {
16	if (ptVar9 == (tTimerTimeUnit *)0x0) {
16	if ((ptVar9 == (tTimerTimeUnit *)0x0) || (-1 < (int)*ptVar9)) {
16	long local_20 [2];
16	u64 local_10 [8];
16	if (param_5 == (int *)0x0) {
16	tTimerTimebaseEfficient::getResolutionTimeUnit(in_ECX,plVar3);
16	ptStack_3c = (tTimerTimebaseEfficient *)local_10;
16	ptStack_3c = (tTimerTimebaseEfficient *)param_2;
16	long *plVar6;
16	*param_2 = iVar2;
16	sVar1 = *psVar6;
16	*(undefined4 *)(in_ECX + 0x36) = 0;
16	*(undefined4 *)(in_ECX + 0x62) = 0;
16	*(undefined4 *)(in_ECX + 0x66) = 0;
16	*(undefined4 *)(in_ECX + 0x72) = 0;
16	if (*(undefined4 **)(in_ECX + 0x36) != (undefined4 *)0x0) {
16	(**(code **)**(undefined4 **)(in_ECX + 0x36))(1);
16	(**(code **)(*piVar2 + 0x38))(0,&local_8);
16	sVar2 = (**(code **)(*in_ECX + 0x56c))
16	(pvVar3 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_8),
16	pvVar6 != (void *)0x0)) {
16	*param_3 = iVar3;
16	param_3 = param_5;
16	local_3c = piVar10;
16	local_18 = 0x271c;
16	local_c = ftol();
16	local_10 = iVar5;
16	(**(code **)(**(int **)(in_ECX + 0x3a) + 4))(param_2,param_3,param_4);
16	(**(code **)(**(int **)(in_ECX + 0x3a) + 0x14))(param_2,param_3,param_4);
16	} while (iVar3 < 8);
16	undefined1 local_2c [20];
16	uVar3 = _STCMgrControlUser_12(uVar3);
16	*param_7 = uVar2;
16	sVar1 = (**(code **)(*in_ECX + 0x3fc))(param_1,param_2,&local_6,param_4);
16	if (param_1 != (short *)0x0) {
16	} while (uVar6 < uVar5);
16	in_ECX[0x10] = 0;
16	FUN_21087470();
16	*(undefined4 *)(in_ECX + 0x38) = 1;
16	puVar2 = (undefined4 *)FUN_21082700();
16	local_18 = puVar2[1];
16	local_1c = *puVar2;
16	*param_3 = *(undefined4 *)(in_ECX + 0xc);
16	*(undefined2 *)(in_ECX + 6) = 0;
16	ushort *puVar9;
16	if (*(int *)(in_ECX + 8) == 0) {
16	*(undefined4 *)(in_ECX + 4) = param_2;
16	*puVar1 = 7;
16	return 0xffffd68c;
16	piVar1 = (int *)*in_ECX;
16	if (*(char *)(param_1 + 0x193) == '\x02') {
16	*param_3 = local_24;
16	return -0x2a5e;
16	if (iVar3 != 0) break;
16	*(undefined1 *)(param_1 + 0x166) = 1;
16	local_18 = 0xffffffff;
16	if ((short)param_3 == 2) {
16	case -2:
16	sVar1 = FUN_2107ea70(param_1 + 0x15);
16	sVar2 = -0x2971;
16	sVar5 = FUN_210990b0(param_1);
16	*param_4 = *param_4 + 1;
16	FUN_2107fbf0(puVar1,param_9 + (uVar10 % param_4) * 2);
16	*puVar4 = *puVar4 + 1;
16	*puVar5 = *puVar4;
16	uVar2 = (uint)sVar1;
16	puVar3 = param_1;
16	puVar2[3] = 0;
16	iStack_130 = param_1 + 0x15;
16	FUN_2107f260();
16	*param_4 = local_14;
16	uVar2 = (**(code **)(*piVar1 + 0x7c))();
16	if (local_3c == 0) {
16	local_4c = local_14;
16	local_10 = local_40;
16	*(undefined1 *)(param_1 + 0x3b7) = 0;
16	FUN_210978c0(iVar3,4,*(undefined1 *)(iVar3 + 0x3e1));
16	if (*(short *)(param_1 + 0x497) == 0) {
16	goto LAB_2108d507;
16	in_EAX = FUN_21092c30(param_1);
16	if ((short)in_EAX == 0x10) {
16	if (sVar3 == 9) {
16	*(undefined1 *)(param_1 + 0x3b7) = 1;
16	*(undefined4 *)((int)param_5 + 4),param_4);
16	goto LAB_2108dd48;
16	FUN_210978c0(psVar2,7,0x80);
16	if (bVar9) {
16	0);
16	FUN_2108c320(0x32);
16	iVar3 = 8;
16	local_14 = iVar7;
16	float10 fVar1;
16	uStack_20 = 0;
16	sVar4 = 7;
16	fVar9 = (float10)FUN_21090e00();
16	if (fVar9 < (float10)(double)fVar8) {
16	sVar4 = sVar4 + -1;
16	} while (-1 < sVar4);
16	FUN_2108c320(400);
16	dVar1 = (double)CONCAT44(uStack_10,local_14);
16	if (*(short *)(param_1 + 0x495) == 1) {
16	local_c = 0xffffffff;
16	uVar5 = local_10;
16	if (sVar2 == 0x10) {
16	*piVar1 = iVar7;
16	return 0xffffd5a8;
16	if (param_2 == 0x3afc) {
16	local_8 = (int)sVar4;
16	if (param_3 == 0x8980) {
16	undefined4 *param_6)
16	uVar4 = 8;
16	if (param_2 == 0x6982) {
16	*(byte *)(iVar2 + 8) = bVar4;
16	uVar3 = param_5;
16	*puVar5 = 1;
16	*param_5 = uVar1;
16	if (iVar3 == 1) {
16	uVar8 = local_8;
16	uVar5 = FUN_21136310(iVar6);
16	uVar1 = FUN_211362e0(0x2040,param_1);
16	FUN_21136300(uVar1);
16	(*(tMemBlockReferenceBase **)(param_1 + 0x15e),(long *)&local_8);
16	iVar5 = **(int **)psVar9;
16	else if (iVar1 == 1) {
16	FUN_211850f0(*(undefined4 *)(param_1 + 9),0xd,bVar1);
16	if (param_2 == 0x50dc) {
16	int *param_6,int *param_7)
16	_memDelete(*(void **)((int)in_ECX + 0x8b));
16	*(undefined4 *)((int)in_ECX + 0x8b) = 0;
16	_memDelete(*(void **)((int)in_ECX + 0x9f));
16	*(undefined4 *)((int)in_ECX + 0x9f) = 0;
16	_memDelete(*(void **)((int)in_ECX + 0xa3));
16	*(undefined4 *)((int)in_ECX + 0xa3) = 0;
16	uVar2 = param_4;
16	if (param_1 == (undefined2 *)0x0) {
16	if ((char)psVar1[0xbf] == '\x01') {
16	psVar1[9] = 0;
16	param_5 = FUN_21099f00(iVar9,(int)&param_1 + 3,(int)&param_8 + 3);
16	pvVar4 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_c);
16	sVar2 = (**(code **)(*in_ECX + 0x2f0))(uVar1,0x33f4,0x2cec,&param_1);
16	if (param_1 != 10) {
16	case 0x52e4:
16	case 0x52e5:
16	case 0x52e6:
16	case 0x52e7:
16	case 0x52e8:
16	case 0x52e9:
16	case 0x530c:
16	uVar3 = 0x4b;
16	case 0x5330:
16	*param_4 = param_3;
16	uVar3 = 1 << (bVar2 & 0x1f);
16	(*(code *)**(undefined4 **)*puVar2)();
16	return CONCAT22(uVar6,uVar1);
16	*param_12 = (double)(int)sVar7;
16	FUN_2109c880((int)(short)param_3,uVar2);
16	sVar1 = (**(code **)(**(int **)(param_1 + 0x3a) + 0x10))(param_4,param_3,0);
16	*param_6 = (int)sVar2;
16	tBuffer *ptVar4;
16	ptVar4 = NIBS100::tBufferFactory::makeBuffer
16	((tMemBlockReferenceBase *)&param_1,(long *)&local_8);
16	*(undefined4 *)(in_ECX + 0xaf) = 0;
16	uVar1 = (**(code **)(**(int **)(in_ECX + 0x42) + 0x7c))();
16	pvVar5 != (void *)0x0)) {
16	if (local_c != 0) break;
16	_memDelete(pvVar5);
16	uVar2 = *in_ECX;
16	long *plVar5;
16	tMemBlockReferenceBase::unassignExternalPointer((tMemBlockReferenceBase *)&local_c,&local_8);
16	if (ptVar3 != (tBuffer *)0x0) {
16	NIBS100::tBuffer::~tBuffer(ptVar3);
16	fVar7 = (float10)FUN_2109fe30(param_2,5);
16	fVar8 = (float10)FUN_2109fe30(param_2,5);
16	*param_3 = sVar3;
16	if (ptVar4 == (tIterator *)0x0) {
16	return 0xd8df;
16	piStack_8c = &local_8;
16	if (local_70 == 0) {
16	local_30 = local_18;
16	return CONCAT22((short)((uint)iVar2 >> 0x10),0xd8e8);
16	if ((param_3 != 0) && (param_4 != 0)) {
16	puVar2[2] = 0;
16	puVar2[5] = 0;
16	short local_1e;
16	param_2 = in_ECX + 0xb2;
16	psVar1 = param_3;
16	*(undefined4 *)((int)in_ECX + 0xb7) = 0;
16	FUN_210a1f60((int)(short)param_3,uVar2);
16	if (*puVar1 == 0) {
16	FUN_210b6bd0(0);
16	if (sVar1 != -1) {
16	FUN_210a57d0();
16	FUN_210a7af0();
16	iVar2 = *(int *)((int)in_ECX + 0xa7);
16	iVar2 = *(int *)(in_ECX + 0xa7);
16	uVar3 = 6;
16	sVar1 = -0x2713;
16	undefined2 local_8 [2];
16	undefined4 param_5,int *param_6)
16	char cVar5;
16	uint local_7c;
16	iVar12 = *(int *)(in_ECX + 0xa7);
16	if (local_50 == 0) {
16	if (iVar12 != 0) {
16	*(undefined4 *)((int)psVar1 + 0x2f) = uVar11;
16	*(undefined4 *)((int)psVar1 + 0x33) = uVar7;
16	case 0xfffd:
16	local_44 = local_44 + 1;
16	if ((-1 < sVar2) &&
16	bool bVar12;
16	bVar7 = bVar6;
16	puVar1 = *(undefined2 **)(in_ECX + 0xa7);
16	if (param_10 != 0) {
16	undefined4 local_14 [2];
16	switch(*param_2) {
16	if (sVar2 == -10) {
16	(**(code **)(*in_ECX + 0x10))(0xffff0004,6,param_2);
16	(**(code **)(*in_ECX + 0x10))(0xffff0004,5,param_2);
16	(**(code **)(*in_ECX + 0x10))(0xffff0004,3,param_2);
16	(**(code **)(*in_ECX + 0x10))(0xffff0004,1,param_2);
16	(**(code **)(*in_ECX + 0x10))(0xffff0004,0,param_2);
16	*param_4 = -0x2713;
16	while (cVar1 != '\0') {
16	FUN_210ab620(&local_50,0xdb50f40e,0x3f505186);
16	if (iVar5 != 2) {
16	param_2 = (int *)((int)param_2 + 1);
16	fVar5 = (float10)(**(code **)(*in_ECX + 0x14))(0xffff8002,param_2);
16	piVar1 = (int *)in_ECX[3];
16	(**(code **)(*(int *)in_ECX[3] + 0x10))(0xffff0014,local_8,piVar3);
16	local_c = local_c - 1;
16	} while (uVar6 < uVar3);
16	int local_c [2];
16	(*(int *)(*(int *)(*(int *)(in_ECX + 0xc) + 0x14) + 0xaf) + 0x6b +
16	*(int *)(*(int *)(in_ECX + 0xc) + 0xc) * 0x77) * 0.001;
16	iVar7 = *(int *)(*(int *)(in_ECX + 0x10) + 4);
16	*(undefined4 *)(iVar7 + 0x11) = 7;
16	return 0xc;
16	(*(undefined4 *)(in_ECX + 4),*(undefined4 *)(in_ECX + 8),*(int *)(in_ECX + 0x1c) + 1
16	*(undefined4 *)(iVar7 + 0x11) = 9;
16	sVar1 = *(short *)(in_ECX + 0x1c);
16	*param_2 = local_18[0];
16	} while (param_6 != (int *)0x0);
16	while (cVar2 != '\0') {
16	dVar1 = *pdVar5;
16	*(undefined4 *)(iVar7 + 0x11) = 6;
16	*(undefined4 *)(iVar8 + 0xd) = 0x90;
16	*(short *)(iVar8 + 3) = *(short *)(iVar7 + *(int *)(iVar8 + 0x19) * 4) + 2;
16	*(int *)(in_ECX + 0x1c) = iVar7 + 2;
16	*(undefined4 *)(in_ECX + 0x24) = 0;
16	fVar5 = (float10)(**(code **)(**(int **)(in_ECX[6] + 0x14) + 0x14))(0xffff8002,param_4);
16	in_ECX[0x16] = 0;
16	*param_3 = (int)sVar2;
16	uVar1 = param_2[1];
16	if (param_3 != 2) {
16	undefined1 local_40 [8];
16	lVar8 = tPIMMblockReferenceBase::allocateMemory
16	local_20 = pcVar15;
16	pcVar15 = (char *)(int)sVar6;
16	if (pcVar15 == (char *)0x0) {
16	pcVar15 = (char *)(int)sVar7;
16	uVar2 = (**(code **)(*(int *)*in_ECX + 0x7c))();
16	(**(code **)(*(int *)*in_ECX + 0x44))(0xb,uVar2,&local_8);
16	uVar3 = uVar3 + 8;
16	FUN_210062e0();
16	*param_6 = -0x2a58;
16	param_4[1] = (int)s_j__drvsrc_ALL_nidaq_e_series_wal_212090e8;
16	else if (param_1 == 0) {
16	if (param_4 == (undefined4 *)0x0) {
16	local_14 = (undefined4 *)0x0;
16	piVar1[1] = (int)s_j__drvsrc_ALL_nidaq_e_series_wal_2120911c;
16	if (local_18 == (int *)0x1) {
16	param_2 = (int *)0x8;
16	if (0 < *param_3) {
16	*piVar1 = -0x289a;
16	if (iVar2 != 1) {
16	iVar2 = **(int **)(in_ECX + 8 + *param_1 * 4);
16	if (param_2 < 0x83a5) {
16	if (param_2 == 0x83a4) {
16	param_5[1] = (int)s_j__drvsrc_ALL_nidaq_e_series_wal_212090e8;
16	*in_ECX = 1;
16	in_ECX[0x1c] = 0;
16	in_ECX[0x1e] = 0;
16	*param_6 = 0x2896;
16	iVar6 = *piVar2;
16	if (*(void **)(in_ECX + 4) != (void *)0x0) {
16	iVar2 = *param_2;
16	if (_Dest == (char *)0x0) {
16	undefined4 local_118;
16	undefined4 local_104;
16	undefined4 local_f4;
16	param_6 = (int *)((int)param_6 + 1);
16	piVar2 = param_3;
16	case 0xce40:
16	case 0xce54:
16	case 0xce5e:
16	case 0xce72:
16	case 0xce86:
16	case 0xce90:
16	if (puVar2 == (undefined4 *)0x0) {
16	uVar1 = *puVar2;
16	if (iVar6 == 2) {
16	undefined2 local_c [2];
16	switch(*(undefined2 *)(in_ECX + 0x2e)) {
16	*(undefined2 *)((int)in_ECX + 0x676) = 1;
16	*(code **)((int)in_ECX + 0x672) = FUN_210bbb60;
16	if ((-1 < param_3) && (param_3 < 2)) {
16	uVar1 = FUN_210039d0(param_1);
16	in_ECX[1] = param_1[1];
16	in_ECX[1] = iVar1 + 1;
16	if (*in_ECX != 1) {
16	FUN_210be030(in_ECX);
16	in_ECX[1] = iVar1 + -1;
16	lVar2 = tPIMMblockReferenceBase::allocateMemory((tPIMMblockReferenceBase *)&param_1,0x44,1,8);
16	(puVar3 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&param_1),
16	local_8 = local_10;
16	_memDelete(local_10);
16	*(undefined4 *)(in_ECX + 0x3e) = 0;
16	local_8 = *(int **)(in_ECX + 0x1c);
16	if (local_8 != *(int **)(in_ECX + 0x20)) {
16	local_8 = (int *)local_8[3];
16	FUN_210ce470();
16	iVar1 = -0x28a3;
16	FUN_210bfa90(&local_c,param_1);
16	local_10 = pvVar7;
16	pvVar7 = local_10;
16	puVar3 = local_2c;
16	*param_2 = 0x4a;
16	*param_2 = 0x48;
16	*param_2 = 0x49;
16	*(undefined4 *)(in_ECX + 0x11c + uVar4 * 4) = 0xa7;
16	u64 *puVar8;
16	u64 local_4c [8];
16	undefined1 local_64 [32];
16	local_44 = local_c;
16	return 0xd735;
16	uVar3 = param_1 - 1U & 0xffff;
16	tTimerTimebasePrecise *in_ECX;
16	*(undefined4 *)(in_ECX + 0x40) = 0;
16	case 0x121:
16	local_10 = local_18;
16	u64::_divide((u64 *)&local_14,(u64 *)&local_14,(u64 *)local_24);
16	if ((param_4 < 0) || (3 < param_4)) {
16	uVar2 = uVar1 & 0xffff;
16	return 0xd899;
16	*param_3 = 0x67;
16	if (param_1 == 0x6a) {
16	return 0xd752;
16	iVar2 = *(int *)*puVar1;
16	return 0xffffd7fc;
16	return 0xffffd59f;
16	uVar2 = (uint)uVar1;
16	if ((iVar1 < 1) && (iVar2 = 0, iVar1 != 0)) {
16	if (uVar5 != 0) goto LAB_210c960d;
16	if (*(int *)(in_ECX + 0x62) == 0) {
16	(**(code **)(*local_c + 0x5c))();
16	iVar2 = (**(code **)(*local_8 + 0x58))();
16	iVar2 = (**(code **)(*local_8 + 0x5c))();
16	return 0xd63f;
16	(uVar2,in_stack_00000020,in_stack_00000010,in_stack_00000024);
16	piVar1 = (int *)*piVar1;
16	FUN_210ce680(param_1,param_2,param_3);
16	if (param_1 == 0xb) {
16	iVar2 = (**(code **)(*in_ECX + 0x38))();
16	puStack_50 = (undefined4 *)0x0;
16	undefined4 uStack_6c;
16	if (uVar2 != 0) goto LAB_210cbe45;
16	else if (uVar3 == 0) {
16	0x5a,0xffffffff,0x5a,0xffffffff,0x5a,0xffffffff,0x5a,0xffffffff,0x5a,
16	iVar6 = iVar5;
16	u64 local_24 [8];
16	(**(code **)*local_c)(1);
16	0xffffffff,0x5a,0xffffffff,0x5a,0xffffffff,0x5a,0xffffffff,0x5a,
16	*(uint *)(in_ECX + 0x2c) = uVar1;
16	FUN_210cfba0(0xd,uVar1);
16	FUN_210cfc20(0x301,1);
16	return -0x2a5a;
16	FUN_210cfc20(0x302,0);
16	FUN_210cfc20(0x300,uVar7);
16	FUN_210d13e0(bVar1 | 4,&local_8);
16	FUN_210d13e0(bVar1 | 5,&local_8);
16	psVar5 = param_2;
16	if (*(int *)(in_ECX + 0x66) == 0) {
16	return 0xd757;
16	} while (uVar4 < uVar1);
16	if (((local_8 == 0) &&
16	case 0xffffffff:
16	if (param_3 == (ushort *)0x0) {
16	if (0 < (short)uVar3) {
16	local_c = (void *)0x0;
16	if ((local_8 != 0) ||
16	in_ECX[3] = param_4;
16	*(ulong *)(this + 4) = param_1;
16	iVar4 = *param_4;
16	uVar3 = (**(code **)(iVar1 + 0x7c))(param_1);
16	(**(code **)(iVar1 + 0x40))(uVar3);
16	if ((param_1 < 0) || (*(short *)(this + 8) <= param_1)) {
16	iVar1 = **(int **)(*(int *)(this + 0x18) + iVar4);
16	iVar1 = **(int **)(iVar4 + *(int *)(this + 0x18));
16	iVar1 = **(int **)(*(int *)(this + 0x18) + param_1 * 4);
16	puVar1[2] = 0;
16	if (param_2 == 50000) {
16	if (*(int *)(iVar3 + 0x30) != 0xa7) {
16	if (local_8 == (long *)0x0) {
16	iVar6 = *(int *)(in_ECX + 0x18) + iVar5;
16	(**(code **)(**(int **)(*(int *)(in_ECX + 0x3e) + param_1 * 4) + 0x20))
16	iVar7 = local_14;
16	local_18 = uVar2;
16	*local_c = uVar3;
16	case 0x115:
16	case 0x116:
16	case 0x117:
16	case 0x135:
16	iVar1 = **(int **)(in_ECX + 0x20a);
16	uVar3 = (**(code **)(iVar4 + 0x7c))(&local_c);
16	if (param_4 == 0x6658) {
16	iVar3 = **(int **)(in_ECX + 0x1fa + param_1 * 4);
16	iVar1 = *(int *)*puVar4;
16	*(tBuffer **)((int)in_ECX + 0x1ce) = ptVar8;
16	*(int *)((int)in_ECX + 0x1d2) = iVar5;
16	(**(code **)(iVar5 + 0x50))(*(undefined4 *)((int)in_ECX + 0x1d2),uVar7);
16	ptVar8 = *(tBuffer **)((int)in_ECX + 0x1ce);
16	param_7 = (undefined2 *)**(uint **)((int)in_ECX + *psVar12 * 4 + 0x1fa);
16	iVar5 = **(int **)(in_ECX + 0x1fe);
16	puVar4 = (undefined4 *)(in_ECX + 0x1d6);
16	local_c = **(int **)(in_ECX + 0x1da + uVar6 * 4);
16	uVar3 = (**(code **)(local_c + 0x7c))(&local_8);
16	uVar5 = (**(code **)(iVar2 + 0x7c))(&local_8);
16	if (*(int **)(in_ECX + 0x10) != (int *)0x0) {
16	case 0x134:
16	case 0x157:
16	case 0x158:
16	uVar2 = FUN_210039d0((int)param_1);
16	case 0xca76:
16	local_8 = (**(code **)(**(int **)(in_ECX + 0xc) + 0x14))(uVar5,&param_2,local_14,&local_10);
16	param_4 = 0x65f4;
16	else if ((param_4 != 0x65f4) && (param_4 != 0x71ac)) {
16	param_4 = 0x71ac;
16	if (!bVar6) {
16	if (param_4 < 0x7b0d) {
16	if (param_4 != 0x7b0c) {
16	(**(code **)(*piVar3 + 0x34))();
16	if (param_4 == 0x71ac) {
16	case 0xc468:
16	if (local_10 == (int *)0x0) {
16	return 0xffffd873;
16	*param_4 = (-(uint)(local_10 != 0xa7) & 0xffffcd9c) + 0x98bc;
16	return 0xffffd88e;
16	if (iVar1 != 0) break;
16	param_2[1] = uVar1;
16	iVar1 = param_2[1];
16	*piVar2 = iVar7;
16	in_ECX = local_1c;
16	u64 *puVar9;
16	uVar4 = uVar2;
16	iVar3 = *piVar1;
16	*piVar1 = iVar3;
16	iVar1 = -0x2a58;
16	param_1 = (char *)0x0;
16	in_ECX[1] = in_ECX[1] + 1;
16	if (param_1 != (char *)0x0) {
16	case 0x445c:
16	case 0x44a4:
16	case 0x44a8:
16	case 0x4484:
16	case 0x448e:
16	case 0x44a2:
16	case 0x44a6:
16	case 0x43de:
16	case 0x43e0:
16	case 0x4444:
16	case 0xc472:
16	case 0xc47c:
16	case 0xc54e:
16	(**(code **)(*piVar1 + 0x24))(0xcc,param_2,*(undefined4 *)((int)in_ECX + 0x16),&local_8);
16	uVar1 = 0xd8e9;
16	if (*psVar9 == 0) {
16	if (*psVar9 != 0) {
16	goto switchD_210efc65_caseD_33f5;
16	goto switchD_210efce9_caseD_3b3d;
16	pdVar14 = pdVar4;
16	iVar9 = FUN_210f09d0(0x40000,pdVar4,pvVar5,pvVar6,pvVar7);
16	local_20 = (double *)0x512;
16	puVar10 = puVar10 + 4;
16	local_20 = (double *)((int)local_20 + -1);
16	} while (local_20 != (double *)0x0);
16	iVar9 = *in_ECX;
16	uVar1 = param_5;
16	*param_2 = (int)(short)uVar4;
16	piVar8 = local_60;
16	dVar1 = *param_1;
16	dVar6 = param_1[3];
16	double dVar17;
16	undefined4 uStack_50;
16	pdVar17 = pdVar17 + 1;
16	double dVar23;
16	} while (iVar26 < param_2);
16	pdVar28 = *(double **)(in_ECX + 0xa8);
16	pdVar28[1] = *pdVar28 - pdVar28[1];
16	*pdVar28 = dVar1 + *pdVar28;
16	dVar1 = pdVar28[2];
16	dVar3 = pdVar21[2];
16	dVar4 = pdVar21[1];
16	dVar6 = pdVar28[3];
16	pdVar4 = local_10;
16	*puVar11 = 0;
16	local_8 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_10);
16	local_c = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_10);
16	pdVar6 = local_8;
16	local_c = 1.0;
16	case 0x3f:
16	(**(code **)(**(int **)(in_ECX + 0x157) + 0x30))
16	if (*(int *)(in_ECX + 0xd5) == 0x3eb) {
16	puVar2 = (undefined4 *)(*(int *)(in_ECX + 0x31) + iVar4);
16	puVar2 = (undefined4 *)(iVar4 + *(int *)(in_ECX + 0x31));
16	float *pfVar3;
16	param_1 = pdVar1;
16	return 0xffffd59a;
16	(**(code **)(**(int **)(in_ECX + 0x15b) + 0x24))();
16	_memDelete(puVar4);
16	(**(code **)(**(int **)((int)in_ECX + 0x163) + 0x44))
16	(0xf,*(undefined4 *)((int)in_ECX + 0x14f),&local_8);
16	*(undefined4 *)((int)in_ECX + 0xed) = 0xd4;
16	*(undefined4 *)((int)in_ECX + 0xf5) = 0xd4;
16	*(undefined4 *)((int)in_ECX + 0xfd) = 0x163;
16	FUN_2110b300();
16	puVar3 = (u64 *)FUN_21058950();
16	if (param_5 == (double *)0x0) {
16	(**(code **)(*piVar4 + 0x44))(8,*(undefined4 *)(in_ECX + 0x14f),&local_8);
16	(**(code **)(*piVar4 + 0x34))(0x13,&param_2,*(undefined4 *)(in_ECX + 0x14f),&local_8);
16	uVar2 = *(undefined4 *)(in_ECX + 0x14f);
16	param_5 = param_1;
16	pdVar12 = pdVar12 + 1;
16	_memDelete(local_14);
16	pdVar7 = local_10;
16	_memDelete(param_5);
16	double *pdVar16;
16	double local_5c;
16	local_44 = 0.0;
16	pdVar8 = pdVar3;
16	pdVar12 = pdVar12 + (int)param_3;
16	pdVar8 = pdVar8 + (int)param_3;
16	pdVar14 = pdVar12;
16	_memDelete(local_18);
16	dVar1 = *pdVar6;
16	pdVar28 = *(double **)(in_ECX + 0x2a9);
16	return 0xffffd59c;
16	(**(code **)(**(int **)((int)in_ECX + 0x157) + 0x44))
16	*(undefined4 *)((int)in_ECX + 0x2c1) = *param_2;
16	*param_2 = 0xffffffff;
16	*pdVar11 = (double)iVar7 * 5.9604644775390625e-08;
16	return 0xbffa0021;
16	uVar3 = (**(code **)(*in_ECX + 0x6a8))(local_8);
16	(**(code **)(**(int **)(in_ECX + 0x34) + 0x20))(0xe,0,&local_c,&local_8);
16	if ((local_8 == 0) && (piVar1 != (int *)0x0)) {
16	(**(code **)(**(int **)(in_ECX + 0x34) + 0x38))(0xe,0,local_c,&local_8);
16	local_c = (int)sVar1;
16	sVar1 = *(short *)((int)in_ECX + 0x6a);
16	(**(code **)(*piVar2 + 0x20))(0x1f7,0xa7,local_c,&local_8);
16	iVar4 = local_1c;
16	*piVar3 = (int)param_3;
16	if ((int)param_3 < 0) {
16	iVar2 = local_c;
16	*piVar4 = local_8;
16	if ((piVar7 != (int *)0x0) && (*piVar7 < 0)) {
16	(**(code **)(**(int **)(in_ECX + 4) + 0x20))(4,0,&local_10,&local_8);
16	(**(code **)(**(int **)(in_ECX + 4) + 0x38))(0x2a,0,local_c,&local_8);
16	iVar1 = FUN_211095c0(local_c);
16	*(undefined4 *)(in_ECX + 0xf9) = 0;
16	u64 local_3c [8];
16	this = (tTimerTimebaseEfficient *)0x0;
16	tTimerTimebaseEfficient::getResolutionTimeUnit(this,&local_10);
16	if (*(int *)(this + 0x14) == 0) {
16	param_9 = (uint)sVar2;
16	pfVar7 = in_stack_0000002c;
16	pfVar7 = pfVar7 + uVar3;
16	pfVar11 = pfVar7;
16	pfVar11 = pfVar11 + param_2;
16	undefined8 uVar7;
16	case 0x108:
16	case 0x10a:
16	param_3[3] = 0;
16	uVar7 = uVar7 - 1;
16	if (local_34 != 0) {
16	if (*(short *)(param_4 + 0x66) == 0) {
16	iVar9 = *param_7;
16	iVar9 = *piVar2;
16	*piVar2 = iVar9;
16	if (*(int *)(in_ECX + 3) != 0) {
16	piVar1 = *(int **)(*(int *)(in_ECX + 0x5a) + (param_1 & 0xffff) * 4);
16	(**(code **)(**(int **)(in_ECX + 0x6e) + 0x44))(0xb,0,&local_8);
16	(**(code **)(*(int *)in_ECX[0x16] + 0x24))(0x13,0,in_ECX[0x17],&local_8);
16	(**(code **)(*(int *)in_ECX[0x16] + 0x20))(0x17f,0x54,in_ECX[0x17],&local_8);
16	*param_4 = iVar2;
16	local_14 = local_50;
16	if ((plVar8 == (long *)0x0) || (-1 < *plVar8)) {
16	if (*param_8 == 0) {
16	sVar1 = (**(code **)(**(int **)(in_ECX + 0x272) + 0x560))
16	sVar1 = (**(code **)(**(int **)(in_ECX + 0x272) + 0x584))
16	(**(code **)(**(int **)(in_ECX + 0x15f) + 0x24))
16	(**(code **)(**(int **)((int)in_ECX + 0x1b3) + 0x40))
16	*(undefined4 *)((int)in_ECX + 0x203) = 0x2000;
16	} while (uVar7 < 0x4000);
16	if (bVar13) {
16	local_14 = (uint)*(char *)(uVar10 + iVar4);
16	double local_48;
16	double local_40;
16	fVar10 = (float10)3247.0 -
16	uVar2 = puVar7[1];
16	uVar3 = puVar7[2];
16	float *pfVar6;
16	int local_a0;
16	iVar1 = strcmp(param_2,s_VAL_PFI_1_2120b3f4);
16	iVar1 = strcmp(param_2,s_VAL_PFI_2_2120b3e8);
16	local_14 = (void *)0x0;
16	(param_1,param_2,0,0x1dd,param_3,uVar2,param_4,1,&param_5,param_6,local_c,local_c,
16	(param_1,param_2,param_3,0x1dd,param_4,uVar2,param_5,1,&param_6,param_7,local_c,local_c,
16	param_8,param_9,param_10,param_11);
16	puVar12 = param_9;
16	*param_15 = *param_15 * 1.52587890625e-05;
16	pbVar9 = _Src + 4;
16	(**(code **)(**(int **)((int)in_ECX + 0x16b) + 0x20))
16	(**(code **)(**(int **)((int)in_ECX + 0x15b) + 0x24))
16	local_c = *puVar1;
16	local_c[1] = 0;
16	puStack_14c = *(undefined1 **)((int)in_ECX + 0x14f);
16	if (*(int *)(in_ECX + 0x62) != 0) {
16	sVar1 = daqDevice::niDaqCfqGetDeviceChildF64AttribArray_TheVirtualThing
16	*(undefined2 *)(in_ECX + 0x44) = 0;
16	*param_3 = (short)local_8;
16	if (0 < *(short *)(in_ECX + 0x32)) {
16	} while (sVar1 < *(short *)(in_ECX + 0x30));
16	if (0 < psVar5[5]) {
16	iVar1 = iVar1 * 0x6e0 + *(int *)(in_ECX + 0x1c9);
16	if (local_c == (undefined4 *)0x0) {
16	float *pfVar4;
16	if ((double)CONCAT44(param_2,param_1) < 0.0) {
16	return *(undefined1 *)(in_ECX + 0x20);
16	sVar1 = sVar2;
16	uVar5 = FUN_21125fd0(uVar2,param_3,0);
16	if (*(int *)(ptVar3 + 0x48) != 0) {
16	return ptVar3;
16	(*(code *)**(undefined4 **)ptVar3)(1);
16	(tDMAIterator *this,_func_void_void_ptr_void_ptr_ulong *param_1,void *param_2,
16	ulong param_3,ulong *param_4,timeStruct *param_5)
16	ulong param_3)
16	uVar2 = local_c;
16	local_2c = puVar6[1];
16	local_30 = *puVar6;
16	lVar10 = local_8;
16	iVar5 = puVar1[2];
16	uVar11 = local_10;
16	iVar2 = *(int *)(this + 0x10);
16	iVar3 = *(int *)this;
16	iVar4 = puVar1[4];
16	iVar5 = *(int *)(this + 0x14);
16	(**(code **)(iVar3 + 0x88))((void *)((int)pvVar7 + (iVar4 * iVar5 + iVar2) * iVar6),param_1,uVar8)
16	(**(code **)(iVar2 + 0x88))(param_1,(void *)((int)pvVar7 + (iVar3 * iVar4 + iVar5) * iVar6),uVar8)
16	(tScaleIterator *this,_func_void_void_ptr_void_ptr_ulong *param_1,void *param_2,
16	_close(_FileHandle);
16	FUN_211362c0(uVar4);
16	bVar7 = *pbVar2;
16	if (((*(uint *)(iVar6 + 0x28) | uVar12) >> (bVar7 & 0x1f) & 1) != 0) {
16	if (*psVar14 == 2) {
16	FUN_211850f0(uVar3,iVar11,((-(*psVar14 != 0) & 2U) + 4) * '\x02' | 1);
16	psVar14[0x13] = 0;
16	if ((sVar4 != 0) && (sVar4 != 1)) {
16	iVar2 = FUN_21069ae0();
16	iVar5 = FUN_21069ae0();
16	sVar3 = (short)param_8;
16	uVar1 = FUN_211362a0(param_1);
16	FUN_2112d820(local_8,uVar10,param_1,0);
16	if ((uVar9 & 0xffff & 1 << (bVar4 & 0x1f)) != 0) {
16	pbVar12 = pbVar12 + 0x10;
16	uVar9 = FUN_21185070(*(undefined4 *)(iVar1 + 0xc),(param_2 & 0xffff) + 2);
16	bVar6 = FUN_21185030(*(undefined4 *)(iVar1 + 0xc),(param_2 & 0xffff) + 1 + (int)sVar2);
16	uVar3 = FUN_2112aa20(param_1,param_2,local_c,&local_8);
16	uVar1 = *(undefined2 *)(&DAT_2120b6ec + iVar4 * 2);
16	iVar5 = iVar4 + -5;
16	if (sVar6 < 6) {
16	uVar3 = FUN_2112d800(local_8,1 << ((char)iVar5 - 1U & 0x1f) | 0x20,param_1,uVar1,0);
16	if ((-1 < (short)param_3) && ((short)param_3 < 0x10)) {
16	ushort *puVar7;
16	iVar9 = *(int *)(&DAT_2120f937 + iVar1);
16	if (param_5[2] == 0) {
16	if (param_5[7] == 0) {
16	uVar14 = FUN_21185070(*(undefined4 *)(iVar9 + 0xc),(param_4 & 0xffff) + 2);
16	else if (param_5[7] == 0) {
16	bVar5 = FUN_21185030(*(undefined4 *)(iVar9 + 0xc),
16	uVar13 = FUN_21185070(*(undefined4 *)(iVar9 + 0xc),(param_4 & 0xffff) + 2);
16	case '\a':
16	sVar1 = local_8;
16	iVar6 = ftol();
16	short local_4a;
16	long) */
16	(daqDevice *this,short param_1,short param_2,short param_3,short *param_4,ulong param_5,
16	*,double *) */
16	*,unsigned long) */
16	iVar1 = Ordinal_17(&local_c);
16	iVar1 = Ordinal_64(local_c,(int)param_1,&local_8);
16	if (param_2 != -1) {
16	uVar15 = 1;
16	if (*(short *)(param_3 + 0x16) == 1) {
16	if (sVar6 != 0) break;
16	short local_74;
16	sVar5 = (short)param_7;
16	uVar9 = ftol();
16	cVar1 = (char)sVar5;
16	if (lVar1 == -1) {
16	uVar2 = *(undefined2 *)(&DAT_21214404 + iVar9);
16	if (iVar5 == 2) {
16	*piVar2 = iVar5;
16	local_c = 0xffffd734;
16	short local_e;
16	puVar18 = &local_28;
16	puVar16 = &local_28;
16	p_Var22 = (LPOVERLAPPED)0x0;
16	DVar19 = 10;
16	DVar17 = 10;
16	DVar15 = 0xabcd2014;
16	if (param_3 == (char *)0x0) {
16	FUN_21139150(*puVar1,*puVar3);
16	*puVar14 = 0;
16	if ((int)uVar23 < 0) {
16	bVar9 = false;
16	bVar9 = true;
16	*local_c = 0;
16	} while (!bVar4);
16	*(undefined2 *)(&DAT_21213588 + sVar7 * 2) = 1;
16	FUN_21135f30(iVar10,0x78);
16	return 0xd8d5;
16	*(undefined4 *)(iVar7 + 0x22) = *(undefined4 *)(param_3 + 0x13);
16	iVar7 = (int)*(short *)(param_2 + 0x1ea);
16	iVar7 = *param_5;
16	uVar5 = FUN_2103d030(sVar2);
16	} while (!bVar6);
16	switch(*(undefined2 *)(param_2 + 0x11)) {
16	return -0x2714;
16	uVar1 = *puVar7;
16	if (sVar16 != 0) {
16	if (iVar6 != iVar9) {
16	puVar7 = puVar7 + 6;
16	sVar1 = *param_3;
16	return (short *)0x0;
16	iVar3 = *(int *)((int)&DAT_2120f9b1 + iVar7 * 0x7a);
16	puVar4 = *(undefined2 **)(&DAT_21217788 + iVar7 * 4);
16	*(undefined1 *)((int)puVar4 + 3) = 2;
16	*(undefined1 *)((int)puVar4 + 0x27) = 2;
16	*(undefined1 *)(puVar4 + 0x15) = 8;
16	*(undefined1 *)(puVar4 + 0x17) = 8;
16	*(undefined1 *)(puVar4 + 0x19) = 8;
16	uVar1 = FUN_21136310(_Buf);
16	uVar6 = local_10;
16	local_c = puVar2;
16	iVar17 = iVar17 + -1;
16	} while (iVar17 != 0);
16	sVar1 = *(short *)(param_1 + 10);
16	param_3[local_3c * 4 + 8] = 0;
16	local_14 = -0x2713;
16	if (local_8 == -0x272f) {
16	short local_70;
16	short local_64;
16	for (local_6c = 0; local_6c < 4; local_6c = local_6c + 1) {
16	for (local_70 = 0; local_70 < 4; local_70 = local_70 + 1) {
16	short local_c0;
16	short local_98;
16	return -0x292e;
16	for (local_24 = 0; local_24 < 4; local_24 = local_24 + 1) {
16	if ((local_8 == -0x272f) &&
16	sVar1 = FUN_21129b00(CONCAT22((short)((uint)local_c >> 0x10),param_1),*local_14,5,4,
16	*(int *)(local_14 + 0x467) = *(int *)(local_14 + 0x467) + 1;
16	local_84 = 2;
16	local_c = -0x2971;
16	uVar4 = (uint)(ushort)local_6c[0x3cc];
16	switch(local_8) {
16	param_2[local_8 + 1] = 2;
16	for (local_14 = 0; local_14 < 8; local_14 = local_14 + 1) {
16	local_c = FUN_21171bda(param_1,&local_20);
16	if ((param_2 < 1) || (*(short *)(local_20 + 0x10) < param_2)) {
16	sVar1 = local_c;
16	piVar1 = (int *)(local_34 + param_3 * 8 + 0x9f7);
16	param_3 = 0xffff;
16	piVar1 = (int *)(local_48 + 0x9f7 + (short)param_3 * 8);
16	for (bVar3 = 0; bVar3 < 8; bVar3 = bVar3 + 1) {
16	(int)((ulonglong)*(ushort *)((int)local_1c + 0xa89) /
16	local_10 = FUN_21171bda(param_1,&local_18);
16	uVar7 = (int)param_3 & 0x80000001;
16	*(char *)((int)local_1c + 0x6d5) = (char)uVar4;
16	*(char *)(local_c + 0x36b) = (char)uVar2;
16	for (local_18 = 0; local_18 < 4; local_18 = local_18 + 1) {
16	return -0x288c;
16	local_c = FUN_21171bda(param_1,local_20);
16	sVar2 = strlen(local_3c);
16	local_c = _SCXIchassis;
16	uVar2 = FUN_21185070(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x32));
16	cVar1 = FUN_211525de(param_1);
16	*(undefined2 *)(param_1 + 0x798) = 0;
16	*(uint *)(param_1 + 0x959 + local_c * 0x10) =
16	*(undefined4 *)((int)param_7 + 4) = 0x3ff00000;
16	if ((param_5 != 0) || (param_6 != 0x40c38800)) {
16	*(byte *)(param_1 + 0x957 + sVar3 * 0x10 + local_10) =
16	return CONCAT22(sVar1,0xd8e9);
16	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 0x20;
16	*(byte *)(param_1 + 0x6d6) = *(byte *)(param_1 + 0x6d6) | (byte)param_2;
16	*(undefined4 *)(param_1 + 0x79e) = 0x40;
16	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0x3f;
16	if (*(int *)(param_1 + 10) < 0xffff) {
16	if ((local_8 == 3) || (local_8 == 5)) {
16	else if (local_8 == 0x16) {
16	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 4;
16	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0xfd;
16	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 0x2f;
16	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 0x11;
16	return 0xd60c;
16	if (*(int *)(param_1 + 10) == 0x80) {
16	*param_4 = (uint)((*(uint *)(param_1 + 0x8ea) & 1 << (bVar2 & 0x1f)) != 0);
16	local_c = 0x26e;
16	local_c = 0x4be;
16	local_30 = ftol();
16	local_14 = FUN_21181d0c(param_1,param_2,&local_8);
16	3);
16	local_c = 0x5c;
16	for (local_1c = 0; local_1c < local_18; local_1c = local_1c + 1) {
16	uStack_2b4._0_4_ = CONCAT22(local_30 >> 0xf,param_1);
16	*param_3 = 10.0;
16	*param_3 = (char)uVar1;
16	*param_4 = (char)((ushort)uVar1 >> 8);
16	*(char *)((int)&local_14 + (int)puVar2) =
16	*(uint *)(puVar2 + 0x3d1) = *(uint *)(puVar2 + 0x3d1) & 0xfffffff0;
16	uVar3 = (undefined2)((uint)local_c >> 0x10);
16	undefined2 *local_28;
16	uStack_24 = 0x40140000;
16	puVar3[1] = 0xd;
16	*(undefined1 *)(puVar3 + 3) = 1;
16	*(byte *)((int)puVar3 + 7) = bVar6;
16	*(byte *)((int)param_1 + 0xfd4f) = bVar6;
16	sVar5 = FUN_2106aa40(param_1 + 0x7eb4,8,uVar2,0x57e,puVar3);
16	bVar6 = *(byte *)((int)param_1 + 0xfd4f);
16	sVar5 = FUN_21182ec0(uVar1,param_1,0);
16	if (param_1[1] == 3) {
16	FUN_210ce470(uVar12,0);
16	puVar3 = u64::operator%=(puVar3,uVar4);
16	puVar3 = u64::operator/=(puVar3,uVar4);
16	local_c = 3600000000;
16	iVar4 = FUN_21185240(param_1);
16	psVar2[1] = sVar3 + param_2;
16	*(int *)(param_1 + 0x1c) = (int)sVar3;
16	*(int *)(param_1 + 0x1c) = (int)*(short *)((int)DAT_212191c0 + 1);
16	if (DAT_2121b3b8 != 0) {
16	FUN_21136340(iVar2);
16	if (DAT_2121b3bc != 0) {
16	float *in_stack_00000028;
16	int *in_stack_00000034;
16	if (param_5 != (float *)0x0) {
16	uVar11 = (uint)param_4 & 0xffff;
16	in_stack_00000024 = in_stack_00000024 + 1;
16	(*(int *)(in_stack_00000034[0x37] + 0x1c + (int)in_stack_00000024) +
16	(uVar8 + in_stack_00000034[0x38]) * 8) =
16	} while (uVar8 < in_stack_00000028);
16	if (((in_stack_00000034[0x2b] == 0) || (in_stack_00000034[0x2c] == 0)) &&
16	((in_stack_00000034[0x2e] == 0 || (in_stack_00000034[0x2b] == 0)))) {
16	scaleAndSetNumReadings(in_stack_00000034[0x24],in_stack_00000028);
16	param_4 = (int *)((int)param_4 + 1);
16	scaleSubset(in_stack_00000034[0x24],in_stack_00000034[0x28],in_stack_00000034[0x2a]);
16	param_2 = (uint *)param_1;
16	param_2 = (uint *)((int)param_2 + -1);
16	} while (param_2 != (uint *)0x0);
16	if (param_1 == (float *)0x0) {
16	*in_stack_0000002c = (int)(puVar1 + uVar14);
16	*puVar9 = *puVar7;
16	puVar9 = puVar9 + (int)param_1;
16	puVar7 = puVar7 + uVar13;
16	param_4 = param_4 + uVar11;
16	puVar8 = puVar8 + uVar11;
16	} while (param_4 < uVar5);
16	*in_stack_0000002c = (int)(puVar1 + uVar5);
16	puVar8 = puVar8 + param_1;
16	(in_stack_00000034[0x38] + uVar11) * 8) =
16	} while (uVar11 < in_stack_00000028);
16	(*(int *)(iVar6 + 0x1c + *(int *)(param_13 + 0xdc)) +
16	} while (uVar2 < uVar7);
16	uint *local_1c;
16	uVar8 = *(undefined2 *)(iVar3 + 0x14);
16	iVar1 = *param_10;
16	pcVar7 = param_4;
16	pcVar7 = pcVar7 + sVar6 + 1;
16	iVar9 = FUN_21009150(param_1,0x25);
16	if ((short)param_8 == 0) {
16	float *pfVar14;
16	if (pcVar8 == (char *)0x0) {
16	*(int *)(param_2 + 6) = iVar11;
16	*(int *)(param_2 + 10) = iVar11;
16	*(int *)(param_2 + 0xe) = iVar11;
16	*(int *)(param_2 + 0x12) = iVar11;
16	sVar13 = strlen(param_1);
16	puVar2[0x56] = 1;
16	iVar3 = atoi(pcVar4 + 2);
16	undefined1 local_cc [4];
16	iVar11 = param_5;
16	uVar5 = FUN_211ce880(param_1);
16	*(undefined2 *)(param_1 + 0xbe) = 1;
16	pcVar4 = (char *)FUN_21185a00(sVar5 + 1);
16	iVar2 = *(int *)(iVar2 + 0x94);
16	uVar5 = *(undefined4 *)(iVar3 + 0xbc);
16	goto LAB_211928c7;
16	if (param_6 == -1.0) {
16	uVar11 = param_10;
16	if (uVar6 == 1) {
16	iVar4 = FUN_21009150(param_2,0x25);
16	local_8 = 0.0;
16	*param_8 = 0.0;
16	fVar11 = extraout_ST0;
16	fVar4 = *param_4;
16	param_2 = (float)((int)param_2 + -1);
16	} while (param_2 != 0.0);
16	fVar1 = *param_4;
16	param_8 = param_9;
16	while (sVar5 = FUN_21197ff0(fVar3,param_2,local_8,param_4,param_5,iVar8,param_9,&param_1),
16	-1 < sVar5) {
16	if (param_2 <= param_7) {
16	return 0xd7ff;
16	_Dest = _Dest + sVar2 + 1;
16	if (*psVar5 == 0) {
16	if (sVar7 < 0) goto LAB_2119c2cf;
16	if (*(int *)(param_1 + 0x276) == 0) {
16	param_4 = (float)FUN_21008a10(iVar2,iVar2,local_10,local_1c,param_1,local_14,local_18,
16	setDestBufferAttrs(*(undefined4 *)(iVar3 + 0x1b2),*(undefined4 *)(iVar12 + 0x98),
16	uVar7);
16	uVar9 = *(undefined4 *)(param_2 + 0xbc);
16	if ((short)param_5 != 2) {
16	&param_4,&param_8,&param_13);
16	sVar14 = 0;
16	sVar5 = strlen(pcVar6);
16	param_9 = 0.0;
16	if (*(short *)(local_8 + 6) == 0x1a) {
16	if (sVar2 < 0) goto LAB_211a6144;
16	if (local_c == (char *)0x0) {
16	iVar12 = local_1c;
16	goto LAB_211a6b20;
16	*psVar6 = (short)param_9;
16	*param_17 = 0;
16	if ((short)local_8 != 0) goto LAB_211a85d9;
16	goto LAB_211a85d9;
16	uVar20 = 3;
16	goto LAB_211a904a;
16	if (fVar1 != 0.0) {
16	DAT_21223668 = 0;
16	goto LAB_211ae1c4;
16	if (DAT_21223668 != 0) {
16	if (local_c == 0xc922) {
16	return 0xd8c7;
16	lVar16 = CONCAT44(uVar11,uVar6);
16	*param_4 = 0x6dc4;
16	goto switchD_211b60b2_caseD_3;
16	switch(*(undefined2 *)(param_4 + sVar14 * 2)) {
16	if (!bVar18) {
16	psVar8 = param_7;
16	sVar4 = strlen(pcVar9);
16	sVar2 = strlen(_Dest_00);
16	_Dest_00 = _Dest_00 + sVar2 + 1;
16	uint *local_18;
16	puVar2 = param_19;
16	uVar3 = FUN_211ce880(param_3);
16	if (param_14 == 0) {
16	goto switchD_211bbb42_caseD_1d;
16	param_10 = uVar11;
16	param_5[5] = uVar6;
16	if (*(double *)(local_8 + 0x1f6) == 0.0) {
16	local_8 = (int *)*param_8;
16	iVar11 = local_24;
16	FUN_211c70f0(iVar1);
16	*(undefined2 *)(iVar1 + 8) = 0;
16	*(ushort *)(local_14 + 6) & ~(ushort)(1 << ((byte)local_18[0] & 0x1f));
16	if ((*(int **)(iVar1 + 0x3a))[1] == 1) {
16	tTimerTimebaseEfficient::getResolutionTimeUnit(local_6c,(long *)puVar12);
16	psVar6 = *(short **)(param_2 + 4);
16	bVar15 = (short)param_5 == 0;
16	if (bVar15) {
16	FUN_21183d20(local_40,uVar5);
16	if (*param_5 != param_3) {
16	sVar3 = FUN_21006840(local_c,*(undefined2 *)((int)local_8 + 0x2e),&local_14);
16	FUN_21183d20(local_40,uVar4);
16	puVar9 = local_18;
16	if (*param_6 != local_14) {
16	uVar2 = uVar6;
16	local_8 = (uint *)0x0;
16	goto switchD_211cee82_caseD_11f;
16	goto switchD_211ced12_caseD_1;
16	*param_7 = *param_6;
16	case 0x6b:
16	case 0x71:
16	goto switchD_211cfb49_caseD_d;
16	} while (sVar2 < param_3);
16	*puVar2 = (param_1 == (ushort *)0x69aa) + 1;
16	goto LAB_211d5065;
16	param_1 = (ushort *)0x6982;
16	param_1 = (ushort *)0x69aa;
16	param_3 = *(uint *)(&DAT_2120cedc + param_3 * 4);
16	error in (no error)B
16	Lead Zero MSG
16	- occurrences: `6`
16	QVWU
16	Cf;]
16	Numeric
16	HMCos
16	TMLbl
16	error outL
16	all files
16	4=+t$=t
16	refnumu"@
16	prompt@@P
16	parity`
16	O$4
16	x?bfff
16	<8(I16)
16	(icl8
16	<wwww
16	*,3
16	DBDHP
16	100V
16	VPTH0
16	8STRG
16	LIsb
16	task ID outM
16	Test Leads?X
16	Error\FC Out
16	driver opened(
16	Error\FC Out(F)4
16	Result`
16	Communication Error.
16	lVICD
16	Ph@]
16	10ND
16	EEPROM.VIX
16	Beep.viU
16	4c0
16	Test Leads?"
16	GlobStat.viU
16	CALONR
16	CALSET.VIU
16	not at EOF
16	gP d
16	[exception action] (none:0) `
16	character string
16	Qus0
16	iteration (0:initialize)M
16	DDLDR
16	Devicei`
16	Outputi`
16	DeviceiPTH0
16	#333333
16	D/A DataD
16	Error\FC In$
16	Selection Mode@
16	Num Rows
16	Scroll Position6@P
16	EPQR
16	jPPh
16	uWf
16	t*f=
16	t$f=
16	]VWf
16	EVf
16	ERPV
16	QRPS
16	EQPh
16	o!!f
16	U,Rf
16	|o"!
16	!Ph
16	stream
16	endstream
16	endobj
16	(/(/
16	ADDR 1`
16	ADDR 2`
16	$@P
16	AllN
16	D/A Values
16	+Q+0
16	Global.viMD
16	4D/x
16	QRhh@h
16	QRhhAh
16	QRhhBh
16	udf"P@
16	aQRRWh
16	^QQU
16	[user-defined codes]>
16	message,
16	mark after write (bytes)
16	patternM
16	start
16	current
16	sourceF
16	input XON/XOFF @!
16	output XON/XOFF @!
16	GPIB Card"
16	StatusGlobalPTH0
16	port numberH
16	- The VI expected to be at "\\Atlas\Shared\Cal-Test\LC103\Source\lv8\103f_cal.llb\Beep.vi" was loaded from "C:\Program Files\National Instruments\LabVIEW 8.6\vi.lib\Platform\system.llb\Beep.vi".
15	local_c = iVar1;
15	undefined4 *local_3c;
15	uVar8 = uVar6;
15	else if (iVar5 == 5) {
15	long *plVar3;
15	int in_AX;
15	bVar6 = 0;
15	param_1[1] = uVar2;
15	return in_AX;
15	undefined2 local_48;
15	undefined2 local_2e;
15	if (iVar2 != 0) break;
15	uVar1 = *puVar3;
15	uVar2 = uVar5;
15	if (lVar1 != 0) {
15	iVar1 = param_1[3];
15	undefined1 *puVar8;
15	1688 SetCINArraySize, elmtNum %ld out of range 0 <= elmtNum < %ldnon-array detected
15	do NOT use specific reset
15	Use Specific Reset
15	Open Serial DriverY
15	Low Value Inductance BoxW
15	IND3Short the UUT leads to the
15	Inductor Value ary
15	daqdrv
15	u4&g
15	RPWQ
15	Gf;}
15	hvers
15	History
15	lMLbl
15	`Labl
15	4LVIN
15	03333333
15	>FYahP
15	6Wh8
15	0!-
15	846g
15	|FPHP
15	<LIvi
15	lLIbd
15	error out\D
15	instr handle out[
15	PLIfp
15	p||>
15	|4./
15	mhm4
15	Oldest compatible LabVIEW.\
15	source4"
15	t>SPVh
15	instr handle out'
15	source4#
15	O$,(
15	instr handle in\D
15	instr handle outgencode.cGenCopyProcs3
15	VI name
15	4"0
15	4BDHP
15	$FTAB
15	6Whn
15	-1MD
15	Computes the mean value and the standard deviation (STD) of the values in the input sequence X. The mean and standard deviation are computed using the following formulas:
15	mean = Sum { X[i] } / n.
15	DZLjHb
15	This vi performs general purpose RS-232 communication.
15	Timeout: (value in seconds)
15	Mode:
15	0 = write then read, 1 = write only, 2 = read only
15	Port Select:
15	This vi handles the RS-232 communications for a UUT. FC In and FC Out are used for flow control.
15	Mode 0 - Write then Read.
15	Mode 1 - Write only.
15	Mode 2 - Read only.
15	4*0
15	NFCW
15	LEADSHRT.viO
15	GlobStat.vi_
15	#33333
15	TSTRG
15	ABORT?.viOD
15	4:0
15	(icl4
15	error?s
15	3.7
15	@0Disk Rev# In
15	IND_CAL.VIH
15	Selection
15	Display Style
15	103FINAL.VIH
15	AVG_RD.VIU
15	ToleranceP
15	LC Array
15	PWRtest.VIU
15	Low Range_
15	QRh
15	QRhhCh
15	False SE
15	MQRP
15	jQRP
15	THIST
15	extnP
15	QQRP
15	True HD
15	TDTHP
15	?fbb`f
14	int in_DX;
14	undefined2 *in_DX;
14	undefined2 param_5)
14	bVar8 = true;
14	if (!(bool)in_CF) {
14	byte bVar9;
14	local_10 = 5;
14	local_48 = param_2;
14	uVar12 = param_2;
14	if (0 < sVar10) {
14	uint uVar19;
14	(*(short *)(iVar2 + 0xaf8) = *(short *)(iVar2 + 0xaf8) + -1, *(short *)(iVar2 + 0xaf8) == 0)) {
14	if ((param_5 != 0) && (param_5 != 1)) {
14	ushort local_3a;
14	sVar11 = (short)param_1;
14	*param_9 = sVar1;
14	ushort *local_18;
14	undefined1 local_48 [4];
14	undefined1 *param_5)
14	uint param_6,int param_7)
14	sVar6 = sVar6 + -1;
14	if ((short)local_c == -0x2a3a) {
14	puVar7 = (uint *)0x0;
14	short *psVar13;
14	return local_54;
14	return 0xd674;
14	else if (sVar11 == 0) {
14	ushort uVar14;
14	iVar5 = (int)param_5;
14	else if (sVar4 == 2) {
14	if (param_4 < 2) {
14	return -0x28d7;
14	return -0x28d8;
14	undefined4 uStack_94;
14	if (sVar7 != 1) {
14	if (puVar9 == (undefined4 *)0x0) {
14	sVar5 != 0)) {
14	if (sVar1 < 1) {
14	puVar3 = local_20;
14	local_3c = 2;
14	FUN_2104b650(param_1);
14	bool bVar17;
14	puVar15 = puVar15 + 1;
14	FUN_21185130(*(undefined4 *)(param_2 + 0xc),0x16,0);
14	uVar7 = param_10;
14	if ((short)local_24 != 0) {
14	iVar14 = 0;
14	uVar20 = 6;
14	param_6 = (char *)0x0;
14	if (iVar7 != 0) break;
14	local_50 = 1;
14	local_38 = local_28;
14	uVar20 = 2;
14	bVar17 = true;
14	if ((short)local_40 == 0) {
14	sVar8 = 2;
14	return -0x2a81;
14	short sVar18;
14	if (1 < sVar18) {
14	sVar4 = FUN_2104a3a0(param_1);
14	ushort local_44;
14	local_ac = 0;
14	ushort uVar13;
14	uVar13 = uVar13 + 1;
14	uVar5 = 0x66bc;
14	local_60 = 1;
14	*param_9 = 1;
14	uVar7 = param_4;
14	local_70 = 1;
14	local_64 = 1;
14	local_54 = 1;
14	local_38 = 0x66bc;
14	iVar6 = (int)sVar2;
14	FUN_2107e090(psVar2,0,0);
14	undefined8 local_34;
14	undefined4 uStack_34;
14	iVar4 = 10;
14	if (iVar14 == 0) {
14	puVar7[1] = 0;
14	local_24 = uVar15;
14	local_40 = local_40 + 1;
14	else if (sVar2 == 10) {
14	undefined8 local_40;
14	char local_2c;
14	double local_64;
14	char *local_24;
14	local_64 = 0.0;
14	local_24 = (char *)0x0;
14	uVar8 = extraout_var_04;
14	if (param_1 == 0x4524) {
14	if ((iVar5 == 0) &&
14	if (iVar6 != 1) {
14	undefined4 local_1d4;
14	ssprintf(s_Error___d_set__File___s_Line___d_2120a4c8,0xffffd734,
14	if (param_1 == 0x6dc4) {
14	if (param_1 == 0x6f54) {
14	if (param_1 == 0x6e28) {
14	if (param_1 == 0x6ef0) {
14	if (param_1 == 0x7aa8) {
14	*param_3 = 0x18;
14	*param_3 = 0x19;
14	*param_3 = 0x1b;
14	*param_3 = 0x1c;
14	*param_3 = 0x1d;
14	*param_3 = 0x1f;
14	if (local_1c == 1) {
14	ulong uVar11;
14	case 0xc6de:
14	case 0xc6e8:
14	case 0xc6f2:
14	case 0xc6fc:
14	case 0xc706:
14	case 0xc710:
14	case 0xc724:
14	if (param_3 == 0x2f8a) {
14	*param_3 = 0x26;
14	*param_4 = *param_3;
14	void *local_1c;
14	dVar22 = 0.0;
14	double dVar19;
14	local_10 = (double *)0x0;
14	iVar7 = 0x1000;
14	) break;
14	double *local_14;
14	double *local_18;
14	pdVar16 = pdVar16 + (int)param_3;
14	if (-1 < iVar10) {
14	if (0 < iVar11) {
14	case 0xe7:
14	uVar9 = param_3;
14	puVar14 = (undefined4 *)((int)puVar14 + 2);
14	if (local_5c == 0) {
14	local_10[0] = 0;
14	Ordinal_9(local_18);
14	local_20 = 3;
14	if (iVar20 == 0) {
14	int local_d0;
14	uint local_c8;
14	undefined1 local_94 [4];
14	int *local_2c;
14	if ((local_c == -0x272f) && (local_c = FUN_21146c41(CONCAT22(extraout_var,param_1)), local_c == 0)
14	for (local_40 = 0; local_40 < 4; local_40 = local_40 + 1) {
14	for (local_4c = 0; local_4c < 4; local_4c = local_4c + 1) {
14	undefined2 *local_30;
14	for (local_68 = 0; local_68 < 4; local_68 = local_68 + 1) {
14	local_48 = '\0';
14	local_44 = '\x01';
14	uVar7 = (undefined2)((uint)puVar4 >> 0x10);
14	if (local_30 != 0) {
14	cVar1 = FUN_211525de(local_10);
14	local_30);
14	local_14 = 0x1e;
14	local_18._0_2_ = FUN_21171bda();
14	undefined8 uVar10;
14	0x3ff00000);
14	if (param_4 < -1) {
14	if (local_8 < 0x10000) {
14	case 0x35:
14	undefined1 local_58 [4];
14	short local_34 [2];
14	local_14 = *(undefined4 *)(param_2 + 10);
14	local_18 = *(undefined4 *)(param_2 + 10);
14	local_18 = 0x1e;
14	switch((short)local_18) {
14	local_1c = (char *)0x0;
14	FUN_21185a40(local_68);
14	FUN_21185a40(local_70);
14	FUN_21185a40(local_1c);
14	FUN_21185a40(local_48);
14	FUN_21185a40(local_58);
14	FUN_21185a40(local_24);
14	undefined1 local_3e [2];
14	size_t sVar10;
14	FUN_21185a40(local_6c);
14	&local_18);
14	param_6 = param_8;
14	if ((short)uVar10 < 0) {
14	if (0 < (short)local_14) {
14	uVar5 = 0xffffffff;
14	switch(*(undefined4 *)
14	param_8[1] = 0;
14	param_8[2] = 0;
14	387 RSRC
14	38e LVSBLBVW
14	39d i386
14	3a2 <MQ<
14	446 LVSB
14	786 PRU
14	85b SVWU
14	8ce vVf=
14	98d vFf=
14	9b4 Sj$
14	a41 vDf=
14	ac0 fFf
14	ad6 ]_^[
14	c86 DAQTABLS: AI_TASK ALLOCATE, device %d, group %d.DAQTABLS: freeing all LVAIGroupDesc structs.DAQTABLS: AO_TASK ALLOCATE, device %d, group %d.DAQTABLS: freeing all LVAOGroupDesc structs.DAQTABLS: DIO_PORT_TASK ALLOCATE, device %d, port %d.DAQTABLS: freeing all LVDIGPortDesc structs.DAQTABLS: allocating new memory ...DAQTABLS: using existing memory.DAQTABLS: pointer is 0x%lxSetCINArraySize, elmtNum %ld out of range 0 <= elmtNum < %ldnon-array detected
14	e4c RSRC
14	e53 LVSBLBVW
14	e68 PLAT
14	e6d LVSB0|gg
14	e7b daqtabls
14	e84 daqtabls
14	1005 RSRC
14	100c LVSBLBVW
14	101b i386
14	109d LVSB
14	13dd PRU
14	16d8 RSRC
14	16df LVSBLBVW
14	16f4 PLAT
14	16f9 LVSB0|gg
14	1707 daqlptrs
14	1710 daqlptrs
14	pos mode specifies where the write begins relative to pos offset:
14	pos mode specifies where the reads begins relative to pos offset:
14	Power Board test Version
14	Relay Settle Time(mS)@
14	iVar4 = **(int **)(param_1 + 0x138);
14	pdVar11 = pdVar11 + (int)param_3;
14	- sources: `Source_LV5_1_103f_cal.llb.strings.txt`
14	SVW1
14	EPR
14	LVARu
14	adir
14	True
14	stop
14	UUUUUU
14	daqlptrs.lsb
14	function is the operation to perform:
14	@0default name
14	04B0
14	4X0
14	4p0
14	\FPHP
14	convert eol
14	don't convert eol
14	20MD
14	STR#
14	(h
14	dLIbd
14	100PD
14	0LIds
14	XDSTM
14	lvers
14	8
14	100MD
14	HICON
14	\icl4
14	XFPHP
14	\LIvi
14	bPTH0
14	XVICD
14	single trigger
14	mA DC
14	\4N0
14	4j3
14	d0C-
14	x?"ffffff
14	$TRec
14	4LIds
14	HDFDS
14	pvers
14	WAIT.VIS
14	Test Sequence4
14	Abort All
14	xICON
14	PHIST
14	do NOT use break delay
14	serpOpen.viW
14	<ZDj@b
14	m[{u
14	a[ou
14	,ICON
14	tvers
14	(DLDR
14	WriteP
14	port selectPTH0
14	NFCR
14	CAPO
14	4P0
14	6Wh;
14	Error\FC In(
14	IST_WT_A.VIH
14	CLRPARd
14	?>G8
14	0vers
14	@0
14	port length
14	?>Gx
14	Leakage I Data
14	Sources Calibrated
14	Start
14	uW3
14	4SVW
14	A!!
14	t,!!
14	:tf
14	_^[f
14	X9!!
14	EQRP
14	VSWQj
14	PSQj
14	jPRh
14	BQj
14	HRj
14	X=!!
14	tIf=
14	jQRj
14	jRj
14	^_[]
14	t6f=
14	t f=
14	WRPQS
14	E_^
14	E,_^[
14	NWP
14	UPQR
14	jqj/
14	PQjWh
14	QRPh
14	A,f=@
14	QPh<
14	E(Pf
14	8}!!
14	t0f=
14	u9}
14	RWSj
14	7"!f
14	H.QR
14	Dio Table
14	HHIST
14	Retries
14	Test to Perform
14	Status loop flag
14	ZYQRhP
14	s|z>
14	QRhhFh
14	old4 P
14	udf&P@
14	Message"
14	oldnP
14	Run Test?>
14	QRRQ
14	False V
14	return string6@P
14	Width@
14	Height
14	=t/
14	|CPST
14	output string
14	PWRtest.VIH
13	uint in_BX;
13	undefined2 extraout_DX;
13	code *pcVar2;
13	uVar2 = 0xffff;
13	EAstatus is TRUE if an error occurred; the default value is FALSE.
13	zvsource is in most cases the name of the VI or function that produced the error; the default value is an empty string.
13	See the Data Acquisition VI Reference Manual for your platform for tables listing the default settings and ranges for this VI for the boards with which it will work.$
13	xt(bool) status: TRUE if an error has occurred. Regardless of the value of status, this VI clears the input operation.
13	All  (Not Ringer)
13	Please check the setting again.
13	type of dialog (OK msg:1) @
13	type of dialog (OK msg:1)6@P
13	1-(bool) status: TRUE if an error has occurred.
13	error in (no error)F
13	Open Serial Driver.viPTH0
13	4.4
13	E(gf
13	u,&gf
13	]Sj
13	;Eu
13	hLVIN
13	MQQ
13	QSRP
13	dMLbl
13	+****
13	create or replace
13	display
13	status4-
13	H4U0
13	"PTH0
13	a:\Q
13	FPHP!
13	PALM
13	#"">
13	x?"f
13	PFPHP
13	xBDHP
13	d@4P
13	byte countM
13	[$4
13	'\'L
13	4 3
13	DICON
13	[X[H
13	Mh|]h
13	O$,5
13	timeoutM
13	TRec2
13	0LIfp
13	O$,4
13	<\<L
13	Mh`rh
13	(CPST
13	`4=3
13	I( D
13	i|iX
13	-i386
13	Mh ah
13	0LIbd
13	!333
13	40C-
13	D4D3
13	\4F0
13	44j3
13	H4s3
13	MhlLh
13	MhXq
13	qXPTH0
13	kPTH0
13	x450
13	<4.3
13	d4.3
13	0333
13	LLIfp
13	0gencode.cGenDispatchEntry
13	source 4
13	`ICON
13	64ND
13	Calibration ResetW
13	O8<=
13	4C0
13	4H0
13	M%Y+
13	4ICON
13	Hicl4
13	?233333
13	Cal Values&@@
13	Please read the DAQ VI Reference Manual for descriptions of Digital Port Configure and Digital Port Write for more information.
13	Please read the DAQ VI Reference Manual for descriptions of Digital Port Configure and Digital Port Read for more information.
13	...FailedU
13	...PassedZ
13	LC Array string
13	4#0"
13	PWRtest VIs
13	666666666666666666666666666
13	|z"<
13	QRhhDh
13	QRhhHh
13	Disk Rev# In
13	refnum"@!
13	promptD@P
13	True MD
13	Input String@
13	$CPMp
13	fffff3fff3
13	f3ff33f3f
13	3ff3f33f33
13	33f333333
13	Std Deviation and Variance.vi
13	Weighting (Sample)
12	from,to,type
12	*unaff_SI = 0;
12	undefined2 __stdcall16far
12	undefined2 param_5,undefined2 param_6,undefined2 param_7,undefined2 param_8,
12	FUN_1000_c58f();
12	uVar1 = unaff_CS;
12	uVar2 = 0x1030;
12	entry,name,namespace,body_addresses,parameter_count,return_type
12	DAT_1008_0028 = 0;
12	DAT_1008_0026 = 0;
12	RVar1 = RpcStringBindingComposeA
12	strcpy(local_6c,s_NIDAQRemoteClientString_21207044);
12	iVar3 = sVar2 + 1;
12	iVar3 = strcmp(local_6c,s_NIDAQRemoteServerString_2120702c);
12	return 0xf;
12	uVar7 = local_c;
12	sVar2 = FUN_21006ba0(param_1,0x4cf4,&param_1);
12	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),0x17,0x34);
12	if ((uVar3 & 1) != 0) {
12	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),7,0);
12	CloseServiceHandle(hSCManager);
12	CloseServiceHandle(pSVar2);
12	CloseServiceHandle(hService);
12	local_e = param_4;
12	local_1c = 10;
12	local_18 = param_3;
12	local_10 = param_5;
12	*(undefined4 *)(this + 0x14) = *(undefined4 *)(param_1 + 0x14);
12	if (-1 < iVar1 + -1) {
12	undefined4 param_25,undefined4 param_26,undefined4 param_27)
12	undefined4 param_29,undefined4 param_30)
12	param_20,param_21,param_22,param_23,param_24,param_25,param_26,param_27,param_28);
12	param_11,param_12,param_13,param_14,param_15,param_16,param_17,param_18,param_19);
12	param_20,param_21);
12	,param_11);
12	(daqDevice *this,ulong param_1,ushort param_2,ushort param_3,long param_4,ushort param_5,
12	long param_6,long param_7,ulong param_8,ulong *param_9,ulong param_10,ushort param_11,
12	long param_12,ushort param_13,float param_14,float param_15,long param_16,long param_17,
12	param_10,_param_11,param_12,_param_13,param_14,param_15,param_16,param_17,
12	param_26,param_27,param_28);
12	(daqDevice *this,short param_1,short param_2,short param_3,char *param_4,ulong *param_5,
12	undefined2 in_stack_00000032;
12	short *param_12)
12	(daqDevice *this,ulong param_1,ushort param_2,long param_3,float *param_4,long param_5,
12	short,char *,long,double,unsigned short,char *,short,unsigned long *,unsigned short *,double
12	*,char *,short *) */
12	(daqDevice *this,ulong param_1,ushort param_2,char *param_3,long param_4,double param_5,
12	ushort param_6,char *param_7,short param_8,ulong *param_9,ushort *param_10,
12	double *param_11,char *param_12,short *param_13)
12	(daqDevice *this,ulong param_1,char *param_2,long param_3,long param_4,float *param_5,
12	(daqDevice *this,ulong param_1,ulong param_2,ulong param_3,ulong param_4,ulong param_5,
12	iVar1 = FUN_2104a560();
12	return in_stack_00000018;
12	undefined4 in_stack_00000030;
12	return param_3 * param_4;
12	short in_stack_0000003c;
12	return (int)in_stack_0000003c;
12	undefined4 in_stack_00000034;
12	NdrConvert(&local_d4,"N\x0fN\bQ\x01\x02");
12	*param_4 = *(undefined2 *)(local_d4.Buffer + 4);
12	undefined4 param_4,undefined4 param_5,undefined4 param_6,undefined2 *param_7)
12	local_d4.BufferLength = 0x1e;
12	local_d4.BufferLength = 0;
12	NdrGetBuffer(&local_d4,0,param_1);
12	NdrConvert(&local_d4,"N\x0fQ\x01\x06");
12	*param_2 = *(undefined2 *)local_d4.Buffer;
12	ULONG_PTR UVar1;
12	*(ULONG_PTR *)local_d4.Buffer = UVar2;
12	undefined2 param_4,uchar *param_5,ULONG_PTR param_6,ULONG_PTR param_7,
12	*(ULONG_PTR *)((int)local_d4.Buffer + 4) = param_7;
12	*(undefined2 *)(local_d4.Buffer + 0xc) = param_5;
12	*(ULONG_PTR *)local_d4.Buffer = param_10;
12	local_d4.BufferLength = 0x1c;
12	NdrGetBuffer(&local_d4,0x1c,param_1);
12	NdrConformantArrayUnmarshall(&local_d4,(uchar **)&param_7,"\x1b",'\0');
12	local_d4.BufferLength = 0x48;
12	*(ULONG_PTR *)((int)local_d4.Buffer + 4) = param_5;
12	NdrConformantArrayUnmarshall(&local_d4,(uchar **)&param_10,"\x1b\x03\x04",'\0');
12	*(ULONG_PTR *)((uint)(local_d4.Buffer + 3) & 0xfffffffc) = param_4;
12	NdrPointerBufferSize(&local_d4,param_11,"\x12");
12	NdrPointerMarshall(&local_d4,param_11,"\x12");
12	undefined2 param_4,undefined2 param_5,undefined4 param_6,undefined4 param_7,
12	NdrGetBuffer(&local_d4,0x20,param_1);
12	*(undefined4 *)(local_d4.Buffer + 8) = param_6;
12	local_d4.BufferLength = 0x30;
12	local_d4.BufferLength = 0x24;
12	*(undefined2 *)(local_d4.Buffer + 0xc) = param_7;
12	local_d4.Buffer = local_d4.Buffer + 0x16;
12	NdrGetBuffer(&local_d4,0x14,param_1);
12	*(undefined2 *)((int)local_d4.Buffer + 4) = param_6;
12	*(undefined2 *)((int)local_d4.Buffer + 6) = param_7;
12	*param_4 = *(undefined2 *)(local_d4.Buffer + 2);
12	NdrConvert(&local_d4,"N\x0fN\bN\bN\bQ\x01\x06");
12	undefined2 *param_5,undefined2 *param_6,undefined2 *param_7,undefined2 *param_8,
12	local_d4.Buffer = (uchar *)((int)pUVar1 + 6);
12	*(ULONG_PTR *)((int)local_d4.Buffer + 8) = param_7;
12	*param_5 = *(undefined2 *)(local_d4.Buffer + 2);
12	undefined2 param_4,undefined2 param_5,undefined2 param_6,undefined2 *param_7)
12	local_d4.BufferLength = 0xe;
12	NdrGetBuffer(&local_d4,0xe,param_1);
12	NdrConvert(&local_d4,"N\x0fN\x06N\x06N\x06N\x06N\x06Q\x01\x06");
12	NdrConvert(&local_d4,"N\x0fN\x06N\bQ\x01\x02");
12	NdrConvert(&local_d4,"N\x0fN\x06N\bN\bQ\x01\x06");
12	local_d4.BufferLength = 0x27;
12	local_d4.Buffer = local_d4.Buffer + 0x1c;
12	undefined2 param_4,uchar *param_5,ULONG_PTR param_6,ULONG_PTR *param_7,
12	ULONG_PTR *param_8,undefined2 *param_9)
12	NdrConvert(&local_d4,"N\x0fN\x06N\x06N\x06M\x01z");
12	puVar1 = (undefined4 *)((uint)((int)local_d4.Buffer + 3U) & 0xfffffffc);
12	local_d4.BufferLength = 0x25;
12	*(ULONG_PTR *)((uint)(local_d4.Buffer + 3) & 0xfffffffc) = param_6;
12	ULONG_PTR param_5,ULONG_PTR param_6,undefined4 param_7,undefined4 param_8,
12	undefined2 param_9,uchar *param_10,ULONG_PTR param_11,undefined2 param_12,
12	ULONG_PTR *param_13,undefined2 *param_14,ULONG_PTR *param_15,undefined4 param_16,
12	ULONG_PTR param_17,undefined2 *param_18,undefined2 *param_19)
12	local_d4.BufferLength = 0x67;
12	pUVar1[1] = param_6;
12	puVar2 = (undefined4 *)((int)pUVar1 + 0xfU & 0xfffffff8);
12	*puVar2 = param_7;
12	puVar2[1] = param_8;
12	*(undefined2 *)(puVar2 + 2) = param_9;
12	local_d4.Buffer = (uchar *)((int)puVar2 + 10);
12	*(ULONG_PTR *)local_d4.Buffer = param_11;
12	*(undefined2 *)((int)local_d4.Buffer + 4) = param_12;
12	*(ULONG_PTR *)((int)local_d4.Buffer + 8) = param_17;
12	*param_13 = *(ULONG_PTR *)local_d4.Buffer;
12	*param_14 = (short)*(ULONG_PTR *)((int)local_d4.Buffer + 4);
12	*param_15 = *(ULONG_PTR *)((int)local_d4.Buffer + 8);
12	param_15[1] = *(ULONG_PTR *)((int)local_d4.Buffer + 0xc);
12	NdrConformantArrayUnmarshall(&local_d4,(uchar **)&param_16,"\x1b",'\0');
12	puVar3 = (undefined2 *)((uint)((int)local_d4.Buffer + 1U) & 0xfffffffe);
12	*param_18 = *puVar3;
12	*param_19 = puVar3[1];
12	local_d4.Buffer = (uchar *)(puVar3 + 2);
12	NdrConformantArrayBufferSize(&local_d4,param_4,"\x1b\x03\x04");
12	NdrConformantArrayMarshall(&local_d4,param_4,"\x1b\x03\x04");
12	ushort *param_5)
12	*(ushort *)((uint)(local_d4.Buffer + 1) & 0xfffffffe) = param_4;
12	} while (uVar5 < local_8);
12	pdVar2 = pdVar2 + 1;
12	if ((local_8 == 0) ||
12	undefined4 param_15,undefined4 param_16,undefined4 param_17,undefined4 param_18,
12	local_10 = 0xffffd5c6;
12	local_10 = uVar3;
12	_Str = param_3;
12	undefined4 local_34 [2];
12	*param_28 = 0;
12	local_38 = param_4;
12	else if (sVar3 == 3) {
12	undefined1 local_3c [4];
12	uVar3 = local_38;
12	uVar3 = CONCAT22(extraout_var,*(undefined2 *)(in_ECX + 0x2c));
12	if (((short)local_24[1] != -0x2864) && (local_24[0] != 0)) {
12	uVar1 = FUN_2100e080(param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9,param_10,
12	uVar2 = ((param_1 >> 0x18 & 0xf) << 8 | param_1 >> 0x10 & 0xf) << 0x10 |
12	*param_6 = ((local_24[0] >> 0x18 & 0xf) << 8 | local_24[0] >> 0x10 & 0xf) << 0x10 |
12	if ((param_1 & 0x100000) == 0) {
12	undefined4 param_10,undefined4 param_11,undefined4 param_12)
12	short local_2c [2];
12	iVar3 = param_3;
12	undefined4 local_2c [2];
12	undefined4 param_6,undefined4 param_7,char *param_8,undefined4 param_9,uint *param_10,
12	undefined4 param_11,undefined4 param_12,undefined4 param_13,undefined4 param_14)
12	uVar7 = 0x101;
12	sVar1 = strlen(param_8);
12	param_9,puVar6,param_11,param_12,param_13,uVar7,param_14,puVar8);
12	uVar5 = param_5;
12	puVar6 = &local_20;
12	undefined4 param_25)
12	CHAR local_68 [100];
12	if (DVar1 != 0) {
12	DWORD DVar6;
12	if (UVar2 == 0) {
12	return -1;
12	if (*(short *)(param_1 + 8) == 0) {
12	*param_3 = local_8;
12	uVar3 = 0xd598;
12	if (puVar4 == (undefined4 *)0x0) {
12	iVar3 = DAT_2121b214;
12	uVar3 = (uint)sVar1;
12	uVar3 = (int)param_1 - 1;
12	goto switchD_2103cd6b_caseD_2;
12	goto switchD_2103cd6b_caseD_0;
12	*param_3 = uVar4;
12	if (*(short *)(iVar3 + 0x14a) != 0) {
12	if (7 < (short)uVar16) {
12	if (*(short *)(iVar3 + 0x12 + (uVar11 & 0xffff) * 2) == 0) {
12	uVar20 = *(undefined4 *)(iVar3 + 0xc);
12	uVar12 = FUN_21185030(*(undefined4 *)(iVar3 + 0xc),0);
12	FUN_211850f0(*(undefined4 *)(iVar3 + 0xc),1,0);
12	return 0x2a31;
12	if (*(short *)(iVar3 + 0x10) == 0x1e) {
12	FUN_21185030(*(undefined4 *)(iVar3 + 0xc),10);
12	switch(sVar8) {
12	goto switchD_2103d865_caseD_2;
12	goto LAB_2103d9e9;
12	*(undefined2 *)(iVar3 + 0x3ad) = 2;
12	if (*(short *)(iVar3 + 0xa6 + (uVar12 & 0xffff) * 2) == 1) {
12	uVar7 = uVar7 | 1;
12	uVar7 = uVar7 & 0xfffe;
12	FUN_21185130(*(undefined4 *)(iVar3 + 0xc),2,(int)*(short *)(iVar3 + 0x41d));
12	if (uVar7 != *(ushort *)(iVar3 + 0x423)) {
12	*(ushort *)(iVar3 + 0x423) = uVar7;
12	FUN_21185130(*(undefined4 *)(iVar3 + 0xc),0x1a,0xff03);
12	if (bVar18) {
12	if (*(short *)(iVar3 + 0x12 + (uVar12 & 0xffff) * 2) == 0) {
12	sVar10 = (short)param_5;
12	FUN_21185130(*(undefined4 *)(iVar3 + 0xc),0,(int)*(short *)(iVar3 + 0x41b));
12	FUN_211850f0(*(undefined4 *)(iVar3 + 0xc),10,0);
12	FUN_21185030(*(undefined4 *)(iVar3 + 0xc),0x1d);
12	FUN_21185130(*(undefined4 *)(iVar3 + 0xc),10,0);
12	FUN_211850f0(*(undefined4 *)(iVar3 + 0xc),0x1b,0);
12	FUN_21185130(*(undefined4 *)(iVar3 + 0xc),0x14,4);
12	if ((short)param_6 < 0) {
12	return CONCAT22(uVar15,0xd8ed);
12	else if (param_7 == 2) {
12	(iVar18 = CONCAT31(uVar14,*(char *)(local_8 + 0x399)), *(char *)(local_8 + 0x399) != '\0'))
12	goto LAB_2103ee45;
12	_param_4 = 0;
12	return (int)(short)local_18;
12	if (param_4 == 0x6982) {
12	FUN_21185130(*(undefined4 *)(param_1 + 0xc),6,(int)*(short *)(param_1 + 0x421));
12	iVar9 = param_1;
12	uVar10 = FUN_21185030(*(undefined4 *)(iVar4 + 0xc),0);
12	goto LAB_2103fb80;
12	uVar10 = FUN_21185030(*puVar1,0);
12	uVar7 = 0x1000;
12	uVar8 = FUN_21185070(*(undefined4 *)(param_1 + 0xc),0);
12	uVar8 = FUN_21185070(*(undefined4 *)(param_1 + 0xc),0x18);
12	*(short *)(local_8 + 0xaf8) = *(short *)(local_8 + 0xaf8) + 1;
12	if ((*(short *)(local_8 + 0x10) == 0x21) &&
12	(*(short *)(local_8 + 0xaf8) = *(short *)(local_8 + 0xaf8) + -1,
12	*(short *)(local_8 + 0xaf8) == 0)) {
12	uVar4 = 0x4000;
12	iVar6 = (int)sVar5;
12	FUN_211850f0(*(undefined4 *)(local_8 + 0xc),0xc,0);
12	FUN_21185030(*(undefined4 *)(local_8 + 0xc),0x19);
12	FUN_2105f760(0x21,CONCAT22(extraout_var,*(undefined2 *)(iVar2 + 0xaf6)),iVar2 + 0x273);
12	if ((param_2 & 0x20) != 0) {
12	*(undefined4 *)(iVar1 + 0x230) = 10;
12	sVar2 = (short)local_c;
12	uVar8 = FUN_2103d030(local_8);
12	if ((short)param_3 == -1) {
12	pdVar13 = pdVar13 + 1;
12	if (*(short *)(param_1 + 0x10) == 0x21) {
12	if (*(short *)(param_1 + 0xaf8) == 0) {
12	CONCAT22(extraout_var,*(undefined2 *)(param_1 + 0xaf6)),param_1 + 0x273);
12	*param_3 = (ushort)bVar4;
12	*param_3 = uVar6;
12	uVar8 = extraout_var;
12	if (param_6 == 1) {
12	psVar11 = local_c;
12	local_c[0x119] = 0;
12	uVar6 = FUN_2103d030(iVar13);
12	sVar4 = (short)local_10;
12	FUN_21185130();
12	if (sVar4 != 9) {
12	else if (cVar1 == '\x05') {
12	goto LAB_210424d4;
12	local_14 = -1;
12	lpBytesReturned = (LPDWORD)&param_3;
12	local_42 = param_2;
12	HANDLE pvVar2;
12	psVar1 = param_2;
12	if (*psVar1 == 0x12) {
12	iVar6 = local_18[3];
12	*(undefined2 *)(&DAT_2120f920 + iVar7) = 0;
12	if (1 < sVar11) {
12	(&DAT_2120f8e7)[iVar7] = 0xff;
12	*(short *)(*(int *)(&DAT_2120f937 + iVar7) + 0x10) = local_8[6];
12	*(undefined4 *)(&DAT_2120f8f0 + iVar7) = 0x4c90;
12	*(undefined4 *)(&DAT_2120f8ec + iVar7) = 0x8980;
12	*(undefined4 *)(&DAT_2120f8ec + iVar7) = 0x89e4;
12	*(undefined4 *)(&DAT_2120f8f0 + iVar7) = 0x89e4;
12	iVar5 = (int)param_1;
12	param_2 = param_2 & 0xffff;
12	if ((param_3 & 2) != 0) {
12	local_10 = uVar7;
12	if ((param_3 & 0x10) != 0) {
12	local_18 = uVar7;
12	local_1c = uVar6;
12	iVar11 = (int)param_1;
12	sVar1 = (short)iVar3;
12	puVar8 = param_3;
12	if (*(short *)(local_8 + 0xfd) == 0) {
12	iVar7 = param_2;
12	iVar5 = *(int *)(&DAT_2120f937 + sVar1 * 0x7a);
12	psVar4 = psVar4 + 8;
12	iVar2 = *(int *)((int)&DAT_2120f9b1 + iVar3);
12	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),7,(int)*(char *)(param_1 + 0x356));
12	sVar6 = (short)param_3;
12	*param_6 = uVar5;
12	*param_7 = uVar5;
12	*param_9 = uVar5;
12	param_1 = param_8;
12	param_3 = param_3 - 1;
12	param_8 = param_8 + -1;
12	} while (param_8 != 0);
12	*DAT_212191c0 = 0x1d;
12	return CONCAT22(uVar1,1);
12	else if (0xff < sVar1) {
12	sVar1 = 0xff;
12	} while (sVar3 < sVar1);
12	FUN_21044ff0(param_1,param_2,param_3,0);
12	FUN_21044ff0(param_1,param_2,param_3,0xff);
12	if (sVar3 != 0) goto LAB_21046d8e;
12	bVar4 = bVar4 - 1;
12	param_2 = (byte *)((int)param_2 + -1);
12	} while (param_2 != (byte *)0x0);
12	bVar3 = 3;
12	if ((-1 < sVar2) && (sVar2 < 0x14)) {
12	ushort *param_6)
12	ushort *local_20;
12	undefined1 local_e [2];
12	if (sVar4 == 0xd) {
12	FUN_21185130(uVar2,local_2c & 0xffff,*local_20);
12	ushort *local_1c;
12	*local_18 = *local_18 | (ushort)local_24;
12	*local_1c = *local_1c | (ushort)local_20;
12	if ((short)local_c == 0) goto LAB_210486a3;
12	uVar4 = *(undefined4 *)(iVar3 + 0xc);
12	uVar7 = 7;
12	undefined2 uStack_1a;
12	sVar9 = (short)param_3;
12	switch(sVar9) {
12	ushort local_58;
12	*local_1c = *local_1c & ~local_28[0];
12	} while (local_30 != 0);
12	*param_5 = 0x10;
12	*param_10 = 4;
12	local_2c = 0xffffffff;
12	local_28 = 0xffffffff;
12	uVar8 = extraout_var_02;
12	sVar3 = -1;
12	return CONCAT22(param_1 >> 0xf,1);
12	uVar4 = FUN_21185030(*(undefined4 *)(iVar1 + 0xc),0x15);
12	pDVar14 = &param_1;
12	p_Var15 = (LPOVERLAPPED)0x0;
12	DVar11 = 0x50;
12	DVar9 = 0xabcd201c;
12	local_58 = 6;
12	pvVar7 = (HANDLE)FUN_21002400();
12	DeviceIoControl(pvVar7,DVar9,puVar10,DVar11,puVar12,DVar13,pDVar14,p_Var15);
12	return local_52;
12	*param_3 = uVar5;
12	sVar1 = FUN_21132100(param_1);
12	*param_2 = sVar4;
12	sVar13 = 1;
12	if (sVar13 == 0) {
12	psVar10 = param_4;
12	FUN_21185030(*(undefined4 *)(param_3 + 0xc),2);
12	*(undefined1 *)(param_2 + 0x3de) = 0xff;
12	FUN_211850f0(*(undefined4 *)(param_2 + 0xc),0x1b,0x30);
12	*(byte *)(param_2 + 0xae3) = bVar6;
12	uVar11 = *(undefined4 *)(param_2 + 0xc);
12	if (*(int *)(&DAT_21211864 + (short)param_1 * 4) == 1) {
12	short *local_44;
12	uVar7 = local_34 & 0xffff;
12	MrCleanRemoveHandler(0,1,param_1);
12	undefined2 *puVar16;
12	DWORD DVar17;
12	DWORD local_2c;
12	puVar3 = param_4;
12	sVar10 = (short)param_1;
12	if (puVar7 == (uint *)0x0) {
12	*(undefined2 *)(iVar11 + 0x10e) = 1;
12	param_5[1] = puVar3[1];
12	param_5[2] = puVar3[2];
12	puVar3[4] = 0;
12	uStack_44 = 0;
12	undefined4 *puVar16;
12	puVar7 = (undefined4 *)0x0;
12	if (sVar15 == 0) {
12	puVar7 = param_1;
12	uVar9 = param_9;
12	local_c = *(int *)(param_2 + 0xa98);
12	uVar9 = 4;
12	if (cVar2 == '\x01') {
12	iVar3 = iVar4;
12	return 0xd728;
12	goto LAB_2104d979;
12	if ((DAT_2120b704 & 2) != 0) {
12	uVar6 = FUN_21136200(param_10);
12	uVar6 = FUN_21136200(param_9);
12	else if (sVar5 == 1) {
12	switch((short)param_3) {
12	FUN_2104e050(param_2,param_3,param_6);
12	undefined2 *param_7)
12	int *local_4c;
12	uVar4 = (undefined2)((uint)iVar3 >> 0x10);
12	if (local_10 < param_4) {
12	local_18 = uVar6;
12	if ((local_1c[(int)(((ulonglong)uVar5 / (ulonglong)(uint)(int)(short)local_20) %
12	(uVar5 % (uint)(int)(short)local_20 == (int)(short)local_24)) {
12	piVar6 = (int *)((int)local_c + 0x12);
12	_param_4 = 1;
12	if ((short)local_c == -1) {
12	remove(&local_a0);
12	uint _MaxCharCount;
12	iVar4 = FUN_21136300(uVar3);
12	local_8 = param_7;
12	uVar8 = local_c;
12	} while (uVar8 < param_3);
12	remove(local_a4);
12	param_2 = local_8;
12	undefined1 local_3c [32];
12	iVar8 = param_1;
12	if ((double)CONCAT44(param_7,param_6) <= 0.0) {
12	sVar3 = FUN_2104a070(param_1,&local_c);
12	sVar3 = FUN_21082970(iVar1,&param_1);
12	if (*(short *)(&DAT_2120f8de + (short)iVar1 * 0x7a) == 4) {
12	else if (*(short *)(&DAT_2120f8de + (short)iVar1 * 0x7a) == 8) {
12	iVar1 = sVar3 * 0x7a;
12	sVar2 = param_2;
12	uVar3 = *(uint *)(iVar5 + 0x214);
12	FUN_2104a900(param_1 + -1,psVar1,&local_10,&local_14,(int)&param_4 + 3);
12	return local_20 & 0xffff;
12	return (int)(short)local_20;
12	int local_8e;
12	short *local_20;
12	*local_18 = sVar11;
12	goto switchD_210508a6_caseD_21050e7f;
12	if (sVar11 != 2) {
12	if ((sVar9 < 0) || (1 < sVar9)) {
12	undefined2 local_5c;
12	if (7 < param_3) {
12	DeviceIoControl(hDevice,dwIoControlCode,lpInBuffer,nInBufferSize,lpOutBuffer,
12	undefined *local_24;
12	iVar7 = (int)param_2;
12	(((param_2 == 2 || (param_2 == 3)) || (param_2 == 4)))) {
12	if ((short)local_20 < 0) {
12	if (sVar3 != 1) {
12	if (param_2 < 2) {
12	sVar7 = FUN_21006940(param_1,param_2,&local_6);
12	*param_3 = local_2c;
12	*param_7 = -1;
12	*param_3 = -1;
12	*param_8 = -1;
12	if ((sVar6 < 1) || (0x40 < sVar6)) {
12	FUN_21049a20();
12	*param_8 = sVar4;
12	cVar1 = *(char *)((int)param_4 + 5);
12	*param_5 = (short)cVar1;
12	sVar4 = param_4[4];
12	*param_7 = (short)(char)sVar4;
12	undefined3 uVar9;
12	switch(iVar8) {
12	uVar7 = CONCAT31(uVar9,cVar1);
12	local_8 = local_8 + 1099;
12	if (sVar17 == 1) {
12	FUN_21185130(*(undefined4 *)(local_8 + 0xc),4,uVar18);
12	if ((*(short *)(local_8 + 0x3f) == 0) && (*(short *)(local_8 + 0x4f) == 0)) {
12	else if (param_3 == 4) {
12	} while (_param_3 != 0);
12	sVar12 = (short)param_2;
12	sVar15 = 0;
12	iVar11 = sVar15 * 0x10;
12	*(undefined2 *)(iVar11 + 0x1b + param_1) = 1;
12	uVar8 = uVar8 | 0x20;
12	uVar16 = uVar16 | 1;
12	if (*(short *)(param_1 + 0xad) == 0) {
12	if (*(short *)(param_1 + 0xaf) == 0) {
12	puVar4 = param_3;
12	if ((bVar1 & 1) == 0) {
12	FUN_21185130(*(undefined4 *)(param_1 + 0xc),0,*(undefined2 *)(param_1 + 0x9f));
12	(int)(short)param_3);
12	if (*(short *)(param_1 + 0x19) == 1) {
12	FUN_21185130(*(undefined4 *)(param_1 + 0xc),2,*(undefined2 *)(param_1 + 0xa1));
12	if (sVar2 != 2) {
12	return CONCAT22(uVar7,0xd8ed);
12	iVar2 = param_6;
12	param_6 = 2;
12	undefined2 local_4c;
12	else if ((short)param_2 == 2) {
12	if (((short)local_30 != 0) && ((*local_10 & 0x180) == 0)) {
12	return 0x28ce;
12	ushort local_20;
12	iVar1 = 1;
12	param_9);
12	puVar8 = param_9;
12	*param_7 = local_8;
12	undefined1 local_48 [32];
12	if ((sVar2 < 1) || (2 < sVar2)) {
12	undefined1 local_70 [32];
12	u64 local_30 [8];
12	if (piVar1[1] != 1) {
12	local_1c = puVar6[1];
12	local_20 = *puVar6;
12	u64 *puVar1;
12	u64 local_48 [8];
12	puVar5 = (undefined4 *)(**(code **)(*piVar2 + 0x1c))();
12	puVar4 = (u64 *)u64::u64(local_50,(u64 *)&local_10);
12	puVar4 = (u64 *)&local_10;
12	puVar7 = (u64 *)u64::u64(local_50,(u64 *)&local_18);
12	puVar4 = u64::operator-=(puVar7,puVar4);
12	FUN_210589d0();
12	uint *param_6)
12	sVar8 = (short)param_2;
12	*param_4 = 0x98bc;
12	*param_4 = 0x6658;
12	*param_6 = uVar4;
12	uVar6 = uVar4;
12	local_1c = local_c;
12	uVar6 = local_1c;
12	*param_5 = local_14;
12	else if (param_4 == 0xc364) {
12	puVar2 = (undefined1 *)*param_1;
12	if (piVar2[1] != 1) {
12	puVar1[2] = param_5;
12	getDevicePtr((short)*param_2,&param_2);
12	u64 local_c [8];
12	param_1[1] = uVar3;
12	if (param_2 == 0x32fa) {
12	if (-1 < (short)uVar5) {
12	param_3 = param_1;
12	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),0xf,(int)*(char *)(param_1 + 0xae1));
12	if (*(int *)(param_2 + 0xc) != 0) {
12	FUN_21184e80(*(int *)(param_2 + 0xc));
12	FUN_21184e80(*(undefined4 *)(param_2 + 0xc));
12	local_8 = local_8 + 2;
12	iVar11 = (int)(short)param_1;
12	*puVar2 = 0xf;
12	if (param_1._2_2_ == 0) {
12	if ((sVar1 == 0) && (param_1[3] != 0)) {
12	undefined2 local_56;
12	sVar7 = (short)param_1;
12	puVar5[3] = 0;
12	} while (sVar7 < 2);
12	*(byte *)((int)puVar5 + 0xae3) = bVar10;
12	if (*(short *)(param_3 + 0xe) == 0) {
12	(short)uVar10 == 0)) {
12	iVar5 = (int)sVar7;
12	FUN_21185070(*(undefined4 *)(param_2 + 0xc),2);
12	FUN_21185030(*(undefined4 *)(param_2 + 0xc),2);
12	FUN_21185030(*(undefined4 *)(param_2 + 0xc),3);
12	iVar2 = FUN_21183e00(local_2c);
12	while (iVar2 == 0) {
12	iVar4 = 8;
12	FUN_2105bd60(0xef,2,uVar1);
12	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),1,0x5f);
12	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),0,0);
12	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),3,0x5f);
12	FUN_2105c5e0(param_1);
12	*(undefined2 *)(param_1 + 8) = 1;
12	iVar3 = 5;
12	pHVar4 = GetDlgItem(hDlg,param_2);
12	SendMessageA(hDlg,0x111,uVar6,(LPARAM)pHVar4);
12	short *param_10)
12	sVar4 = *(short *)(&DAT_2120f8de + (short)param_1 * 0x7a);
12	sVar5 = -0x2a30;
12	iVar6 = sVar4 + -1;
12	dVar1 = 1e-06;
12	dVar1 = dVar1 * 10.0;
12	if ((short)param_9 != 0) {
12	if (*(short *)(iVar2 + 0x13e) == 0) {
12	if (((((sVar5 == 0x30) || (sVar5 == 0xc9)) || (sVar5 == 0x39)) ||
12	return -0x276c;
12	uVar18 = local_8;
12	uVar17 = param_2;
12	uVar18 = uVar18 - 1;
12	} while (uVar18 != 0);
12	uVar17 = local_8;
12	*psVar13 = sVar5;
12	sVar5 = sVar5 + -2;
12	} while (uVar17 != 0);
12	uVar7 = FUN_21136310(*(undefined4 *)(iVar2 + 0x268));
12	uVar7 = FUN_211362e0(0x2040,(int)*(short *)(iVar2 + 0x266) << 1);
12	*(undefined2 *)puVar9 = (undefined2)param_3;
12	if ((*(code **)(&DAT_21213d58 + local_28 * 4) != (code *)0x0) &&
12	*(byte *)(iVar2 + 0xadf) = bVar16;
12	FUN_211850f0(*(undefined4 *)(iVar2 + 0xc),1,(int)(char)bVar16);
12	*(byte *)(iVar2 + 0xade) = bVar16;
12	bVar16 = *(byte *)(iVar2 + 0xae1);
12	if (*(short *)(iVar2 + 0x10) == 0x1e) {
12	sVar1 = *(short *)(iVar2 + 0x200);
12	FUN_211850f0(*(undefined4 *)(iVar2 + 0xc),0,(int)*(char *)(iVar2 + 0xade));
12	FUN_21185030(*(undefined4 *)(iVar2 + 0xc),10);
12	*(undefined4 *)(iVar2 + 0x220) = 0;
12	sVar6 = *(short *)(iVar2 + 0x10);
12	bVar16 = *(byte *)(iVar8 + 0x199);
12	local_54[8] = 4;
12	local_54[1] = 0;
12	local_54[2] = 8;
12	FUN_211850f0(*(undefined4 *)(iVar2 + 0xc),0x17,0x34);
12	*(byte *)(iVar2 + 0xade) = *(byte *)(iVar2 + 0xade) & 0x7f;
12	uVar7 = *(undefined4 *)(iVar2 + 0xc);
12	if (sVar5 == 0x1e) {
12	FUN_211850f0(*(undefined4 *)(iVar2 + 0xc),0xf,(int)(char)bVar16);
12	*(byte *)(iVar2 + 0xae3) = bVar16;
12	*(undefined4 *)(iVar2 + 0x1ec) = 0;
12	uVar6 = (ushort)param_2;
12	if ((ushort)param_2 == 1) {
12	ushort param_6)
12	local_18 = local_18 - 1;
12	FUN_21185070(*(undefined4 *)(param_8 + 0xc),2);
12	FUN_21185030(*(undefined4 *)(param_8 + 0xc),2);
12	FUN_21185030(*(undefined4 *)(param_8 + 0xc),3);
12	local_40[0] = 0;
12	sVar3 = -0x2a30;
12	local_c[3] = 0;
12	*(undefined2 *)(param_2 + 4) = 0x14;
12	return 8;
12	uVar7 = FUN_21136310(*(undefined4 *)(param_2 + 0x26a));
12	uVar15 = uVar14;
12	local_20 = iVar8;
12	uVar14 = uVar15;
12	return -0x28f0;
12	return 0xd638;
12	if (*(short *)(param_2 + 0x142) != 0) {
12	sVar11 = *local_10;
12	if (sVar11 == 6) {
12	goto LAB_21060d3d;
12	if ((*(code **)(&DAT_21213d58 + sVar11 * 4) != (code *)0x0) &&
12	if ((local_14 != 0) && ((*(byte *)(local_14 + 0x1f) & 0x80) != 0)) {
12	FUN_2107c530(local_14);
12	FUN_21136e00(param_3,param_4,2,local_14);
12	FUN_21136440(local_20,param_4 * 2);
12	*(int *)(param_2 + 0x1ea) = local_20;
12	switch((short)local_8) {
12	sVar11 = (short)local_c;
12	if ((short)param_10 != 0) {
12	local_50[4] = -1;
12	sVar5 = *(short *)(param_2 + 0x1e4);
12	local_50[3] = (ushort)(char)local_10[5];
12	if ((sVar5 == 0xd) || (sVar5 == 0xe)) {
12	goto LAB_21061500;
12	goto LAB_210616d8;
12	iVar6 = iVar5 + 2;
12	FUN_21185130(*(undefined4 *)(param_1 + 0xc),iVar6,0xff0c);
12	FUN_21185130(*(undefined4 *)(param_1 + 0xc),iVar6,0xfff3);
12	iVar1 = iVar2 + 2;
12	FUN_21185130(*(undefined4 *)(param_1 + 0xc),iVar1,0xfff2);
12	if (*(char *)(iVar1 + 0x40c) != '\0') {
12	*(undefined1 *)(iVar1 + 0x40c) = 4;
12	(*(short *)(iVar1 + 0x1fc) < 2)) {
12	uVar3 = uVar3 | 4;
12	iVar3 = *(int *)(param_2 + 0x25e);
12	return CONCAT22((short)((uint)iVar3 >> 0x10),0xd698);
12	if (0 < sVar15) {
12	sVar6 = (short)local_18;
12	uVar7 = FUN_21136310(local_10);
12	if (0 < *param_6) {
12	iVar13 = local_18;
12	local_20 = local_20 + -1;
12	uVar3 = (uint)sVar2;
12	} while ((short)uVar2 != 0);
12	if (*local_8 == 0x18) {
12	undefined2 param_5,undefined4 param_6,undefined2 param_7)
12	sVar1 = FUN_210990b0(param_1);
12	uint *local_10;
12	FUN_21183d20(local_34,uVar7);
12	iVar8 = FUN_21183e00(local_34);
12	puVar1 = (ushort *)(param_9 + (local_8 % param_4) * 2);
12	bVar3 = FUN_21185030(param_8[3],10);
12	uVar6 = param_8[3];
12	*puVar1 = (ushort)bVar3;
12	bVar3 = FUN_21185030(uVar6,10);
12	*puVar1 = *puVar1 | (ushort)bVar3 << 8;
12	uVar6 = FUN_21185030(param_8[3],0);
12	uVar10 = param_3;
12	iVar9 = FUN_21183e00(local_2c);
12	uVar6 = FUN_2103e2e0(param_1,local_c);
12	*(undefined2 *)(iVar3 + ((uint)param_8 % param_4) * 2) = uVar6;
12	param_8 = (uint *)((int)param_8 + 1);
12	*param_1 = 2;
12	undefined2 param_5,undefined4 param_6)
12	sVar2 == 0)) {
12	sVar3 = (short)local_14;
12	if (1 < sVar3) {
12	0xc);
12	*psVar4 = 0;
12	*param_3 = *(undefined4 *)((int)DAT_212191c0 + 3);
12	*param_2 = *(undefined4 *)((int)DAT_212191c0 + 3);
12	*(undefined4 *)(puVar1 + 1) = param_4;
12	} while (sVar4 < 2);
12	*param_8 = uVar1;
12	param_3 = (undefined4 *)((int)param_3 + 1);
12	uVar3 = param_3 & 0xffff;
12	uint param_5)
12	uVar1 = (uint)param_2;
12	iVar13 = local_8;
12	uVar15 = 2;
12	iVar18 = iVar18 + 1;
12	for (iVar4 = 0xe; iVar4 != 0; iVar4 = iVar4 + -1) {
12	if (param_2 == 0x66bc) {
12	if (sVar1 != 0xf) {
12	short local_32;
12	local_24 = param_4;
12	return (uint)uVar6 << 0x10;
12	uVar2 = *(undefined4 *)(iVar1 + 0xc);
12	uVar3 = (undefined2)((uint)iVar1 >> 0x10);
12	return CONCAT22(uVar3,0xd738);
12	psVar1[4] = 0;
12	uVar5 = **(ushort **)(param_1 + 0x26);
12	if ((param_3 == 0) || ((*(byte *)((uint)param_2 + param_3) & bVar3) == 0)) {
12	uVar5 = uVar5 & ~*(ushort *)(param_1 + 0x2c);
12	uVar5 = uVar5 | *(ushort *)(param_1 + 0x2c);
12	if ((bVar3 == 0) && (param_2 != 0)) {
12	while ((bVar4 != 0 || (param_2 != 0))) {
12	if ((param_3 == 0) || ((*(byte *)((uint)param_2 + param_3) & bVar4) == 0)) {
12	iVar5 = 10;
12	iVar5 = 9;
12	*(byte *)(param_4 + (uint)param_2) = *(byte *)(param_4 + (uint)param_2) | bVar4;
12	if ((bVar4 == 0) && (param_2 != 0)) {
12	uVar1 = **(ushort **)(param_1 + 0x26);
12	HANDLE pvVar1;
12	undefined2 *extraout_EDX;
12	puVar2 = *(undefined2 **)(param_1 + 0x26);
12	uVar1 = 0xd5d0;
12	in_ECX = uVar4 & 0xffff;
12	*(undefined1 *)(in_ECX + param_4) = 0;
12	if (((*(ushort *)(param_1 + 0x34) & uVar2) != 0) && (param_4 != 0)) {
12	uVar1 = (ushort)((uVar1 & *(ushort *)(param_1 + 0x34)) != 0);
12	if (uVar1 == 1) break;
12	iVar1 = *(int *)(&DAT_2120f937 + (short)param_1 * 0x7a);
12	sVar3 = FUN_21142800(param_1);
12	undefined1 local_2c [16];
12	puVar1[2] = param_4;
12	uVar3 = uVar3 - 1;
12	} while (uVar3 != 0);
12	pbVar4 = pbVar4 + 1;
12	puVar4 = (undefined4 *)((int)puVar4 + 1);
12	if (param_2 < -1) {
12	sVar6 = -0x2971;
12	if (sVar6 == 8) {
12	return CONCAT22(uVar13,0xd8ed);
12	pcVar10 = (char *)((int)param_6 * 2);
12	pcVar10 = (char *)0xfffe;
12	uVar20 = local_58;
12	param_2 = (uint)*param_3;
12	pcVar10 = param_5;
12	pcVar11 = local_8;
12	pcVar11 = local_44;
12	while (((short)param_11 == 0 && (pcVar10 != (char *)0x0))) {
12	pcVar9 = param_5;
12	if (pcVar10 <= param_5) {
12	pcVar10 = pcVar10 + -(int)pcVar9;
12	pcVar11 = local_40;
12	iVar8 = _write((int)(short)local_c,pcVar11,(int)pcVar9 * 2 & 0xffff);
12	if ((short)iVar8 != (short)((int)pcVar9 * 2)) {
12	goto joined_r0x2106cdde;
12	if (((char *)0x1 < pcVar9) || (*(int *)(iVar16 + 0xf9) != 0)) {
12	goto LAB_2106cbb2;
12	iVar7 = *(int *)(iVar16 + 0xf9);
12	sVar5 = *(short *)(iVar16 + 0x10e);
12	if (sVar1 == 10) {
12	*(undefined1 *)param_3 = 1;
12	if (-1 < (short)local_8) {
12	if (param_2 < 1) {
12	psVar9 = param_3;
12	uVar14 = (uint)sVar4;
12	uVar7 = (uint)uVar10;
12	} while ((int)uVar7 < (int)uVar14);
12	local_16 = '\x01';
12	sVar5 = (short)local_24;
12	goto switchD_2106dbac_caseD_2;
12	uVar8 = local_84[uVar8];
12	*(uint *)(*puVar1 + 0x22) = param_4;
12	*(uint *)(*puVar1 + 0x30) = param_5;
12	*(uint *)(*puVar1 + 0x2a) = local_1c;
12	*(uint *)(*puVar1 + 0x38) = param_6;
12	*(undefined1 *)(*puVar1 + 0x42) = 1;
12	*(undefined1 *)(*puVar1 + 0x45) = (undefined1)local_10;
12	*(short *)(*puVar1 + 0x47) = sVar4;
12	return local_5c & 0xffff;
12	} while ((int)uVar8 < (int)uVar14);
12	uVar14 = param_5;
12	goto LAB_2106e3a9;
12	return uVar7 & 0xffff;
12	FUN_21136ee0(&local_c,0,param_4,iVar15,2);
12	local_c = local_c & 0x7fff;
12	FUN_21136ee0(param_4,iVar15,&local_c,0,2);
12	*puVar1 = uVar14;
12	uVar14 = local_84[uVar8 & 0xffff];
12	uVar8 = local_10;
12	piVar5 = local_48;
12	*piVar5 = iVar11;
12	if ((short)param_3 != -2) {
12	} while (sVar2 < sVar10);
12	} while (sVar10 < 2);
12	sVar3 = -0x2717;
12	if (param_3 != 4) {
12	*puVar8 = uVar6;
12	uVar6 = uVar6 + 0x51;
12	if (local_c == 4) {
12	FUN_21073a50(param_1,param_2,param_3);
12	sVar8 = (short)param_3;
12	if ((*(byte *)(param_2 + 0xae4) & 2) == 0) {
12	return CONCAT22((short)((uint)iVar2 >> 0x10),0xd690);
12	piVar6 = local_38;
12	return CONCAT22((short)((uint)iVar2 >> 0x10),0xd75d);
12	*piVar6 = iVar5;
12	return CONCAT22((short)((uint)iVar5 >> 0x10),0xd690);
12	} while (sVar6 < 3);
12	local_28 = local_10;
12	goto switchD_2107108a_caseD_2;
12	iVar5 = *piVar7;
12	undefined1 local_50 [32];
12	piVar6 = local_78;
12	*piVar6 = param_2;
12	param_2 = param_2 + 0x51;
12	if (0 < sVar8) {
12	long lVar10;
12	piVar11 = local_a0;
12	*piVar11 = iVar7;
12	FUN_21136340(uVar8);
12	uVar15 = uVar13;
12	&local_30);
12	uVar17 = 1;
12	if ((short)local_10 == 10) {
12	uVar13 = local_1c;
12	while ((short)local_8 == 0) {
12	puVar4 = local_2c;
12	iVar7 = (int)sVar6;
12	uVar3 = uVar3 + 0x51;
12	*piVar10 = iVar8;
12	iVar8 = iVar8 + 0x51;
12	piVar10 = (int *)*local_14;
12	undefined4 uVar18;
12	uint *local_38;
12	undefined1 *local_18;
12	local_40 = (int *******)((int)local_24 + 0x12);
12	iVar17 = (int)local_24 + 0x305;
12	cVar2 = *(char *)(local_a0[*param_3] + 0x45);
12	if (cVar2 != *(char *)(local_a0[param_3[sVar8]] + 0x45)) {
12	} while (sVar8 < sVar11);
12	if (cVar2 != '\x01') goto LAB_21072e8d;
12	local_7 = cVar2;
12	} while ((short)local_c < sVar11);
12	uVar18 = 2;
12	goto LAB_21072fcb;
12	piVar12 = (int *)local_3c[1];
12	if (*(char *)(local_54 + 0x1ca) != '\0') {
12	cVar2 = *pcVar6;
12	if (cVar2 == '\x05') {
12	if (cVar2 == '\x04') {
12	(int)param_5 * 2);
12	FUN_21136ee0(uVar18,local_10,param_4,iVar9,2);
12	local_10 = local_10 + (int)local_20;
12	*local_14 = 1;
12	if ((uVar10 & 2) != 0) {
12	else if (*local_28 == '\x05') {
12	if (*local_28 == '\x04') {
12	if (*local_28 == '\0') {
12	if (((short)local_4c == 6) && ((local_5 != '\0' || (local_29 != '\0')))) {
12	local_34 = local_34 & 0x7fff;
12	FUN_21136ee0(&local_34,0,uVar18,iVar17,2);
12	FUN_21136ee0(uVar18,iVar17,&local_34,0,2);
12	if ((local_5 != '\0') || (local_6 != false)) {
12	if (((uVar10 & 2) != 0) && (local_5 != '\0')) {
12	if ((short)local_4c != 6) {
12	*(undefined1 *)(local_50 + 0x42) = 2;
12	local_48 = (undefined1 *)(int)sVar11;
12	local_14 = (undefined1 *)
12	FUN_21136ee0(uVar18,local_14,param_4,iVar9,2);
12	puVar15 = puVar15 + (int)local_48;
12	iVar9 = iVar9 + (int)local_48 * 2;
12	*(undefined1 *)local_6c = 1;
12	*local_64 = 1;
12	local_30 = local_30 & 0x7fff;
12	FUN_21136ee0(&local_30,0,uVar18,iVar17,2);
12	FUN_21136ee0(uVar18,iVar17,&local_30,0,2);
12	if (*(short *)(param_2 + 0x43b) == 2) {
12	*(byte *)(param_2 + 0x41d) = *(byte *)(param_2 + 0x41d) | 8;
12	uVar12 = CONCAT22(sVar13,sVar18);
12	return uVar12;
12	cVar9 = '\0';
12	bVar7 = false;
12	bVar7 = true;
12	uVar10 = uVar10 * 10;
12	if ((short)param_3 == 1) {
12	iVar16 = iVar16 + -1;
12	} while (iVar16 != 0);
12	if ((short)param_1 == 1) {
12	uVar19 = (ushort)uVar21;
12	local_14 = 0x400;
12	bVar2 = 2;
12	FUN_21185130(*(undefined4 *)(param_2 + 0xc),0x16,0xff42);
12	FUN_211851b0(*(undefined4 *)(param_2 + 0xc));
12	_param_3 = _param_3 + -1;
12	char *pcVar8;
12	*(byte *)(param_2 + 0x41c) = *(byte *)(param_2 + 0x41c) & 0xf7;
12	if (*(char *)(param_3[1] + 0x43) == '\0') {
12	iVar5 = param_5;
12	FUN_2104d220(param_1,iVar5);
12	local_10 = iVar8;
12	local_8 = 0xf;
12	local_10 = 0xffff;
12	if (param_5 == 0x81) {
12	piVar9 = (int *)0x2;
12	local_18 = 8;
12	piVar9 = param_3;
12	piVar7 = (int *)0x0;
12	iVar8 = *local_28;
12	piVar9 = piVar7;
12	piVar7 = (int *)FUN_21135ea0(0x74);
12	iVar8 = *(int *)((int)piVar7 + 6);
12	else if (sVar6 == 2) {
12	iVar3 = piVar4[1];
12	iVar3 = piVar4[2];
12	FUN_21185490(iVar5 + 1,(int)sVar4);
12	FUN_211855e0(sVar5 + 1,(int)sVar4);
12	iVar1 = iVar9 * 0x7a;
12	local_14 = iVar9;
12	local_36 = 0;
12	*(byte *)(iVar9 + 0x2c) = bVar5 & 0xef;
12	iVar7 = (short)param_1 * 0x7a;
12	char cVar7;
12	if (sVar2 == 10) {
12	piVar7 = (int *)*piVar7;
12	if (piVar7 != (int *)0x0) {
12	piVar5 = (int *)*piVar5;
12	*puVar2 = *puVar2 & 0x7fff;
12	DeviceIoControl(pvVar1,DVar3,puVar4,DVar5,puVar6,DVar7,pDVar8,p_Var9);
12	if (*piVar2 == param_1) {
12	size_t _Size;
12	*(undefined4 *)((int)&DAT_2120d4ec + iVar3) = 0;
12	*(undefined4 *)((int)&DAT_2120e0ec + iVar3) = 0;
12	param_1[1] = sVar1;
12	if (sVar1 != 2) {
12	getDevicePtr(param_1,&param_1);
12	puVar7[3] = *puVar1;
12	*puVar3 = uVar1;
12	return 0xd8ef;
12	if (sVar7 != 2) {
12	uVar3 = (uint)uVar6;
12	sVar7 = 3;
12	undefined4 local_2d;
12	UnmapViewOfFile(DAT_2121a06c);
12	uVar3 = 0xffffd5d0;
12	*param_4 = param_2;
12	return 0xffffd598;
12	iVar6 = (int)sVar8;
12	local_1c = 4;
12	pdVar7 = pdVar7 + 4;
12	iVar3 = (int)sVar4;
12	sVar4 = 8;
12	uStack_8 = in_ECX;
12	_param_2 = in_ECX + 0x2c;
12	if (sVar2 == 0x2975) {
12	local_18 = param_4;
12	if (param_2 != 0x3840) {
12	if (param_2 < 0x3715) {
12	*(undefined4 *)pdVar7 = 0;
12	iVar2 = (int)(short)param_2;
12	*param_4 = (short)(uVar3 >> 2);
12	if (param_3 != 0.0) {
12	return CONCAT22((short)((uint)iVar2 >> 0x10),0xd8e9);
12	uint local_a0;
12	daqDevice *local_8;
12	local_14 = 4;
12	local_c4 = 0;
12	FUN_21185130(iVar1,uVar2,0x42);
12	if (param_2 == 0x7c9c) {
12	if (param_2 == 32000) {
12	uVar4 = FUN_21184e80(iVar5);
12	if (param_2 == 0x7c38) {
12	if (param_2 == 0x7b70) {
12	param_2 = 3;
12	param_2 = 6;
12	FUN_21136340(iVar1);
12	if (param_5 != 1) {
12	cVar1 = cVar1 + '\x01';
12	uVar2 = uVar2 >> 1;
12	param_1 = uVar3;
12	uVar2 = (undefined2)((uint)uVar1 >> 0x10);
12	case 0x52da:
12	case 0x532f:
12	case 0x5339:
12	*(undefined1 *)(param_1 + 0x158) = 0;
12	iVar3 = FUN_21183e00(local_28);
12	puVar1 = (undefined2 *)(param_1 + 0x15);
12	FUN_21099000(puVar1);
12	FUN_21080520(puVar1);
12	FUN_21099000(iVar1);
12	FUN_21080520(iVar1);
12	if ((param_3 < 0) || (1 < param_3)) {
12	iVar5 = (int)sVar1;
12	if (cVar1 == '\x03') {
12	undefined1 *puVar12;
12	return 0xd710;
12	uVar11 = param_2;
12	case 0x5303:
12	case 0x5304:
12	case 0x5305:
12	case 0x5306:
12	*param_1 = param_2;
12	if (param_2 != 0x66bc) {
12	*(undefined1 *)(param_1 + 0x9b) = 5;
12	sVar1 = -0x2760;
12	if (param_1 != (undefined2 *)0x0) {
12	if (local_40 != 0) {
12	if ((param_1 & 0x800) != 0) {
12	if (cVar4 != '\0') {
12	} while (sVar4 < sVar1);
12	param_2 = uVar5;
12	FUN_21098f20(param_1,&param_1);
12	local_10 = -1;
12	local_40 = 2;
12	undefined1 local_40 [60];
12	local_c = uVar5;
12	goto switchD_210807c2_caseD_52da;
12	*param_2 = 0x4c2c;
12	*param_2 = 0x2c88;
12	if (*(char *)(param_1 + 0x14c) != '\0') {
12	*param_4 = 0xfffd;
12	*param_4 = 0x32;
12	iVar2 = *param_5;
12	*param_3 = 0x32;
12	case '\0':
12	case '\x03':
12	case '\x01':
12	case '\x02':
12	iVar6 = param_4;
12	*param_4 = local_10;
12	local_64 = param_3;
12	tTimerTimeUnit tVar5;
12	tTimerTimeUnit local_1c;
12	tTimerTimeUnit local_8;
12	puVar3 = (uint *)FUN_21082700();
12	if (*piVar3 < 0) {
12	*param_1 = local_c;
12	long local_18 [2];
12	undefined1 *local_8;
12	plVar3 = param_5;
12	plVar3 = &param_4;
12	if (-1 < *plVar3) {
12	local_8 = (undefined1 *)&uStack_44;
12	FUN_21082560(local_8,uVar2,plVar3);
12	FUN_21082350(local_10,uVar1);
12	u64::operator=((u64 *)(in_ECX + 4),local_10);
12	*(undefined4 *)(in_ECX + 0x14) = 1;
12	if ((param_5 != (int *)0x0) && (*param_5 < 0)) {
12	u64 auStack_48 [4];
12	undefined1 *puStack_40;
12	undefined1 local_10 [8];
12	if (param_3 == (long *)0x0) {
12	local_14 = *(undefined4 *)(in_ECX + 0x10);
12	local_18 = *(undefined4 *)(in_ECX + 0xc);
12	puStack_40 = local_10;
12	ptStack_3c = in_ECX + 4;
12	if ((iVar4 != 0) && (param_3 != (long *)0x0)) {
12	*param_3 = lVar6;
12	puStack_40 = local_28;
12	u64::operator+=((u64 *)&local_18,puVar5);
12	puStack_40 = (undefined1 *)tVar3;
12	u64::u64(auStack_48,(u64 *)&local_18);
12	FUN_21082350(&local_20);
12	puStack_40 = *(undefined1 **)(in_ECX + 0x20);
12	u64::u64(auStack_48,(u64 *)(in_ECX + 0x18));
12	puVar7 = (uint *)FUN_21082350(local_28);
12	uVar1 = puVar7[1];
12	uVar2 = *puVar7;
12	if ((local_1c < uVar1) || ((local_1c == uVar1 && (local_20 < uVar2)))) {
12	local_1c = uVar1 - local_1c;
12	if (uVar2 < local_20) {
12	local_20 = uVar2 - local_20;
12	*param_1 = local_20;
12	param_1[1] = local_1c;
12	tTimerTimebaseEfficient::getResolutionTimeUnit(in_ECX,param_3);
12	local_18 = local_10;
12	long local_14 [2];
12	mdsSimpDIGInterpreter::mdsSimpDIGInterpreter
12	mdsSimpDIGInterpreter *in_ECX;
12	*(undefined4 *)(in_ECX + 0x32) = 0;
12	*(undefined4 *)(in_ECX + 0x46) = 0;
12	*(undefined4 *)(in_ECX + 0x4a) = 0;
12	*(undefined4 *)(in_ECX + 0x5a) = 0;
12	*(undefined4 *)(in_ECX + 0x6a) = 0;
12	*(undefined4 *)(in_ECX + 0x6e) = 0;
12	*(undefined4 *)(in_ECX + 0x76) = 0;
12	*(undefined4 *)(in_ECX + 0x7a) = 0;
12	lVar2 = tPIMMblockReferenceBase::allocateMemory((tPIMMblockReferenceBase *)&local_8,0x10,1,8);
12	(puVar3 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_8),
12	iVar4 = (int)(short)param_2;
12	iVar1 = local_8;
12	if (sVar2 == 3) {
12	FUN_211850f0(*(undefined4 *)(*(int *)(in_ECX + 0x2c) + 9),0xd,iVar3 + 0x40);
12	FUN_211850f0(*(undefined4 *)(*(int *)(in_ECX + 0x2c) + 9),0xd,iVar3 + 0x41);
12	bVar1 = bVar1 - 1;
12	&local_14);
12	local_68 = 1;
12	NIMDS100::mdsNewMiniDriver
12	(long *)&local_8);
12	long local_c;
12	pvVar7 != (void *)0x0)) {
12	} while (uVar9 < uVar10);
12	setI32Attribute(*(undefined4 *)(*(int *)(in_ECX + 0x8f) + 0x90),
12	for (uVar10 = (uint)((uVar10 & 1) != 0); uVar10 != 0; uVar10 = uVar10 - 1) {
12	*param_5 = 0.0;
12	if (*(short *)(local_c + 4) == 2) {
12	uVar7 = param_5;
12	sVar4 = -0x271c;
12	iVar5 = (int)(short)param_2;
12	param_8,param_9,param_10);
12	if ((*(char *)(*(int *)(in_ECX + 0x2c) + 4) != '\0') &&
12	if (param_4 != 0x5e24) {
12	*(undefined2 *)(iVar2 + 0xb4) = 1;
12	local_10 = iVar2;
12	if (local_c == 0xa7) {
12	uVar5 = local_14;
12	if (local_14 == 2) {
12	uVar5 = extraout_var_02;
12	sVar3 = *param_1;
12	undefined4 local_24 [6];
12	local_24[0] = 0x100;
12	_memDelete((void *)in_ECX[3]);
12	undefined4 *puStack_3c;
12	param_2 = 0.0;
12	uVar9 = **(ushort **)(in_ECX + 0x18);
12	if ((uVar9 & 0x800) != 0) {
12	if ((uVar9 & 0x400) != 0) {
12	puVar10 = (undefined2 *)(uint)(iVar4 == 0);
12	param_1 = **(ushort **)(in_ECX + 0x18) >> 6 & 1;
12	puVar6 = (u64 *)FUN_21058950();
12	*(undefined4 *)(in_ECX + 0x38) = 0;
12	*(undefined2 *)(in_ECX + 6) = 1;
12	*(undefined2 *)(in_ECX + 6) = 2;
12	if ((uVar5 & 0x800) != 0) {
12	if ((uVar5 & 0x400) != 0) {
12	} while ((~(uint)uVar5 >> 0xc & 1) == 0);
12	puVar9 = *(ushort **)(in_ECX + 0x18);
12	uVar2 = *puVar9;
12	pvVar2 = (void *)*in_ECX;
12	pvVar2 = pvVar1;
12	} while (pvVar1 != (void *)0x0);
12	if (piVar4 != (int *)0x0) {
12	return *in_ECX;
12	if (piVar3 != (int *)0x0) {
12	busDeleteBusObject(in_ECX);
12	undefined4 uStack_24;
12	if (*(char *)(param_1 + 0x167) == '\0') {
12	if (*(int *)(param_1 + 0x2b9) == 0) {
12	*(undefined1 *)(param_1 + 0x1a2) = 0;
12	*(undefined4 *)(param_1 + 0x1ba) = 0;
12	cVar1 = *(char *)(param_1 + 0x167);
12	local_8 = 0xffffd690;
12	sVar2 = FUN_21088b60(iVar7);
12	while (sVar2 == 0) {
12	*param_4 = local_20;
12	return -0x2762;
12	} while (param_1._2_2_ == 0);
12	undefined4 param_6,int param_7)
12	param_6 = param_4;
12	if (param_3 == (uint *)0x0) {
12	param_5[4] = param_3[4];
12	if (*(char *)(param_1 + 0x167) != '\0') {
12	param_5 = FUN_2107fc20(puVar1,(int)&param_1 + 3,(int)&param_8 + 3);
12	if (((short)param_5 != 0) ||
12	(short)param_5 != 0)) break;
12	sVar5 = FUN_2107fc20(puVar1,(int)&param_1 + 3,(int)&param_8 + 3);
12	if ((-1 < param_3) && (param_3 < 3)) {
12	if (*(char *)(param_1 + 0x17e) == '\x01') {
12	for (iVar3 = 0x13; iVar3 != 0; iVar3 = iVar3 + -1) {
12	sVar1 = FUN_2107ea70(param_1);
12	local_8 = -0x271a;
12	FUN_2108af60(param_1,0,0);
12	if (!bVar8) {
12	sVar2 = *psVar6;
12	*param_5 = uVar7;
12	long *plStack_6c;
12	u64::u64((u64 *)&plStack_6c,param_1);
12	plStack_6c = (long *)&param_1;
12	uStack_78 = tTimerTimebaseEfficient::getResolutionValue(local_50,(long *)&local_1c);
12	uVar2 = tTimerTimebaseEfficient::getCounterValue(local_50,local_c);
12	FUN_21082560(&uStack_74,uVar2,puVar5);
12	local_48 = local_10;
12	local_14 = local_44;
12	plStack_6c = (long *)tTimerTimebaseEfficient::getResolutionTimeUnit(local_50,(long *)&param_1);
12	plStack_6c = &local_4c;
12	plStack_6c = local_c;
12	if ((iVar3 != 0) && (&stack0x00000000 != (undefined1 *)0xfffffffc)) {
12	plStack_6c = (long *)param_1;
12	u64::operator+=((u64 *)&local_14,puVar4);
12	plStack_6c = (long *)uVar2;
12	u64::u64((u64 *)&uStack_78,(u64 *)&local_14);
12	FUN_21082350(&local_1c);
12	if ((&stack0x00000000 != (undefined1 *)0xfffffffc) && ((int)param_1 < 0)) break;
12	if ((local_18 < local_34) || ((local_18 == local_34 && (local_1c < local_38)))) {
12	*(undefined1 *)(param_1 + 0x3b6) = 1;
12	*(undefined1 *)(iVar3 + 0x3ba) = 0x14;
12	FUN_210978c0(iVar3,0xb,*(undefined1 *)(iVar3 + 0x3e2));
12	FUN_210978c0(iVar3,1,*(undefined1 *)(iVar3 + 0x3e3));
12	FUN_210978c0(iVar3,3,*(undefined1 *)(iVar3 + 0x3e4));
12	sVar3 = *(short *)(param_1 + 0x495);
12	FUN_210978c0(param_1,5,*(undefined1 *)(param_1 + 0x3e5));
12	FUN_210978c0(param_1,7,*(undefined1 *)(param_1 + 0x3e6));
12	FUN_210978c0(param_1,8,*(undefined1 *)(param_1 + 1000));
12	FUN_210978c0(param_1,10,*(undefined1 *)(param_1 + 0x3e9));
12	sVar2 = FUN_21092c30(param_1);
12	sVar3 = FUN_21092cd0(param_1);
12	if (param_2 == 0x8020) {
12	*(undefined1 *)(param_1 + 0x3b6) = 0;
12	if (param_3 != 0x6653) {
12	if (sVar1 == 8) {
12	} while (uVar2 < param_3);
12	undefined4 uStack_2c;
12	FUN_2108c320(0xfa);
12	sVar4 = FUN_210908d0(psVar2,0x3eb,0,0,(undefined4)local_30,local_30._4_4_,uVar6,&local_18);
12	param_4[2] = (ushort)(byte)local_18;
12	FUN_210978c0(psVar2,3,0x80);
12	sVar4 = FUN_210908d0(psVar2,0x3e9,0,0,(undefined4)local_30,local_30._4_4_,uVar6,local_1c);
12	*(undefined4 *)(iVar2 + 0x4a9) = 0x2f6c;
12	*(undefined4 *)(iVar2 + 0x4b1) = 17000;
12	if (uVar4 != 0) goto LAB_2108f2b1;
12	if (((sVar5 == 0) && (sVar5 = FUN_210977b0(psVar2,0,1,0,0,0x40240000,0), sVar5 == 0)) &&
12	(sVar5 = FUN_210977b0(psVar2,1,1,0,0,0x40240000,0), sVar5 == 0)) {
12	sVar5 = FUN_210908d0(psVar2,0x7d3,1,1,(undefined4)local_34,local_34._4_4_,uVar7,local_12);
12	sVar5 = FUN_210908d0(psVar2,0x7d6,1,1,(undefined4)local_34,local_34._4_4_,uVar7,local_14);
12	sVar5 = FUN_210908d0(psVar2,0x7d2,0,1,0,0,uVar7,local_16);
12	sVar5 = FUN_210908d0(psVar2,0x7d5,0,1,0,0,uVar7,local_18);
12	sVar5 = FUN_210977b0(psVar2,0,0,0,0,0x40240000,0);
12	FUN_210978c0(psVar2,0xe,0);
12	sVar5 = FUN_210908d0(psVar2,0x7d4,0,0,0,0,uVar7,local_10);
12	sVar6 = FUN_21092c80(psVar2);
12	local_34 = (double)CONCAT44(uStack_38,local_3c) / param_3;
12	local_34 = local_34 * 10.0;
12	*(ushort *)(param_4 + 0x14) = (ushort)param_1._2_1_;
12	*(ushort *)(param_4 + 10) = (ushort)local_6[0];
12	FUN_210978c0(psVar2,10,0x80);
12	sVar5 = FUN_210908d0(psVar2,0x7d8,0,0,(undefined4)local_34,local_34._4_4_,uVar7,
12	*(ushort *)(param_4 + 0x16) = (ushort)param_1._2_1_;
12	*(ushort *)(param_4 + 0x10) = (ushort)local_8[0];
12	*(ushort *)(param_4 + 0xc) = (ushort)local_a[0];
12	*(ushort *)(param_4 + 0x12) = (ushort)local_c[0];
12	FUN_210978c0(psVar2,0xe,0x80);
12	FUN_210978c0(psVar2,0x12,0x80);
12	iVar7 = param_5;
12	local_c = local_c + 4;
12	iVar3 = 2;
12	case 0x7d5:
12	case 0x7d6:
12	local_10 = uVar8;
12	return fVar1;
12	FUN_2108c320();
12	uVar6 = uVar6 & ~(1 << ((byte)sVar4 & 0x1f));
12	uVar6 = uVar6 | 1 << ((byte)sVar4 - 1 & 0x1f);
12	param_5 = 0.0;
12	fVar8 = (float10)FUN_21090e00(local_1c - param_5);
12	if (*(short *)(param_1 + 0x495) == 9) {
12	if (*(short *)(param_1 + 0x495) == 6) {
12	undefined4 uStack_3c;
12	local_8 = 100;
12	iVar6 = (int)param_4;
12	param_1 = ftol();
12	param_2 = ftol();
12	local_c = 10;
12	FUN_21097820(iVar6,iVar7,&param_1);
12	*param_3 = iVar6;
12	uVar6 = FUN_21097820(param_1,0x1ea,&param_3);
12	uVar6 = FUN_21097820(param_1,uVar6,&param_3);
12	goto LAB_21093732;
12	if (param_2 == 0x3c8c) {
12	else if (param_2 == 0x3b60) {
12	pvVar3 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_18);
12	puVar6 = (undefined4 *)0x0;
12	_memDelete(*(void **)(in_ECX + 0x5e));
12	_memDelete(*(void **)(in_ECX + 0x66));
12	FUN_210967c0(local_8);
12	iVar4 = FUN_21183e00(local_3c);
12	iVar8 = param_4;
12	FUN_21095730(iVar1,psVar4,&local_14,&local_18,(int)&param_4 + 3);
12	local_c = local_18;
12	if (param_1 < param_4) {
12	return local_38;
12	} while (sVar2 < sVar11);
12	*param_6 = sVar3;
12	sVar13 = sVar13 + 1;
12	psVar1 = param_5;
12	uVar5 = FUN_21136310(iVar8);
12	uVar5 = FUN_21136310(iVar7);
12	iBus *piVar2;
12	if (param_1 != (iBus *)0x0) {
12	local_8 = palStatusMapStatusValue(local_8);
12	if (*piVar1 != 0) {
12	byte *pbVar5;
12	FUN_210979e0(param_1);
12	if (param_2 < 0x7bd5) {
12	if (param_2 < 0x5015) {
12	if (param_2 == 0x5014) {
12	if (param_2 == 0x4dbc) {
12	if (param_2 == 0x4f4c) {
12	if (param_2 == 0x526c) {
12	uVar6 = extraout_var_00;
12	uVar3 = local_c;
12	uVar2 = param_7;
12	local_8 = 0xffffd8e9;
12	uVar3 = 0xffffd734;
12	FUN_211850f0(*(undefined4 *)(param_1 + 0x19),0xf,*(byte *)(param_1 + 8) | 1);
12	} while (sVar6 < sVar1);
12	sVar1 = getDevicePtr(*param_1,&param_1);
12	if (param_1 == (short *)0x0) {
12	if ((char)psVar1[0xbf] == '\x02') {
12	iVar6 = iVar7;
12	psVar1[8] = 0;
12	*(undefined4 *)((int)in_ECX + 0xa7) = 0;
12	sVar1 = _STCMgrControlUser_12(uVar2);
12	sVar1 = *psVar5;
12	if (*(int *)((int)in_ECX + 0xb3) != 0) {
12	if ((short)param_3 != 1) {
12	bVar2 = (byte)param_3;
12	(**(code **)(**(int **)(in_ECX + 0x3a) + 0xc))(param_2,param_3);
12	(**(code **)(**(int **)(in_ECX + 0x3a) + 0x1c))(param_2,param_3);
12	undefined4 *param_10,ushort *param_11,double *param_12,undefined1 *param_13,
12	undefined2 *param_14)
12	switch(param_7) {
12	if (DAT_2120eea0 == 0) {
12	param_2 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&param_2);
12	(tMemBlockReferenceTemplate<char> *)&param_1,1);
12	if (ptVar4 == (tBuffer *)0x0) {
12	if (*(int *)(in_ECX + 0xaf) != 0) {
12	if (ptVar4 != (tBuffer *)0x0) {
12	if (param_1 != 0x8020) {
12	if (param_1 == 0x3f5c) {
12	if (*(int *)(param_1 + 0x36) != 0) {
12	uVar2 = (**(code **)(**(int **)(in_ECX + 0x3a) + 0x7c))();
12	if (param_1 != 0x7fbc) {
12	local_c = FUN_2109e5c0(pvVar5,&local_6);
12	*(int *)(in_ECX + 0x36) = (int)local_6;
12	fVar4 = (float10)FUN_2109e750(pvVar2,10);
12	fVar6 = (float10)FUN_2109e750(param_2,10);
12	fVar7 = (float10)FUN_2109e750(param_2,10);
12	(float10)*(double *)(in_ECX + 0xd));
12	0x6658);
12	if (ptVar3 == (tBuffer *)0x0) {
12	in_ECX[0x25] = 0;
12	in_ECX[0x26] = 0;
12	if (*(int *)(in_ECX + 0x23) != 0) {
12	in_ECX[0x24] = 0;
12	local_c = FUN_2109fbe0(pvVar8,&local_6);
12	*(int *)(in_ECX + 0x1b) = (int)local_6;
12	fVar4 = (float10)FUN_2109fe30(pvVar2,5);
12	sVar5 = getDevicePtr(param_1,&param_1);
12	iVar2 = *(int *)(iVar1 + 99);
12	FUN_21136440(iVar2,0x625);
12	*(undefined4 *)(iVar1 + 99) = 0;
12	sVar5 = -0x28d4;
12	uVar1 = puVar2[1];
12	local_12 = in_ECX + 0xb2;
12	local_a = in_ECX + 0x207;
12	cVar1 = '\x01';
12	local_2c = param_3;
12	double param_6,undefined4 param_7,int *param_8)
12	undefined4 uStack_98;
12	iVar4 = param_2 + -1;
12	undefined2 local_4e;
12	long local_28 [2];
12	return 0xd8d9;
12	plVar8 = &local_8;
12	return -0x2726;
12	*param_3 = 0x98bc;
12	local_2c = local_14;
12	(**(code **)*puVar2)(1);
12	puVar2[8] = 0;
12	puVar2[6] = 0;
12	local_1e = (short)param_2;
12	local_1e = local_1e + -2;
12	uVar1 = getDevicePtr(param_1,&param_1);
12	if (DAT_2120eeb0 == 0) {
12	pvVar3 = daqDevice::operator_new(0xa7);
12	return (-(uint)(iVar3 != 0) & 0x28cc) - 0x28cc;
12	int local_14 [3];
12	return local_14[0];
12	if (2 < sVar1) {
12	else if ((short)param_2 == 0) {
12	(short)*(char *)((short)uVar1 * 99 + 0x13 +
12	*(int *)(in_ECX + 0xab))));
12	sVar3 = (short)iVar4;
12	if (sVar1 != 0) break;
12	uint local_84;
12	if ((ushort)param_1 != 0) {
12	*(undefined4 *)(psVar1 + 0x11) = uVar11;
12	*(undefined4 *)((int)psVar1 + 0x4f) = 0;
12	*(undefined4 *)((int)psVar1 + 0x53) = 0;
12	*(undefined4 *)((int)psVar1 + 0x57) = 0;
12	*(undefined4 *)((int)psVar1 + 0x5b) = 0;
12	FUN_210b9da0(local_b8,local_18);
12	case 0xfff6:
12	uVar2 = (uint)param_1;
12	if (param_1 == 4) {
12	uVar4 = uVar4 | 1;
12	CONCAT22((short)((uint)&local_c >> 0x10),
12	uVar4 = param_4;
12	_memDelete(pvVar3);
12	FUN_210966c0(*(int *)(in_ECX + 0xa7));
12	uVar8 = extraout_var_00;
12	case 0xffff0000:
12	case 0xffff0001:
12	case 0xffff0002:
12	case 0xffff0003:
12	iVar4 = in_ECX[3] * 0x77 + *(int *)(in_ECX[5] + 0xaf);
12	switch(*(undefined1 *)(iVar4 + 2)) {
12	if (*(char *)(iVar4 + 0xb) == '\0') {
12	case 0xffff0004:
12	case 0xffff0007:
12	case 0xffff0008:
12	case 0xffff0009:
12	case 0xffff000e:
12	case 0xffff000f:
12	case 0xffff0011:
12	case 0xffff0015:
12	case 0xffff0016:
12	case 0xffff002a:
12	ulonglong local_10;
12	switch(in_EAX) {
12	return (1 << ((bVar2 & 7) << 2)) * in_ECX[4];
12	iVar7 = in_ECX[6];
12	(**(code **)(*piVar4 + 0x24))
12	FUN_210ab620(&local_58,0,0);
12	FUN_210ab620(&local_58,0xd2f1a9fc,0x3f50624d);
12	fVar7 = (float10)(**(code **)(*in_ECX + 0x14))(0xffff800b,param_4);
12	param_1 = (int *)((int)param_1 + 1);
12	fVar7 = (float10)(**(code **)(*in_ECX + 0x14))(0xffff8000,param_4);
12	fVar5 = (float10)(**(code **)(*in_ECX + 0x14))(0xffff8000,param_2);
12	local_24 = (double)fVar5;
12	int local_18 [3];
12	FUN_210ba110(local_18);
12	(**(code **)(*(int *)in_ECX[3] + 0x24))(in_ECX[1],in_ECX[2],in_ECX[6] + -1,param_1);
12	(**(code **)(*(int *)in_ECX[3] + 0x10))(0xffff000a,1,param_1);
12	if (in_ECX[8] != 0) {
12	(**(code **)(*(int *)in_ECX[3] + 0x10))(0xffff0009,1,param_1);
12	lVar2 = tPIMMblockReferenceBase::allocateMemory((tPIMMblockReferenceBase *)&local_8,0x24,1,8);
12	iVar4 = FUN_210a8dd0(param_1,in_ECX,param_2);
12	if ((void *)in_ECX[1] != (void *)0x0) {
12	if (in_ECX[0x12] == 0) {
12	FUN_210a8da0(*(undefined4 *)(in_ECX[0x13] + 4),0x10,
12	if (*(int *)(in_ECX + 0x20) != 0) {
12	(**(code **)(**(int **)(in_ECX + 0xc) + 0x2c))
12	iVar6 = *(int *)(in_ECX + 0x1c);
12	local_14 = (double)(fVar8 + (float10)local_14);
12	(**(code **)(*piVar6 + 0x10))(0xffff0006,1,param_1);
12	(**(code **)(**(int **)(in_ECX + 0xc) + 0x10))(0xffff0005,0,param_1);
12	iVar2 = **(int **)(in_ECX + 0x10);
12	*(undefined4 *)(iVar6 + 0xd) = 5;
12	(**(code **)(iVar7 + 0x18))(0xffff0027,piVar10);
12	*(double *)(iVar7 + 0x21) = dVar5;
12	(**(code **)(**(int **)(in_ECX + 0xc) + 0x10))(0xffff001d,0,piVar10);
12	(**(code **)(**(int **)(in_ECX + 0xc) + 0x10))(0xffff001e,0,piVar10);
12	iVar4 = piVar3[1];
12	*(undefined4 *)(iVar4 + 0xd) = *(undefined4 *)(iVar7 + 0xd);
12	iVar7 = *(int *)(in_ECX + 0x28);
12	,piVar10);
12	*(undefined4 *)(iVar7 + 0x1d) = uVar9;
12	*(undefined4 *)(iVar6 + 0xd) = 3;
12	(*(undefined4 *)(in_ECX + 4),*(undefined4 *)(in_ECX + 8),*(int *)(in_ECX + 0x1c) + 2
12	iVar7 = *(int *)(in_ECX + 0x2c);
12	for (iVar1 = 5; iVar1 != 0; iVar1 = iVar1 + -1) {
12	} while (uVar3 < uVar1);
12	iVar3 = *(int *)(in_ECX + 0x50);
12	uVar9 = *(ushort *)(pcVar7 + 1);
12	iVar10 = *piVar6;
12	uVar8 = *(undefined4 *)(in_ECX + 4);
12	*param_3 = *(double *)(*(int *)(in_ECX + 0x50) + (uint)uVar9 * 8) + *param_3;
12	(**(code **)(iVar10 + 0x24))(uVar8,uVar4,(uint)uVar9,param_4);
12	iVar7 = (*(int **)(in_ECX + 0xc))[1];
12	iVar8 = **(int **)(in_ECX + 0xc);
12	*(undefined4 *)(iVar7 + 0xd) = 0;
12	*(short *)(iVar7 + 3) = sVar1 + -1;
12	if (param_2 == 10) {
12	uVar5 = *(undefined4 *)(in_ECX + 4);
12	sVar1 = *(short *)(in_ECX + 0x18);
12	sVar2 = *(short *)(in_ECX + 0x20);
12	*(short *)(iVar7 + 3) = (sVar1 - sVar2) + 2;
12	*(undefined4 *)(iVar7 + 0xd) = param_1;
12	(**(code **)(*piVar1 + 0x10))(0xffff001f,0,param_1);
12	(**(code **)(iVar5 + 0x10))(0xffff001f,0,param_1);
12	(**(code **)(**(int **)(in_ECX + 0xc) + 0x10))(0xffff0020,0,param_1);
12	(**(code **)(*piVar1 + 0x10))(0xffff002a,1,param_1);
12	(**(code **)(iVar4 + 0x10))(0xffff001f,0,param_1);
12	pvVar7 = (void *)0x0;
12	if (pvVar7 == (void *)0x0) {
12	_memDelete(*(void **)(in_ECX + 0x3c));
12	local_10 = (double)((float10)local_10 - fVar5);
12	local_18 = (double)(fVar5 + (float10)local_18);
12	iVar2 = *param_4;
12	iVar2 = *piVar4;
12	if ((iVar4 == 0) &&
12	} while (iVar4 != 1);
12	iVar4 = (int)param_1;
12	*(undefined4 *)(in_ECX + 0x18) = 0;
12	lVar1 = tPIMMblockReferenceBase::allocateMemory((tPIMMblockReferenceBase *)&local_c,0x1e,1,8);
12	if (*(char *)(in_ECX + 0x60) == '\0') {
12	return 0xd824;
12	*(undefined4 *)(in_ECX + 0x58) = 0;
12	long lVar8;
12	undefined2 local_ec;
12	double local_6c;
12	pcVar17 = (char *)0x1;
12	pcVar15 = &stack0xffffffe8;
12	FUN_2108b920();
12	local_28 = pcVar15;
12	local_20 = (char *)(int)sVar19;
12	pcVar17 = local_28;
12	pcVar15 = (char *)(**(code **)(**(int **)(extraout_ECX + 4) + 0x6f0))();
12	iVar12 = iVar12 + 8;
12	sVar7 = FUN_210b1ff0();
12	if (param_1 == 0xc800) {
12	sVar3 = strlen(param_1);
12	} while (sVar5 < sVar2);
12	(**(code **)(*(int *)*in_ECX + 0x20))(0x99,0x91,uVar2,&local_8);
12	} while (uVar3 < 4);
12	uVar1 = in_ECX[0x17];
12	if ((uVar1 == 0) || (0x1fff < uVar1)) {
12	} while (uVar4 < param_2);
12	FUN_210b2450(param_1,param_2,param_3,param_4,param_5);
12	FUN_210b24b0();
12	char local_104 [256];
12	(**(code **)(**(int **)(in_ECX + 0x138) + 0x10))(&param_7);
12	switch(iVar6) {
12	*piVar1 = -0x2897;
12	*piVar1 = -0x2713;
12	if (local_8 == (int *)0x0) {
12	piVar4 = param_5;
12	param_1 = 0xffffffff;
12	FUN_210b4ef0(local_30,piVar1,param_4);
12	*piVar4 = iVar2;
12	FUN_210b4fe0(local_28,piVar1,param_4);
12	return 0xb;
12	return 0xe;
12	param_2 = (uint)(param_2 == 0);
12	if (local_c == 6) {
12	piVar1 = param_1 + 1;
12	iVar4 = (**(code **)(**(int **)(in_ECX + 8 + iVar4 * 4) + 0x2c))(0x10,0,piVar9);
12	iVar4 = FUN_210b5520(param_1,piVar9,1);
12	goto LAB_210b699f;
12	if (param_1 == 0x33f4) {
12	else if (param_2 == 0x42cc) {
12	if (param_1 != 0x3458) {
12	if (param_1 == 0x51a4) {
12	goto LAB_210b6607;
12	iVar5 = FUN_210b55f0(iVar4,7,*piVar9,piVar9[1],piVar9[2]);
12	FUN_210b4180(0,iVar4,piVar9,2);
12	if (param_3 != (int *)0x0) {
12	piVar3 = param_3;
12	piVar2 = piVar2 + 2;
12	*param_3 = iVar5;
12	iVar5 = iVar5 + 4;
12	if (param_1 != 8) {
12	pvVar5 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&param_2);
12	if (*(int *)(in_ECX + 0x40) != 0) {
12	_Dest = (char *)0x0;
12	undefined4 local_244;
12	undefined4 local_144;
12	undefined4 local_140;
12	undefined4 local_13c;
12	undefined4 local_138;
12	undefined4 local_134;
12	undefined4 local_130;
12	undefined4 local_12c;
12	undefined4 local_128;
12	undefined4 local_124;
12	undefined4 local_120;
12	undefined4 local_11c;
12	undefined4 local_114;
12	undefined4 local_110;
12	undefined4 local_10c;
12	undefined4 local_108;
12	undefined4 local_100;
12	undefined4 local_fc;
12	undefined4 local_f8;
12	undefined4 local_f0;
12	undefined4 local_ec;
12	undefined4 local_e8;
12	undefined4 local_e4;
12	undefined4 local_e0;
12	undefined4 local_d0;
12	undefined4 local_cc;
12	if (in_ECX[3] == 0) {
12	FUN_210b69c0(local_4a4,0x80,0x35,0,piVar8);
12	if (in_ECX[0xb] == 0) {
12	(**(code **)(*(int *)*piVar3 + 0x10))(8,local_4a4,0,piVar8);
12	iVar6 = *(int *)*piVar3;
12	iVar6 = iVar6 + 4;
12	param_3 = puVar7[-3];
12	if ((((int)param_3 < 0) || (0x40 < (int)param_3)) || (in_ECX[param_3 + 2] == 0)) {
12	param_2 = puVar7 + 2;
12	*piVar8 = -0x28cc;
12	piVar8[1] = (int)s_j__drvsrc_ALL_nidaq_e_series_wal_2120a51c;
12	uVar2 = extraout_var_01;
12	iVar1 = (**(code **)(*in_ECX + 0x2c))
12	in_ECX[3] = param_2;
12	*(undefined4 *)(in_ECX + 0x234) = 1;
12	*(undefined4 *)(in_ECX + 0x264) = 1;
12	*(undefined4 *)(in_ECX + 0x18) = uVar1;
12	iVar6 = param_2[5];
12	if (uVar1 == 2) {
12	if (pcVar9 == (char *)0x0) {
12	if (pcVar9 != (char *)0x0) {
12	local_14 = param_7;
12	local_12 = in_ECX + 0x3b;
12	local_a = in_ECX + 400;
12	local_20 = param_3;
12	goto LAB_210bcc8c;
12	FUN_21139170(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
12	sVar1 = daqDevice::Set_DAQ_Device_Info_TheVirtualThing(in_ECX,param_1,param_2,param_3);
12	if (param_2 != 0x3778) {
12	if (param_2 == 0x37dc) {
12	sVar1 = -0x28a3;
12	FUN_210bbdc0();
12	psVar2 = param_3;
12	sVar3 = *psVar2;
12	*(undefined2 *)((int)in_ECX + 0x67a) = 2;
12	*(undefined2 *)(in_ECX + 0x19e) = 3;
12	*(undefined4 *)((int)in_ECX + 0x682) = 7;
12	puVar5[1] = 0;
12	local_16 = 0;
12	local_58 = 0xb;
12	local_46 = 1;
12	in_ECX[4] = param_2;
12	*in_ECX = &PTR_FUN_211e3220;
12	*(undefined4 *)(in_ECX + 0x18) = 1;
12	FUN_210bdea0();
12	if (((iVar1 != 0) && (iVar1 != 1)) && (iVar1 != 2)) {
12	return in_ECX[1];
12	iVar1 = FUN_210be0c0();
12	return iVar1 == iVar2;
12	*(undefined4 *)((int)in_ECX + 0x42) = 0;
12	_memDelete(*(void **)(in_ECX + 0x3e));
12	*(undefined4 *)(in_ECX + 0x42) = 0;
12	int local_1c [2];
12	FUN_21163b70(local_2c);
12	*(undefined4 *)(in_ECX + 4) = *(undefined4 *)(in_ECX + 8);
12	piStack_3c = (int *)local_14;
12	FUN_21163b50();
12	FUN_210be670();
12	FUN_210bf9a0(param_1,&local_c);
12	uVar2 = FUN_210bfa10(param_1);
12	FUN_210be030(uVar2);
12	FUN_210bf7f0(param_1,&local_c);
12	*(undefined4 *)(in_ECX + 0x3c) = 1;
12	*param_1 = *param_2;
12	*in_ECX = *param_1;
12	(pvVar4 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&param_1),
12	*param_5 = local_c;
12	*piVar2 = iVar3;
12	FUN_210be8e0();
12	local_24[2] = 1;
12	undefined4 local_2c [8];
12	local_2c[0] = *(undefined4 *)(*(int *)(in_ECX + 0x20) + 0x2e);
12	local_2c[3] = param_1;
12	local_2c[1] = *(undefined4 *)(in_ECX + 0x18);
12	param_3 = pvVar7;
12	pvVar7 = param_3;
12	case 0x76:
12	*param_3 = 0x43f8;
12	if (local_14 == 0x72) {
12	uVar2 = (int)sVar1;
12	if (param_2 == 0x98) {
12	return 0xd5a5;
12	(**(code **)(**(int **)(in_ECX + 0x5c + uVar4 * 4) + 0x20))(0x3f,0x74);
12	(**(code **)(*(int *)in_ECX[uVar13 + 0x17] + 0x38))();
12	if ((&stack0x00000000 == (undefined1 *)0xfffffff4) || (-1 < (int)param_3)) {
12	if (local_6c != 0) {
12	puVar8 = (u64 *)FUN_21058950();
12	return 0xffffd5ce;
12	local_8 = 0x2a30;
12	u64 local_2c [8];
12	local_10 = puVar5[1];
12	local_14 = *puVar5;
12	iVar1 = (**(code **)(**(int **)(in_ECX + 0xb8) + 0x44))();
12	if (param_2 == 0x52) {
12	tTimerTimebasePrecise::getResolutionTimeUnit(in_ECX,param_3);
12	case 0xd3:
12	case 0xd6:
12	case 0xd7:
12	case 0xd8:
12	case 0xd9:
12	case 0xda:
12	case 0xe4:
12	case 0xe5:
12	case 0xe6:
12	*psVar2 = sVar3;
12	goto switchD_210c5510_caseD_45;
12	param_3 = (short *)((int)param_3 + 4);
12	return 0xd57f;
12	local_14 = local_24[2];
12	uVar1 = (**(code **)(*param_1 + 0x60))(param_2,param_3);
12	uVar1 = (**(code **)(*param_1 + 0x78))(param_2,param_3);
12	if ((param_6 != 0) && (param_6 != 1)) {
12	return 0xd8e2;
12	iVar3 = **(int **)(in_ECX + 0x5c);
12	if (param_2 < 0x5dcb) {
12	if (param_2 == 0x5dca) {
12	if (param_2 == 0x3f84) {
12	if (param_3 == 0x6982) {
12	iVar5 = iVar2;
12	uVar2 = (**(code **)(**(int **)(in_ECX + 100) + 0x44))();
12	(**(code **)(**(int **)(in_ECX + 0x18) + 0x5c))();
12	if (*(int *)(in_ECX + 0x1c) == 0) {
12	if (*(int *)(in_ECX + 0x24) == 0) {
12	*param_2 = '\0';
12	iVar1 = fseek(_File,0,2);
12	return 0xffffd59d;
12	float *param_11)
12	param_7 = *(uint *)(param_5 + 0x174);
12	iVar1 = (**(code **)(*local_8 + 0x58))();
12	iVar1 = (**(code **)(*local_8 + 0x5c))();
12	iVar2 = iVar3;
12	iVar2 = -0x2a3a;
12	local_8 = in_EAX;
12	(**(code **)(*param_1 + 0x5c))();
12	if (*(int *)(in_ECX + 0x7e) != 0) {
12	param_5[1] = 1;
12	uVar3 = local_18;
12	int in_stack_00000010;
12	int in_stack_00000028;
12	goto LAB_210c9bf7;
12	return 0xd640;
12	uVar5 = (**(code **)(*in_ECX + 0x3a4))
12	return -0x297d;
12	(**(code **)(*param_2 + 0x5c))();
12	bVar2 = uVar1 == 0;
12	if (!bVar2) {
12	uint uStack_c;
12	*param_1 = (double)uStack_c;
12	*(undefined4 *)(in_ECX + 0x4c) = 1;
12	uVar3 = 10;
12	uVar3 = 9;
12	uVar3 = 8;
12	bVar4 = iVar1 == 0;
12	if ((0 < iVar2) || (iVar1 = local_8, iVar2 == 0)) {
12	iVar2 = (**(code **)(*in_ECX + 0x30))();
12	if (iVar2 != 0) goto LAB_210cb651;
12	daqDevice *pdVar1;
12	*(int *)pdVar1 = 0;
12	*(undefined4 *)(in_ECX + 0x30) = 0;
12	iVar5 = iVar3;
12	tTimerTimebaseEfficient local_78 [4];
12	tTimerTimeUnit local_14;
12	if (0 < iVar7) {
12	if (local_64 != 0) {
12	FUN_210ce6e0(0x13,0);
12	if (iVar2 != 0) goto LAB_210cceea;
12	if (param_1 == 0x6c) {
12	goto LAB_210ce30d;
12	} while (local_8 < param_2);
12	return pvVar2;
12	FUN_210ce6b0(0x2f,0x52);
12	if (in_ECX[0x11] == 1) {
12	if ((iVar2 < 1) && (iVar4 = iVar3, iVar2 != 0)) {
12	iVar3 = FUN_210d1f60(param_4,&local_c,0x5e24,0x62,0x46b4,0x4e,0xffffffff,0x5a,0xffffffff,0x5a,
12	iVar3 = (**(code **)(*param_3 + 0x58))();
12	iVar3 = *param_3;
12	if (iVar1 != 0) goto LAB_210cf4c4;
12	if (*(int *)(in_ECX + 0x2c) != 0) {
12	if ((param_3 == (undefined *)piVar3[-1]) && (param_4 == (undefined *)*piVar3)) {
12	piVar3 = piVar3 + 2;
12	else if (param_2 < 0x7c9d) {
12	if (((param_2 != 0x7c9c) && (param_2 != 0x7bd4)) && (param_2 != 0x7c38)) {
12	if (param_2 == 0x7bd4) {
12	(**(code **)(*param_2 + 0x20))(0x2f,0x52);
12	(**(code **)(*param_2 + 0x20))(0x2f,0x71);
12	(**(code **)(*piVar1 + 0x20))(0x69,param_2);
12	FUN_210d0550(0);
12	FUN_210d05f0(0);
12	*(uint *)(in_ECX + 0x38) = uVar1;
12	FUN_210cfba0(0x3a,uVar1);
12	FUN_210cfc20(0x601,0);
12	FUN_210cfc20(0x600,param_1);
12	FUN_210cfc20(0x901,0);
12	else if (param_2 == 3) {
12	uVar2 = 0xe;
12	FUN_210cfc20(0x300,uVar1);
12	} while (uVar5 < 8);
12	uVar2 = FUN_210cfc80(0x300);
12	bVar5 = bVar4;
12	uVar1 = uVar1 >> 1;
12	if (uVar2 == 1) {
12	FUN_210d13e0(4,&local_8);
12	if (*(int *)((int)in_ECX + 0x3a) != 0) {
12	if (*(int *)((int)in_ECX + 0x36) != 0) {
12	if (local_18 == 1) {
12	} while (uVar6 < uVar4);
12	FUN_210d2a20();
12	uVar2 = (**(code **)(iVar3 + 0x7c))(&local_8);
12	uVar4 = uVar6;
12	uVar6 = iVar3 - 1;
12	if (uVar4 <= uVar6) {
12	puVar5 = (undefined4 *)(in_ECX + 0x12 + uVar4 * 4);
12	case 0x75:
12	iVar1 = in_ECX + iVar3 * 0x48;
12	*(undefined4 *)(iVar1 + 0x1e6) = 0x58;
12	*(int *)(iVar1 + 0x1ea) = local_8;
12	undefined1 local_44 [8];
12	puVar4 = param_2;
12	local_c = (int)sVar5;
12	local_1c);
12	local_8 = -0x2a31;
12	plVar13 = &local_8;
12	if ((double)CONCAT44(param_7,param_6) == 0.0) {
12	if (0 < *(short *)(in_ECX + 0x3a)) {
12	uVar8 = uVar7;
12	for (; param_2 != 0; param_2 = param_2 + -1) {
12	if (param_1 < -1) {
12	in_ECX[0x1f] = 0;
12	if (*(undefined4 **)(in_ECX + 0x40) != (undefined4 *)0x0) {
12	(**(code **)**(undefined4 **)(in_ECX + 0x40))(1);
12	case 0x59:
12	if (param_4 < 0x21) {
12	return (uint)uVar1;
12	if (param_2 == (undefined4 *)0x0) {
12	uVar1 = (**(code **)(**(int **)(*(int *)(in_ECX + 0x18) + param_1 * 4) + 0xb0))
12	iVar3 = param_1 * 4;
12	iVar4 = -0x28cc;
12	iVar1 = **(int **)(*(int *)(this + 0x18) + uVar4 * 4);
12	(**(code **)(iVar1 + 0x20))(0x9a,0xbb,uVar3);
12	(mdsSimpDIGInterpreter *this,short param_1,short param_2,short param_3)
12	if ((-1 < param_2) && (param_2 < *(short *)(this + 0xc))) {
12	(**(code **)(iVar1 + 0x40))(uVar2);
12	iVar1 = **(int **)(*(int *)(this + 0x18) + iVar3);
12	pvVar4 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&param_3);
12	puVar1[0xd] = 0x66;
12	puVar1[0xb] = 0x66;
12	puVar1[1] = 1;
12	(**(code **)(**(int **)(*(int *)(in_ECX + 0x3e) + iVar3 * 4) + 0x24))
12	uVar3 = (uint)(ushort)(param_1 - 1);
12	if ((param_1 < 1) || (2 < param_1)) {
12	if (-1 < *piVar2) {
12	param_2[1] = 0x3ff00000;
12	uint local_78;
12	tTimerTimebaseEfficient local_54 [4];
12	u64 local_20 [8];
12	local_c = puVar8[1];
12	local_10 = *puVar8;
12	else if (param_2 == 0xc35a) {
12	else if (param_2 == 0xc364) {
12	if (local_40 == 0) {
12	uVar10 = FUN_21082330();
12	long local_34 [2];
12	long *local_8;
12	if (*(int *)(iVar3 + 0x34) != 0xa7) {
12	iVar4 = *(int *)(in_ECX + 0x20) + iVar5;
12	piVar2 = param_4;
12	*param_4 = (int)sVar3;
12	goto LAB_210d9f94;
12	*piVar2 = (int)sVar3;
12	local_34 = 0x66bc;
12	sVar3 = _STCMgrControlUser_12(*(undefined4 *)(in_ECX + 0x14),0x2003,&local_38);
12	puVar1[1] = 0;
12	tBufferFactory local_28 [8];
12	NIBS100::tBufferFactory::tBufferFactory(local_10,*(ulong *)(in_ECX + 0x14),&local_8);
12	pdVar4 = pdVar4 + 4;
12	(**(code **)(iVar2 + 0x20))(0x99,0x90,uVar4);
12	(**(code **)(iVar2 + 0x20))(0x99,0x91,uVar4);
12	tMDSMiniDriver **pptVar1;
12	if (*pptVar1 == (tMDSMiniDriver *)0x0) {
12	*(undefined4 *)(in_ECX + 0x6c) = 0;
12	*(undefined4 *)(in_ECX + 0x50) = 1;
12	*(undefined4 *)(in_ECX + 0x54) = 0;
12	case 0xd4:
12	if (param_4 == 0x98bc) {
12	if (param_4 == 0x69aa) {
12	if (param_4 == 0x3368) {
12	(**(code **)(iVar3 + 0x44))(0xb,uVar1);
12	iVar3 = **(int **)(in_ECX + 0x20e);
12	iVar1 = **(int **)(in_ECX + 0x202 + param_1 * 4);
12	uVar5 = uVar2;
12	if (local_8 != 0) goto LAB_210dd7c8;
12	uVar7 = (**(code **)(param_5 + 0x7c))(&local_8);
12	iVar5 = (**(code **)(iVar5 + 0x54))(*(undefined4 *)((int)in_ECX + 0x1ce),0,uVar7);
12	(**(code **)(iVar5 + 0x60))(*(undefined4 *)((int)in_ECX + 0x1d2),uVar7);
12	(**(code **)(iVar5 + 0x4c))(uVar7);
12	(**(code **)(iVar5 + 0x20))(0x29,0x3c,uVar7);
12	if (param_1 == 0x69dc) {
12	return 0xffffd686;
12	(**(code **)(iVar5 + 0x20))(0x2f,0x52,uVar3);
12	if (param_1 == 0x69c8) {
12	uVar3 = (**(code **)(**(int **)(in_ECX + 0x1f6) + 0x7c))(&local_8);
12	goto LAB_210de87e;
12	iVar5 = 6;
12	(**(code **)(iVar5 + 0x20))(0x2f,0x71,uVar3);
12	uVar6 = 5;
12	uVar5 = (**(code **)(iVar1 + 0x7c))(&local_8);
12	if (param_5 == (undefined4 *)0x0) {
12	if (param_2 == 0x3714) {
12	short *param_5)
12	(pvVar4 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_14),
12	*(undefined2 *)(in_ECX + 0x1e) = 0;
12	case 0xe8:
12	case 0xed:
12	iVar1 = -0x2733;
12	case 0x148:
12	long *plVar7;
12	puVar4[2] = 0;
12	puVar4[0xd] = 0;
12	puVar4[0xe] = 0;
12	uVar2 = in_ECX[1];
12	goto switchD_210e0399_caseD_43f9;
12	param_4 = local_10;
12	if (param_4 != 0xc620) {
12	return -0x278d;
12	undefined1 local_30 [8];
12	goto LAB_210e1fe8;
12	uVar3 = *param_1;
12	*param_1 = uVar3;
12	case 0x3b2e:
12	case 0x3b38:
12	case 0x3b3d:
12	case 0x3b42:
12	case 0x3b47:
12	case 0x3b4c:
12	case 0xc9ae:
12	case 0xc9b8:
12	case 0xc9c2:
12	case 0xc9d6:
12	case 0xc9e0:
12	if ((param_4 != 0x6658) && (param_4 != 0x98bc)) {
12	case 0xca26:
12	case 0xc95e:
12	case 0xc396:
12	case 0xc3a0:
12	case 0xc3aa:
12	case 0xc3b4:
12	goto switchD_210e390b_caseD_c652;
12	goto LAB_210e39e1;
12	if (param_4 == 0x5e24) {
12	else if (param_4 == 0x46b4) {
12	if (param_4 != 0xc97c) {
12	iVar3 = param_4 - 0x7b70;
12	iVar3 = param_4 - 0x7c9c;
12	case 0xc59e:
12	case 0xc5e4:
12	case 0xc594:
12	puVar5 = param_8;
12	uVar4 = *puVar5;
12	in_ECX[(local_c * 5 + 5) * 4] = 0;
12	piVar3 = in_ECX + local_c * 0x14;
12	if (in_ECX[local_c * 0x14 + 0xc] == 0) {
12	(**(code **)(*piVar2 + 0x20))(0xce,0x115,*(undefined4 *)(in_ECX + 0x3dc),&local_8);
12	(**(code **)(*piVar2 + 0x20))(0xe3,0x115,*(undefined4 *)(in_ECX + 0x3dc),&local_8);
12	(**(code **)(*piVar2 + 0x20))(0x112,0xa7,*(undefined4 *)(in_ECX + 0x3dc),&local_8);
12	*(undefined4 *)(param_2 * 0x50 + 0x30 + in_ECX) = 0x98bc;
12	(**(code **)(iVar3 + 0x20))(uVar5,uVar6,uVar4,&local_8);
12	(**(code **)(*piVar2 + 0x20))(0xd0,0x11a,*(undefined4 *)(in_ECX + 0x3dc),&local_8);
12	(**(code **)(*piVar2 + 0x20))(0xcf,0x118,*(undefined4 *)(in_ECX + 0x3dc),&local_8);
12	(**(code **)(*piVar2 + 0x24))(0xd5,0,*(undefined4 *)(in_ECX + 0x3dc),&local_8);
12	if (local_8 != 0) goto LAB_210e67f1;
12	*param_4 = iVar5;
12	if (local_10 == 0xa7) {
12	if (local_10 == 0x66) {
12	local_8 = local_18;
12	puVar3[1] = 1;
12	return 0xffffd88f;
12	if (0 < (short)in_ECX[5]) {
12	FUN_210e79a0();
12	FUN_210e7b50();
12	undefined4 *local_2c;
12	long local_14;
12	local_1c = in_ECX;
12	*param_1 = -0x2a3a;
12	pvVar12 = local_8;
12	if (param_1 != 1) {
12	local_8 = -0x2a5a;
12	return 0xffffd825;
12	iVar3 = *(int *)(iVar1 + 8);
12	return -0x27db;
12	char *_Str2;
12	_Str2 = param_1;
12	case 0x4470:
12	goto switchD_210ea366_caseD_43d1;
12	case 0x43dc:
12	goto switchD_210ea366_caseD_43e0;
12	goto switchD_210ea384_caseD_4416;
12	iVar4 = FUN_210ee960(param_1,param_2,param_3,0x6d7e,0);
12	uVar3 = 0xc648;
12	goto LAB_210eac04;
12	local_8 = (**(code **)(*in_ECX + 0x14))(param_3,&local_c,local_10,&param_2);
12	local_c = 0x122;
12	(**(code **)(*piVar1 + 0x20))(0x82,local_c,*(undefined4 *)((int)in_ECX + 0x16),&local_8);
12	(**(code **)(*piVar1 + 0x20))(0x9a,0xea,*(undefined4 *)((int)in_ECX + 0x16),&local_8);
12	goto LAB_210eba2f;
12	*param_2 = 0x60;
12	*param_4 = 0x17;
12	*param_4 = 0x12;
12	*param_4 = 0x11;
12	*param_4 = 0x13;
12	*param_4 = 0x15;
12	*param_4 = 0x16;
12	*param_2 = 0x188;
12	goto switchD_210efc65_caseD_33f4;
12	_memDelete(*(void **)(in_ECX + 0xc));
12	*puVar10 = 0;
12	pdVar4 = (double *)in_ECX[1];
12	if (0 < (short)uVar1) {
12	iVar6 = 2;
12	double dVar18;
12	undefined4 uStack_90;
12	double *pdVar17;
12	dVar2 = *local_c;
12	local_c = local_c + local_14;
12	undefined4 *puVar18;
12	undefined4 uVar19;
12	*puVar17 = 0;
12	if (2 < param_2) {
12	*(int *)(in_ECX + 0x6c) = iVar26;
12	pdVar21 = *(double **)(in_ECX + 0xac);
12	return 7;
12	local_c = (double *)0x0;
12	pdVar5 = local_c;
12	dVar3 = *pdVar5;
12	*pdVar6 = (double)iVar1;
12	lVar2 = tPIMMblockReferenceBase::allocateMemory((tPIMMblockReferenceBase *)&local_14,0x8000,0,8);
12	local_1c = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_14);
12	for (iVar3 = 0x2000; iVar3 != 0; iVar3 = iVar3 + -1) {
12	iVar3 = 0x1000;
12	return -0x29b8;
12	(**(code **)(**(int **)(in_ECX + 0x163) + 0x44))(0xf,*(undefined4 *)(in_ECX + 0x14f),&local_8)
12	iVar3 = iVar3 + 0x5e;
12	(**(code **)(**(int **)(in_ECX + 0x157) + 0x40))(*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	(**(code **)(**(int **)(in_ECX + 0x167) + 0x24))
12	(**(code **)(*piVar2 + 0x20))(0x2f,0x71,*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	*(undefined4 *)(in_ECX + 0x101) = 0x67;
12	(**(code **)(*piVar3 + 0x40))(*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	(**(code **)(*piVar3 + 0x20))
12	goto LAB_210f3d97;
12	if (uVar2 < uVar1) {
12	pvVar3 = tMemBlockReferenceBase::getPointer(this,&local_8);
12	iVar2 = **(int **)(in_ECX + 0x15b);
12	(**(code **)(**(int **)(in_ECX + 0x163) + 0x44))(0xf,*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	NIBS100::tBuffer::~tBuffer(ptVar2);
12	psStack00000004 = psStack00000004 + 1;
12	void *local_18;
12	local_10 = (void *)0x0;
12	(**(code **)(**(int **)((int)in_ECX + 0x163) + 0x24))();
12	*(undefined4 *)((int)in_ECX + 0x101) = 0x67;
12	*(undefined4 *)((int)in_ECX + 0x1ed) = 0;
12	*(undefined4 *)((int)in_ECX + 0x1e9) = 0;
12	*(undefined4 *)((int)in_ECX + 0x2c1) = 0;
12	*(undefined4 *)((int)in_ECX + 0x1f5) = 0;
12	*(undefined4 *)((int)in_ECX + 0x1f1) = 0;
12	*(undefined4 *)((int)in_ECX + 0x1f9) = 0;
12	u64 *this_00;
12	tTimerTimeUnit local_18;
12	(0xa4,0xab,*(undefined4 *)((int)in_ECX + 0x14f),&local_8);
12	tTimerTimebaseEfficient::getResolutionTimeUnit(this,(long *)&param_1);
12	if (iStack_8 == 0) {
12	(**(code **)(*piVar1 + 0x44))(8,*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	iVar1 = **(int **)(in_ECX + 0x153);
12	*puVar3 = *puVar3 | (uint)param_2;
12	param_1 = (double *)((int)param_1 + 4);
12	if (lVar5 == 0) {
12	local_1c = (double *)((int)local_1c + param_3);
12	local_34 = local_34 - 1;
12	} while (uVar15 != 0);
12	param_5 == (double *)0x0)) {
12	iVar11 = param_3 - 1;
12	if (-1 < iVar11) {
12	param_5 = (double *)((int)puVar6 - (int)puVar17);
12	pdVar9 = (double *)(puVar17 + iVar11 * 2);
12	if ((int)uVar15 < (int)param_3) {
12	param_6 = pdVar9 + 1;
12	dVar2 = *param_9;
12	dVar3 = *param_6;
12	dVar1 = dVar2 * dVar3 + dVar1;
12	pdVar9 = pdVar9 + -1;
12	dVar17 = 0.0;
12	if ((int)local_10 < param_2) {
12	pdVar12 = (double *)((int)pdVar12 + -1);
12	} while (pdVar12 != (double *)0x0);
12	local_44 = -local_44;
12	dVar18 = *pdVar8;
12	pdVar3 = local_24;
12	if (-1 < (int)local_20) {
12	local_1c = (double *)((int)local_20 * (int)param_3);
12	local_14 = (double *)((int)local_14 + -1);
12	pdVar14 = pdVar14 + (int)param_3;
12	if ((int)pdVar3 < param_2) {
12	iVar15 = param_2 - (int)pdVar3;
12	local_4c = 1.0;
12	local_28 = (double *)((int)local_18 - param_4);
12	dVar2 = *pdVar5;
12	iVar7 = iVar1;
12	int iStack_14;
12	iVar7 = iVar11;
12	pdVar6 = pdVar6 + param_3;
12	iVar10 = iVar11;
12	dVar4 = *pdVar8;
12	pdVar2 = pdVar3;
12	pdVar3 = pdVar3 + param_2;
12	return 0xffffb1b7;
12	*(int *)(in_ECX + 0x26d) = iVar26;
12	pdVar21 = *(double **)(in_ECX + 0x2ad);
12	if (*(int *)((int)in_ECX + 0x2c5) != 0) {
12	FUN_21116d00();
12	if ((iVar1 == 0) && (local_8 == 0)) {
12	bVar3 = *(int *)(in_ECX + 0xc) != 0x4a;
12	(**(code **)(*piVar1 + 0x44))(3,*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	(**(code **)(*piVar1 + 0x44))(5,*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	(0x29,uVar2,*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	LSTATUS LVar1;
12	if (LVar1 != 0) {
12	local_1c = 0x80;
12	if (local_8 != 0) goto LAB_210fbcf8;
12	(**(code **)(**(int **)((int)in_ECX + 0x163) + 0x24))
12	(**(code **)(**(int **)((int)in_ECX + 0x15b) + 0x44))
12	uVar2 = (**(code **)(*in_ECX + 0x6a8))(local_8);
12	*param_2 = *(undefined4 *)(in_ECX + 0x3d);
12	puVar5 = *(undefined4 **)((int)in_ECX + 0x1ad);
12	undefined1 local_70 [4];
12	local_68 = (double *)0x0;
12	local_3c = (int *)0x0;
12	sVar2 = (**(code **)(*extraout_ECX + 0x400))();
12	} while (uVar18 < 0x149);
12	uVar18 = (uint)local_30._4_4_;
12	iVar6 = -0x4005bff5;
12	} while (uVar18 < 2);
12	((tTimerTimeWasterSleep *)(iVar6 + 0x24),(long *)&param_2);
12	*(undefined4 *)(iVar6 + 0x2e) = 0x26;
12	*(undefined4 *)(iVar6 + 0x46) = 0xab;
12	puVar25 = &stack0xfffffff8;
12	if ((iVar6 == 0) && (iVar6 = FUN_210f4e70(), iVar6 == 0)) {
12	tMemBlockReferenceBase::getPointer
12	piVar10 = tMemBlockReferenceBase::getPointer
12	local_30._4_4_ = (double *)0xb;
12	local_30._0_4_ = 0x99;
12	iVar6 = FUN_210f5090();
12	iVar6 = FUN_210f4950();
12	iVar6 = 0x400;
12	pdVar11 = (double *)0x0;
12	iVar6 = 0x1000;
12	pdVar19 = pdVar12;
12	pdVar19 = (double *)0x0;
12	if (local_48 != (double *)0x0) {
12	_memDelete(local_48);
12	uVar27 = 0;
12	pdVar12 = pdVar11;
12	_memDelete(*(void **)pdVar11);
12	pdVar11 = (double *)((int)pdVar11 + 4);
12	param_2 = (tBuffer *)((int)param_2 - 1);
12	iVar7 = 0x23;
12	if (*(int *)((int)extraout_ECX + 0x1e1) != 0) {
12	((tMemBlockReferenceBase *)((int)extraout_ECX + 0x1c9),(long *)&stack0xfffffff8);
12	return 0xbffa400d;
12	puStackY_34 = (undefined1 *)0x1ff4;
12	local_30 = sin(local_54);
12	lVar3 = tPIMMblockReferenceBase::allocateMemory((tPIMMblockReferenceBase *)&param_2,0x38,0,8);
12	*(void **)((int)extraout_ECX + 0x1d5) = pvVar4;
12	iVar6 = -0x2713;
12	asin(dVar22);
12	puVar25 = (undefined1 *)ftol();
12	puVar25 = (undefined1 *)0x1ff4;
12	puStackY_34 = puVar25;
12	dVar23 = sin(dVar22);
12	iVar7 = (int)param_2 * 8;
12	*(double *)(iVar7 + *(int *)((int)extraout_ECX + 0x1d5)) =
12	(dVar23 * local_30) / (double)CONCAT44(puStackY_34,local_38);
12	iVar9 = SUB84(dVar22,0);
12	*(undefined4 *)(iVar7 + iVar9) = uVar13;
12	piVar10 = (int *)0xac;
12	param_2 = (tBuffer *)0x7;
12	*puVar17 = uVar13;
12	puVar17 = puVar17 + 2;
12	FUN_210f6aa0();
12	iVar6 = 0xe;
12	piVar10[0x1c] = *piVar10 + local_7c;
12	piVar10 = piVar10 + 2;
12	_memDelete(*(void **)((int)extraout_ECX + 0x1d5));
12	*(undefined4 *)((int)extraout_ECX + 0x1d5) = 0;
12	NIBS100::tBufferFactory::tBufferFactory
12	ptVar15 = NIBS100::tBufferFactory::makeBuffer
12	*(tBuffer **)((int)extraout_ECX + 0x1d9) = ptVar15;
12	iVar6 = (**(code **)(**(int **)((int)extraout_ECX + 0x163) + 0x54))();
12	*(int *)((int)extraout_ECX + 0x1e1) = iVar6;
12	(**(code **)(**(int **)((int)extraout_ECX + 0x163) + 0x60))();
12	goto LAB_210feb93;
12	goto LAB_210febb7;
12	goto LAB_210febdb;
12	goto LAB_210febfc;
12	goto LAB_210fec1d;
12	goto LAB_210fec3e;
12	case (tBuffer *)0x7:
12	case (tBuffer *)0x8:
12	case (tBuffer *)0x9:
12	case (tBuffer *)0xa:
12	case (tBuffer *)0xb:
12	case (tBuffer *)0xc:
12	case (tBuffer *)0xd:
12	case (tBuffer *)0xe:
12	case (tBuffer *)0xf:
12	case (tBuffer *)0x10:
12	case (tBuffer *)0x11:
12	case (tBuffer *)0x12:
12	case (tBuffer *)0x13:
12	case (tBuffer *)0x14:
12	case (tBuffer *)0x15:
12	case (tBuffer *)0x16:
12	case (tBuffer *)0x17:
12	case (tBuffer *)0x18:
12	ptVar20 = (tMemBlockReferenceBase *)0x3f;
12	case (tBuffer *)0x19:
12	ptVar20 = (tMemBlockReferenceBase *)0x42;
12	case (tBuffer *)0x1a:
12	ptVar20 = (tMemBlockReferenceBase *)0x45;
12	case (tBuffer *)0x1b:
12	ptVar20 = (tMemBlockReferenceBase *)&DAT_00000040;
12	puVar26 = local_70;
12	*(undefined4 *)(puVar26 + (int)param_2 * 8 + 4) = uVar13;
12	tMemBlockReferenceBase::free(this,(long *)&stack0xfffffff8);
12	ptVar20 = this;
12	goto LAB_210ff78f;
12	goto LAB_210ff7b3;
12	goto LAB_210ff7d7;
12	goto LAB_210ff7f8;
12	goto LAB_210ff819;
12	goto LAB_210ff83a;
12	(**(code **)(*piVar2 + 0x20))(0x2f,0x71,*(undefined4 *)((int)in_ECX + 0x14f),&local_8);
12	if (*(uint *)(in_ECX + 0x2c5) <= uVar1) {
12	case 0x144:
12	case 0x104:
12	case 0x143:
12	case 0x139:
12	iVar5 = *plVar2;
12	switch(pvVar8) {
12	case (void *)0x14d:
12	case (void *)0x14e:
12	sVar1 = *(short *)(in_ECX + 0x2c);
12	piVar1 = (int *)(**(code **)(**(int **)(in_ECX + 0x34) + 0x14))(0xe,0,&local_8);
12	(**(code **)(*piVar1 + 0x40))(0,&local_8);
12	FUN_21101060();
12	*in_ECX = &PTR_FUN_211e81b8;
12	(**(code **)(*(int *)in_ECX[1] + 0x38))(0x1b,0,local_8,&param_3);
12	(**(code **)(*in_ECX + 0x28))(param_1,param_2);
12	(**(code **)(**(int **)(in_ECX + 8) + 0x20))(0x1ef,0x21e,local_8,piVar1);
12	(**(code **)(**(int **)(in_ECX + 8) + 0x44))(0x19,local_8,piVar1);
12	if (*piVar4 < 0) {
12	(**(code **)(*(int *)in_ECX[1] + 0x38))(0x1b,0,param_3,&local_8);
12	(**(code **)(**(int **)(in_ECX + 8) + 0x30))();
12	(**(code **)(**(int **)(in_ECX + 8) + 0x44))();
12	*param_6 = iVar3;
12	switch(*(undefined2 *)(in_ECX + 0xc3)) {
12	(*(tMemBlockReferenceBase **)(in_ECX + 0xf9),(long *)0x0);
12	local_14 = local_2c;
12	if ((*(int *)(in_ECX + 0x113) != 0) || (*(int *)(in_ECX + 0x10f) != -1)) {
12	*(undefined4 *)(this + 0x10) = 0;
12	*(undefined4 *)(this + 0xc) = 0;
12	if (((int)local_8 < 0) || ((local_8 != 0 && (-1 < (int)uVar1)))) {
12	u64 local_28 [8];
12	param_6._2_2_ = -1;
12	param_6._2_2_ = (short)param_6 >> 0xf;
12	local_8 = 0xffffd75d;
12	if (param_3 == 0.0) {
12	float *pfVar7;
12	pfVar7 = pfVar7 + 1;
12	case 0x107:
12	case 0x109:
12	case 0x10c:
12	uVar6 = param_3[1];
12	uVar1 = param_3[2];
12	goto LAB_21108642;
12	sVar4 = (short)local_24;
12	(**(code **)(*piVar4 + 0x1c))
12	if (local_8 != 0) goto LAB_21109b0b;
12	*(undefined4 *)this = 0;
12	uVar3 = uVar4 & 0xffff;
12	*(undefined4 *)(in_ECX + 0xf1) = 0;
12	local_14[1] = 0;
12	if (*(short *)(param_4 + 0x8a) == 2) {
12	if (*(short *)(param_4 + 0x66) != 0) {
12	local_c = (int *)0x1;
12	goto LAB_2110a384;
12	&local_1c,&local_18,&param_8);
12	sVar2 = FUN_210077d0(iVar1,local_1c,local_18,param_8);
12	*(undefined2 *)(in_ECX + 0xbf) = 1;
12	if (piVar5 == (int *)0x0) {
12	*param_7 = iVar1;
12	float fVar12;
12	iVar9 = ftol();
12	goto switchD_2110ae55_default;
12	tTimerTimebaseEfficient local_48 [4];
12	tTimerTimeWasterSpin local_24 [4];
12	long local_1c [2];
12	u64::u64((u64 *)&stack0xffffff9c,param_1);
12	uVar1 = tTimerTimebaseEfficient::getResolutionValue(local_48,(long *)local_14);
12	puVar8 = &param_1;
12	uVar2 = tTimerTimebaseEfficient::getCounterValue(local_48,local_1c);
12	FUN_21082560(&uStack_6c,uVar2,puVar8);
12	FUN_21082350(&local_c,uVar1);
12	tVar3 = tTimerTimeWasterSpin::getResolutionTimeUnit(local_24,(long *)&param_1);
12	while (-1 < (int)param_1) {
12	piVar7 = (int *)&param_1;
12	puVar4 = (u64 *)FUN_21082700();
12	u64::operator=(local_14,puVar4);
12	if (((piVar7 != (int *)0x0) && (*piVar7 < 0)) || (iVar5 = FUN_21058a50(), iVar5 == 0)) {
12	if (-1 < (int)param_1) {
12	uVar6 = tTimerTimeWasterSpin::canSleepNow(local_24,(long *)&param_1);
12	FUN_21104f70(&uStack_6c,tVar3,&param_1);
12	tTimerTimeWasterSpin::sleep(local_24);
12	puVar4 = (u64 *)FUN_21082830();
12	u64::operator=((u64 *)&local_c,puVar4);
12	u64::operator+=((u64 *)&local_3c,puVar4);
12	*param_7 = -0x28cc;
12	uVar6 = *(uint *)(in_ECX + 1);
12	iVar9 = -0x2a3a;
12	FUN_2110cf30();
12	FUN_210d4990(1,0);
12	} while (uVar3 < uVar5);
12	undefined4 param_5,undefined4 param_6,undefined2 *param_7)
12	} while (uVar8 < uVar6);
12	} while (uVar7 < *in_ECX);
12	iVar8 = *(int *)(in_ECX + 9);
12	((tPIMMblockReferenceBase *)&param_2,*in_ECX << 2,1,8);
12	(**(code **)(**(int **)(in_ECX + 0x40) + 0x24))
12	(**(code **)(**(int **)(in_ECX + 0x40) + 0x20))
12	piVar1 = *(int **)(*(int *)(in_ECX + 0x38) + iVar3);
12	uVar2 = *(undefined4 *)(*(int *)(in_ECX + 0x3c) + iVar3);
12	} while (uVar1 < *in_ECX);
12	(**(code **)(*(int *)in_ECX[0x16] + 0x1c))
12	(**(code **)(*(int *)in_ECX[0x16] + 0x24))
12	(**(code **)(*(int *)in_ECX[0x16] + 0x20))(0x99,0x1da,in_ECX[0x17],&local_8);
12	if (0 < local_14) {
12	u64 local_34 [8];
12	plVar8 = (long *)0xfffffff0;
12	*plVar8 = lVar6;
12	undefined4 param_5,undefined4 param_6,undefined4 param_7,int *param_8)
12	sVar1 = (**(code **)(**(int **)(in_ECX + 0x272) + 0x56c))
12	pvVar5 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_8);
12	FUN_21119120();
12	local_10 = param_1 * 0x1c;
12	(**(code **)(*piVar1 + 0x20))(0x25,0x26,*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	(**(code **)(*piVar1 + 0x20))(0x9a,0xbb,*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	(**(code **)(**(int **)(in_ECX + 0x153) + 4))(0);
12	(**(code **)(*piVar1 + 0x20))(0x2f,0x52,*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	(**(code **)**(undefined4 **)(in_ECX + 0x153))(&local_8);
12	(**(code **)(**(int **)(in_ECX + 0x15f) + 0x40))(*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	(0xa4,0xaa,*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	(**(code **)(**(int **)(in_ECX + 0x1b7) + 0x20))
12	(0x25,0x26,*(undefined4 *)((int)in_ECX + 0x14f),&local_8);
12	piVar2 = *(int **)(*(int *)((int)in_ECX + 0x31) + param_1 * 0x5e);
12	(0x138,*(undefined4 *)((int)in_ECX + 0x1fb),*(undefined4 *)((int)in_ECX + 0x14f),
12	pcVar4 = (char *)(**(code **)(*in_ECX + 0x6cc))();
12	goto LAB_21112549;
12	uint *puVar11;
12	local_44 = (double)fVar14;
12	local_1c = (undefined1 *)(int)*(char *)(uVar10 + iVar4);
12	local_3c = 0.0;
12	*(int *)((int)in_ECX + 0x1fb) = *(int *)((int)in_ECX + 0x1fb) - (int)local_18;
12	(**(code **)(*piVar1 + 0x20))();
12	if (*(int *)(local_c + 0x14) != 0) {
12	ptVar12 = local_20;
12	*(undefined4 *)((int)in_ECX + 0x14f),&local_8);
12	local_14 = (int)*(char *)(uVar6 + iVar4);
12	iVar4 = *piVar2;
12	if (*(int *)(in_ECX + 0x173) != 0) {
12	((float10)local_28 * (float10)3932.0) /
12	((float10)local_30 - (float10)local_28);
12	*(undefined2 *)(iVar2 + 4) = 0;
12	iVar3 = local_18;
12	(**(code **)(*piVar5 + 0x40))(*(undefined4 *)((int)in_ECX + 0x14f),&local_8);
12	(**(code **)(*piVar2 + 0x24))();
12	*puVar8 = *puVar7;
12	puVar8[2] = uVar3;
12	puVar8[1] = uVar2;
12	puVar8 = puVar8 + 4;
12	(**(code **)(**(int **)((int)in_ECX + 0x15f) + 0x40))
12	(**(code **)(**(int **)(*(int *)(in_ECX + 0x31) + (param_1 & 0xff) * 0x5e) + 0x4c))
12	(0x98,0x220,*(undefined4 *)(in_ECX + 0x14f),&local_8);
12	daqDevice::Get_DAQ_Device_Info_TheVirtualThing(in_ECX,param_1,param_2,param_3);
12	uint local_b0;
12	iVar2 = *(int *)(in_ECX + 0x31);
12	if (param_2 == 20.0) {
12	if (param_2 == 10.0) {
12	iVar1 = strcmp(param_2,s_VAL_NO_SOURCE_2120b454);
12	iVar1 = strcmp(param_2,s_VAL_RTSI_0_2120b448);
12	iVar1 = strcmp(param_2,s_VAL_RTSI_1_2120b43c);
12	iVar1 = strcmp(param_2,s_VAL_RTSI_2_2120b430);
12	iVar1 = strcmp(param_2,s_VAL_RTSI_3_2120b424);
12	iVar1 = strcmp(param_2,s_VAL_RTSI_4_2120b418);
12	iVar1 = strcmp(param_2,s_VAL_RTSI_5_2120b40c);
12	iVar1 = strcmp(param_2,s_VAL_RTSI_6_2120b400);
12	if ((iVar1 != 0) &&
12	iVar7 = *(int *)((int)in_ECX + 0x173);
12	local_c = (u64 *)0x0;
12	*(undefined4 *)(in_ECX + 0x18b) = 0;
12	tTimerTimeWasterSleep *this;
12	this = (tTimerTimeWasterSleep *)(this_00 + 0x24);
12	tTimerTimeWasterSleep::sleep(this);
12	uVar2 = 0xf;
12	uVar2 = 0x1b;
12	param_7,param_8,param_9,param_10);
12	bVar6 = *_Src;
12	_Src = _Src + 1;
12	*param_15 = *param_15 * 0.00390625;
12	*param_15 = *param_15 * 5.9604644775390625e-08;
12	_Dst = _Dst + 2;
12	pdVar10 = (double *)((int)pdVar10 + 1);
12	pdVar10 = (double *)((int)pdVar10 + 2);
12	pdVar10 = (double *)((int)pdVar10 + 4);
12	*param_15 = *param_15 * 256.0;
12	pbVar9 = _Src + 2;
12	*param_15 = *param_15 * 16777216.0;
12	*(short *)_Dst = (short)((uint)*(int *)_Src >> 0x10);
12	if (*(uint *)(in_ECX + 0x173) <= uVar1) {
12	(**(code **)(**(int **)((int)in_ECX + 0x15b) + 0x34))
12	(**(code **)(*in_ECX + 0x6c8))(param_3);
12	undefined1 local_54 [8];
12	return -0x4005bfe8;
12	puVar8 = param_4;
12	puVar1[1] = param_7;
12	*param_3 = (short)local_c;
12	FUN_210d7110(param_2,param_3,param_4);
12	FUN_210d7050(param_2,param_3);
12	FUN_210d7210(param_2,param_3,param_4);
12	FUN_210d7190(param_2,param_3);
12	(0x1e,&param_1);
12	(0x1e,&param_2);
12	(**(code **)(**(int **)(in_ECX + 0x4c) + 0x18))(7,param_1);
12	(**(code **)(**(int **)(in_ECX + 0x4c) + 0x18))(0x32,param_2);
12	uVar3 = 0xd8e4;
12	if (sVar3 < *(short *)(in_ECX + 0x34)) {
12	if ((int)*(short *)(in_ECX + 0x34) + (int)*(short *)(in_ECX + 0x32) <= (int)sVar3) {
12	*(undefined2 *)(in_ECX + 0x30) = 6;
12	*(undefined2 *)(in_ECX + 0x30) = 2;
12	local_4e = 0;
12	} while (sVar6 < *psVar5);
12	if (local_8 == -0x4005fff4) {
12	if (*piVar6 != 0) {
12	piVar6 = piVar6 + 2;
12	if (*(int *)(iVar9 + 0x6c) != 0) {
12	puVar8 = local_c;
12	uVar3 = *puVar7;
12	*puVar8 = uVar3;
12	if (*(int *)(iVar9 + 0x474) == 0x1ee) {
12	if (*(int *)(iVar9 + 0x4b4) != 0) {
12	ptVar6 = local_8;
12	*(undefined4 *)((int)param_4 + 4) = 0;
12	param_2[1] = 2;
12	if (((short)param_3 < 0) || (*param_1 <= param_3)) {
12	*param_5 = sVar3;
12	if ((*(short *)(iVar1 + 0x55) == 0) &&
12	if (-1 < (short)uVar1) {
12	return (int)sVar5;
12	bool bVar15;
12	uVar5 = FUN_21125fd0(uVar2,param_3,1);
12	(!bVar11 &&
12	if (((short)uVar2 != 0) && ((short)uVar3 == 0)) {
12	tPIMMblockReferenceBase *this;
12	uVar2 = 0xffffffff;
12	uVar1 = 0xffffffff;
12	if (ptVar4 != (tIterator *)0x0) {
12	tDMAIterator *in_ECX;
12	FUN_21002720(local_28);
12	local_1c = *puVar1;
12	ulong local_c;
12	if ((local_c == 0) || (local_8 != 0)) {
12	local_18 = *puVar1;
12	iVar2 = puVar1[4];
12	ulong local_8;
12	if (iVar10 != 0) {
12	return lVar2;
12	pcVar6 = (char *)((uint)uVar9 + (int)_DstBuf);
12	short *psVar14;
12	psVar14[1] = 1;
12	uVar12 = *(uint *)(iVar6 + 0x31) | 1 << (bVar7 & 0x1f);
12	sVar8 = *psVar10;
12	param_6);
12	puVar6 = param_5;
12	uVar1 = *(ushort *)(param_1 + 0x1a);
12	} while ((ushort)uVar4 < uVar1);
12	FUN_211362c0(uVar2);
12	sVar1 = FUN_2112aa20(param_1,param_2,&param_1,(int)&param_2 + 2);
12	return -0x2791;
12	if ((uVar9 & 0xffe0) != 0) {
12	if (*(char *)(local_10 + 2) == '\0') {
12	else if (*(char *)(local_10 + 7) == '\0') {
12	if (5 < (short)param_2) {
12	uVar10 = (uint)(short)param_2;
12	sVar13 = (short)param_3;
12	*param_6 = uVar7;
12	(param_4 & 0xffff) + 1 + (int)sVar3);
12	param_5[5] = 1;
12	return 0xd8c5;
12	sVar7 = sVar7 + -1;
12	param_5[2] = uVar2;
12	FUN_2112dfc0(param_1,param_2);
12	sVar3 = (short)param_5;
12	if (param_4 < uVar12) {
12	psVar5 = param_10;
12	undefined4 local_3e;
12	param_3 = param_3 >> 1;
12	(daqDevice *this,short param_1,short param_2,ulong param_3,ulong param_4)
12	(daqDevice *this,short param_1,short param_2,short param_3,short *param_4)
12	(daqDevice *this,short param_1,short param_2,char *param_3,double param_4,double param_5,
12	(daqDevice *this,short param_1,short param_2,short param_3,short param_4,short param_5)
12	*,unsigned long *,short *) */
12	(daqDevice *this,short param_1,short param_2,short *param_3,ulong param_4)
12	long,unsigned long,unsigned long *) */
12	(daqDevice *this,short param_1,short param_2,short *param_3,short *param_4)
12	double *param_11)
12	*,double *,double *,double *,double *) */
12	long *param_6,double *param_7,double *param_8,double *param_9,double *param_10)
12	return local_12;
12	local_16 = (int)param_2;
12	*param_3 = local_12;
12	if ((*(byte *)((int)param_2 + 0x1f) & 0x80) == 0) {
12	puVar5 = local_28;
12	local_1c = local_10;
12	puVar8[3] = 0;
12	sVar1 = FUN_211329b0(1,local_50,param_1,param_2);
12	uVar1 = FUN_211329b0(1,local_50,param_1,param_2);
12	if (local_4a != 8) {
12	uVar14 = CONCAT44(0xffffffff,(uint)(ushort)param_2[1]);
12	if (iVar13 <= iVar8) break;
12	if (iVar2 == 2) {
12	puVar11 = puVar12;
12	for (iVar8 = 0x25; iVar8 != 0; iVar8 = iVar8 + -1) {
12	*puVar11 = CONCAT22(uVar2,uVar2);
12	*(undefined2 *)(param_3 + 0x7f) = 1;
12	undefined2 *
12	iVar3 = FUN_21009150(param_1,0x25);
12	if ((short)puVar4 != 0) {
12	if (param_1 == 7) {
12	*param_8 = 0xfffe;
12	*param_8 = 0xffff;
12	float10 fVar12;
12	else if (iVar6 == 1) {
12	local_28 = (double)CONCAT44(uStack_34,local_38);
12	local_30 = 8;
12	iVar2 = palStatusMapStatusValue(uVar1);
12	while (sVar1 != 0) {
12	piVar3 = (int *)*piVar2;
12	sVar1 = (short)((int *)*piVar2)[1];
12	pimmDeletePointer(param_1);
12	if (puVar5 == (uint *)0x0) {
12	return sVar11;
12	if (DAT_21218e80 != (int *)0x0) {
12	iVar5 = local_1c;
12	iVar2 = FUN_21137e80(param_1);
12	} while (uVar4 < param_3);
12	*piVar1 = *piVar1 + 1;
12	local_20 = 0xc;
12	return (uint)param_1 & 0xffff0000;
12	uVar8 = 0x4c90;
12	uVar9 = 0x89e4;
12	*piVar4 = 0x6720;
12	return -0x272b;
12	DAT_21213952 = 0;
12	sVar4 = FUN_21139110(param_1,&local_c);
12	uVar2 = (undefined2)(uVar1 >> 0x10);
12	char *_Source;
12	FUN_21139460(param_3);
12	return param_6;
12	int *piVar19;
12	if (uVar5 <= uVar17) break;
12	if (!bVar9) {
12	uVar17 = uVar17 + 1;
12	if (*(char *)(param_2 + 0x25c) == '\0') {
12	local_c = (undefined4 *)(local_14 + 0x44);
12	local_8 = (undefined4 *)(local_14 + 0x40);
12	FUN_21185490(iVar1,(int)sVar7);
12	*(undefined1 *)(param_2 + 0xa86) = 1;
12	FUN_211855e0(iVar8 + 1,(int)sVar7);
12	*(undefined1 *)(param_2 + 0xa86) = 0;
12	if (*(char *)(param_3 + 0x25c) == '\0') {
12	iVar4 = (int)*(short *)(param_3 + 0x1ea);
12	return 0xd639;
12	puVar5 = param_5;
12	puVar5 = param_6;
12	FUN_21135f70(uVar4);
12	goto LAB_2113c000;
12	lpOutBuffer = &local_10;
12	lpInBuffer = &local_10;
12	uVar1 = param_1[1];
12	if (*(uint *)(param_1 + 6) < *(uint *)(param_2 + 0x13)) {
12	if (sVar8 < 0) {
12	uVar3 = *(undefined4 *)(param_2 + 0x2b);
12	uVar3 = *(undefined4 *)(param_2 + 0x17);
12	*(undefined4 *)(param_4 + 0x22) = *(undefined4 *)(param_2 + 0x13);
12	*(undefined4 *)(param_4 + 0x26) = uVar3;
12	return puVar7;
12	*puVar1 = uVar5;
12	if (*piVar4 != 0) {
12	memDelete(iVar6);
12	iVar17 = param_3;
12	piVar19 = piVar19 + 1;
12	undefined2 local_1c [2];
12	*(char **)(puVar7 + 4) = param_2;
12	cVar4 = *param_2;
12	*param_2 = ';';
12	return (char *)0x0;
12	return pcVar1;
12	psVar1 = param_6;
12	local_10 = local_10 & 0xffff0000;
12	iVar6 = FUN_21141390(*pcVar5);
12	pcVar5 = (char *)FUN_21142420(pcVar5,param_2,&param_1,(int)&param_5 + 2,piVar3,&local_8,param_7)
12	case '\b':
12	goto switchD_211421b6_caseD_7;
12	return pcVar7;
12	if (puVar1 == (undefined4 *)0x0) {
12	dVar1 = 1.0;
12	*psVar2 = 0;
12	if (sVar9 == 0xf) {
12	piVar5 = *(int **)(&DAT_21217908 + iVar7 * 4);
12	*(undefined1 *)(puVar4 + 1) = 0x10;
12	puVar4[2] = 2;
12	*(undefined1 *)((int)puVar4 + 7) = 2;
12	*(undefined1 *)(puVar4 + 3) = 0x10;
12	*(undefined1 *)(puVar4 + 5) = 0x10;
12	*(undefined1 *)((int)puVar4 + 0xf) = 2;
12	*(undefined1 *)((int)puVar4 + 0x1f) = 2;
12	*(undefined1 *)(puVar4 + 0xf) = 0x10;
12	puVar4[0x10] = 0x10;
12	*(undefined1 *)((int)puVar4 + 0x23) = 2;
12	*(undefined1 *)(puVar4 + 0x11) = 0x10;
12	puVar4[0x12] = 0x12;
12	*(undefined1 *)(puVar4 + 0x13) = 0x10;
12	*(undefined1 *)(puVar4 + 0x1b) = 8;
12	*(undefined1 *)((int)puVar4 + 0x3b) = 2;
12	*(undefined1 *)((int)puVar4 + 0x4b) = 1;
12	puVar4[0x2a] = 0x1e;
12	*(undefined1 *)((int)puVar4 + 0x57) = 2;
12	*(undefined1 *)(puVar4 + 0x2b) = 8;
12	*(undefined1 *)((int)puVar4 + 0x5b) = 2;
12	*(undefined1 *)(puVar4 + 0x2d) = 8;
12	*piVar5 = iVar3 + 0x41b;
12	piVar5[1] = iVar3 + 0x41d;
12	*(undefined1 *)((int)puVar4 + 0x13) = 1;
12	*(undefined1 *)((int)puVar4 + 0x2f) = 2;
12	*(undefined1 *)((int)puVar4 + 0x33) = 1;
12	bVar1 = *(byte *)((int)puVar4 + 3);
12	*(byte *)((int)puVar4 + 3) = bVar1 | 4;
12	uVar6 = uVar5 * 2 & 0xffff;
12	FUN_21136ee0(param_1,param_2,_Buf,0,uVar6);
12	remove(local_b4);
12	iVar5 = *(int *)(param_2 + 6);
12	code *pcVar4;
12	iVar2 = *(int *)(param_2 + 6);
12	*(undefined4 *)(param_1 + 0x18) = 0;
12	iVar4 = (int)local_a8;
12	(cVar1 = FUN_21152636(*(undefined4 *)(local_1c + 5)), cVar1 != '\0')) ||
12	cVar1 = FUN_211525de(*(undefined4 *)(local_1c + 5));
12	sVar2 = FUN_21166c24(*(undefined4 *)(local_1c + 5));
12	for (local_64 = 0; local_64 < 1; local_64 = local_64 + 1) {
12	((byte)((int)local_64 << 3) & 0x1f));
12	for (local_68 = 0; local_68 < 2; local_68 = local_68 + 1) {
12	((byte)((int)local_68 << 3) & 0x1f));
12	for (local_74 = 0; local_74 < 4; local_74 = local_74 + 1) {
12	for (local_7c = 0; local_7c < 1; local_7c = local_7c + 1) {
12	for (local_80 = 0; local_80 < 2; local_80 = local_80 + 1) {
12	sVar2 = FUN_21146493(param_1,*local_1c,6,2,local_10,0,local_1c[1],local_1c[2]);
12	for (local_20 = 0; local_c = 0, local_20 < 4; local_20 = local_20 + 1) {
12	sVar2 = FUN_21129b00(*local_24,CONCAT22(local_20 >> 0xf,*local_1c),
12	local_24 = FUN_21171bda(param_1,&local_54);
12	if (local_1c[0] == 0x23) {
12	if (*(int *)(local_4c + 5) == 0x26) {
12	if ((*(int *)(local_4c + 5) == 0x16) && (local_1c[0] == 0x23)) {
12	local_4c[1],local_4c[2]);
12	(char)(*(uint *)(local_4c + 0x3d6) >>
12	sVar2 = FUN_21166ad5(*(undefined4 *)(local_30 + 5));
12	if (((param_3 & 0x8000) == 0) &&
12	(sVar2 = FUN_21166c24(*(undefined4 *)(local_30 + 5)), sVar2 != 0)) {
12	FUN_2117fe31(local_30,CONCAT22(sVar2 >> 0xf,
12	local_30[(short)param_3 + 0x419]));
12	*(undefined1 *)(local_30 + 9) = 0;
12	*(byte *)(local_30 + 0x36b) = *(byte *)(local_30 + 0x36b) | 2;
12	local_24 = FUN_21146493(param_1,*local_30,1,local_30[3],
12	*(undefined4 *)((int)local_30 + 0x6d5),0,
12	local_30[1],local_30[2]);
12	sVar2 = FUN_21166c24(*(undefined4 *)(local_30 + 5));
12	*(uint *)(local_30 + 0x3d6) & 0xfffffffd;
12	*(uint *)(local_30 + 0x3d6) & 0xfffffffe;
12	if (local_30[(short)param_3 + 0x419] == 3) {
12	*(uint *)(local_30 + 0x3d6) = *(uint *)(local_30 + 0x3d6) | 8;
12	*(uint *)(local_30 + 0x3d6) & 0xffffffdf;
12	local_24 = FUN_21152f6b(local_30,param_1);
12	if (((*(int *)(local_30 + 5) == 10) || (*(int *)(local_30 + 5) == 1)) &&
12	sVar2 = FUN_21166bd9(*(undefined4 *)(local_30 + 5));
12	if ((*(int *)(local_30 + 5) == 0x21) &&
12	(*(char *)((int)local_30 + 0x795) == '\0')) {
12	*(undefined1 *)((int)local_30 + 0x793) = 0xff;
12	*(byte *)(local_30 + 0x3ca) = *(byte *)(local_30 + 0x3ca) & 0xfe;
12	*(byte *)((int)local_30 + 0x793) =
12	*(byte *)((int)local_30 + 0x793) &
12	~(byte)(1 << ((byte)param_3 & 0x1f));
12	for (local_78 = 0; local_78 < 1; local_78 = local_78 + 1) {
12	(char)((int)(uint)*(byte *)((int)local_30 + 0x793) >>
12	(char)((int)(uint)*(byte *)(local_30 + 0x3ca) >>
12	local_30[1],
12	(char)(*(uint *)(local_30 + 0x3cf) >>
12	if ((*(int *)(local_30 + 5) == 1) &&
12	((0 < local_48 && (*(char *)((int)local_c + 0xf) != '\0')))) {
12	local_30[2]);
12	short local_d4;
12	short local_d0;
12	short local_c4;
12	ushort local_88;
12	char local_54;
12	undefined2 local_4c [2];
12	local_2c = FUN_21171bda(param_1,&local_9c);
12	if (((param_3 == (short *)0x0) || (param_5 == 0)) || (param_4 == 0)) {
12	if ((param_2 < 1) || (0x100 < param_2)) {
12	if (local_28[0] != 0x23) {
12	local_74 = local_74 + 1;
12	return -0x298b;
12	sVar2 = FUN_21166ad5(*(undefined4 *)(local_78 + 5));
12	local_24 = -0x292c;
12	local_8c = (undefined2 *)((int)local_9c + (local_a8[0] + -1) * 0xa8d + 0x16);
12	if ((*(int *)(local_8c + 5) == 0x16) && (local_28[0] == 0x23)) {
12	if (param_3[local_68] <= (short)local_9c[8]) {
12	if ((*(short *)(param_5 + local_68 * 2) < -8) ||
12	(-1 < *(short *)(param_5 + local_68 * 2))) {
12	local_54 = '\0';
12	local_54 = '\x01';
12	sVar2 = FUN_21166bd9(*(undefined4 *)(local_78 + 5));
12	(*(char *)((int)local_78 + 0x795) == '\0')) {
12	*(byte *)((int)local_78 + 0x793) =
12	uVar5 = (uVar5 - 1 | 0xfffffff8) + 1;
12	if (((*(int *)(local_78 + 5) == 5) || (*(int *)(local_78 + 5) == 3)) &&
12	*(uint *)(local_78 + 0x3d6) = *(uint *)(local_78 + 0x3d6) | 8;
12	((byte)((int)local_c0 << 3) & 0x1f));
12	local_7c = '\x01';
12	((byte)((int)local_c4 << 3) & 0x1f));
12	local_5c = '\x01';
12	for (local_d0 = 0; local_d0 < 4; local_d0 = local_d0 + 1) {
12	local_70 = FUN_211362e0(0x2040,(int)param_2 << 1);
12	local_14 = (undefined2 *)(local_18 + 0x16 + (param_2 + -1) * 0xa8d);
12	local_10 = 0x2f;
12	short local_94;
12	local_28 = '\0';
12	if ((local_24 == -0x272f) &&
12	if (param_3[local_40] < 1) {
12	if ((*(int *)(local_50 + 5) == 5) || (*(int *)(local_50 + 5) == 3)) {
12	local_84 = 1;
12	local_78[0] = param_3[local_40];
12	if (local_28 == '\0') {
12	local_74 = '\x01';
12	sVar2 = FUN_21166ad5(*(undefined4 *)(local_50 + 5));
12	if ((*(int *)(local_50 + 5) == 0x21) && (*(char *)((int)local_50 + 0x795) == '\0')) {
12	local_24 = FUN_2117ff27(local_50,*(undefined2 *)(local_7c + local_5c * 2),
12	local_50[*(short *)(local_7c + local_5c * 2) + 0x3d9]);
12	local_24 = FUN_2117fe31(local_50,local_50[*(short *)(local_7c + local_5c * 2) +
12	0x3d9]);
12	local_80 = local_50[*(short *)(local_7c + local_5c * 2) + 0x3d9];
12	} while (iVar5 == 0);
12	local_48 = FUN_211362e0(0x2040,(int)param_2 << 1);
12	*local_50,1,local_64);
12	*(byte *)(local_50 + 0x36b) = *(byte *)(local_50 + 0x36b) | 4;
12	local_24 = FUN_21156d95(CONCAT22((short)((uint)local_64 >> 0x10),param_1),*local_50,1,
12	local_64);
12	local_1c = -0x292c;
12	if (*(int *)(local_10 + 5) == -1) {
12	*(undefined4 *)((int)local_10 + 0x6d5),0,local_10[1],
12	local_70 = (uint)*(byte *)((int)local_6c + 0x957);
12	local_74 = (uint)*(byte *)(local_6c + 0x4ac);
12	local_34 = CONCAT31(local_34._1_3_,1);
12	sVar3 = local_5c;
12	sVar3 = FUN_21146493(param_1,*local_6c,6,2,local_64,0,local_6c[1],
12	short *local_28;
12	return -0x297a;
12	sVar1 = -0x292c;
12	for (local_14 = 0; local_14 < 4; local_14 = local_14 + 1) {
12	fVar4 = (float10)FUN_2104a400(uVar1,0x430);
12	iVar2 = FUN_2104a3c0(uVar1,0x424);
12	fVar4 = (float10)FUN_2104a400(uVar1,0x428);
12	uVar3 = FUN_21153556(param_1);
12	undefined2 local_18 [2];
12	local_14 = FUN_2104a4d0(param_1,1,8,0x56a,local_10);
12	fVar2 = (float10)FUN_2104a400(local_14,0x430);
12	local_c = (double)fVar2;
12	FUN_21143130(local_c,local_18,param_2 + 2 + local_10 * 4);
12	*(undefined2 *)(param_2 + local_10 * 4) = local_18[0];
12	uVar2 = FUN_21153556(param_1);
12	if (iVar2 == 3) {
12	local_c = (double)fVar3;
12	_numSCXIchassis = _numSCXIchassis + -1;
12	iVar3 = local_1c + 0x415 + local_18 * 8;
12	FUN_211431c0((int)*(short *)(param_2 + 0x70 + local_18 * 4),
12	*(undefined2 *)(param_2 + 0x72 + local_18 * 4)),iVar3);
12	*(undefined2 *)(local_1c + 0x7b0) = *(undefined2 *)(param_2 + 0xe);
12	*(undefined2 *)(local_1c + 0x7b2 + local_18 * 2) =
12	*(undefined2 *)(local_1c + 0x832 + local_18 * 2) =
12	*(undefined4 *)(local_1c + 0x215 + local_18 * 8) = 0;
12	*(undefined4 *)(local_1c + 0x219 + local_18 * 8) = 0x3ff00000;
12	if (local_18 == 0x3f) {
12	FUN_211431c0(*(undefined4 *)(param_2 + 0xe),
12	CONCAT22(uVar2,*(undefined2 *)(param_2 + 0x12)),local_1c + 0x15);
12	*(undefined4 *)(local_1c + 0x415 + local_20 * 8) = 0;
12	*(undefined4 *)(local_1c + 0x419 + local_20 * 8) = 0x3ff00000;
12	*(undefined4 *)(local_1c + 0x215 + local_20 * 8) = *(undefined4 *)(local_1c + 0x15);
12	*(undefined4 *)(local_1c + 0x219 + local_20 * 8) = *(undefined4 *)(local_1c + 0x19);
12	*(undefined4 *)(local_1c + 0x615) = *(undefined4 *)(param_2 + 0x14);
12	*(undefined2 *)(local_1c + 0x695) = *(undefined2 *)(param_2 + 0x18);
12	if (local_18 == 0x1f) {
12	iVar3 = local_1c + 0x9b7 + local_18 * 8;
12	*(undefined2 *)(local_1c + 0x9a7 + local_18 * 2) =
12	*(undefined2 *)(param_2 + 0x9e + local_18 * 2);
12	*(undefined2 *)(local_1c + 0xa8b) = 4;
12	ushort local_30;
12	uVar3 = 0xd75e;
12	if (param_3 == 0xffff) {
12	param_8[local_18] = 0;
12	if ((local_10 == -0x272f) &&
12	sVar1 = -0x2717;
12	uVar3 = (undefined2)((uint)*(undefined4 *)((int)local_2c + 0x6d5) >> 0x10);
12	local_10 = -0x2717;
12	local_c = -0x2713;
12	sVar3 = -0x2730;
12	CONCAT22((short)((uint)param_22[1] >> 0x10),param_5),param_6,
12	*param_22,param_22[1],*param_23,param_23[1],local_30);
12	if (param_3 == 0x8000) {
12	if (param_9 < 1) {
12	if (*(int *)(local_1c + 5) == -1) {
12	cVar2 = FUN_211525de(local_10);
12	if (((cVar2 != '\0') && (local_10 != 0x2d)) && (local_10 != 0x2f)) {
12	*(char *)((int)&local_14 + iVar6) =
12	CONCAT22((short)((uint)iVar6 >> 0x10),local_1c[2]));
12	undefined4 param_5,undefined4 *param_6)
12	uVar2 = (undefined2)((uint)local_c >> 0x10);
12	if (param_5 == -1) {
12	*(byte *)(local_18 + 0x36b) = *(byte *)(local_18 + 0x36b) & 0x7f;
12	local_8 = (double *)&iStack_1393c;
12	local_18._0_2_ = (ushort)uVar4;
12	sVar1 = FUN_2117eae6();
12	local_1c = (undefined2 *)CONCAT22((short)((uint)local_8 >> 0x10),param_1);
12	sVar1 = FUN_211586c1();
12	local_18 = (short *)CONCAT22(local_18._2_2_,(short)uVar4);
12	local_10 = (double)((ulonglong)
12	sVar1 = FUN_21129b00();
12	uStack_2c = (double)CONCAT44(1,CONCAT22((short)((uint)local_1c >> 0x10),param_4));
12	fStack_138f8 = 0.0;
12	local_14 = (undefined2 *)0x1;
12	local_18._2_2_ = (short)((uint)local_8 >> 0x10);
12	puStack_20 = (undefined8 *)0x3ff00000;
12	puStack_24 = (undefined2 *)0x0;
12	uStack_2c = (double)(float)auStack_18778;
12	sVar1 = FUN_21157bf1();
12	dStack_13924 = dStack_13924 + adStack_138d8[sStack_13914];
12	sStack_18876 = ftol();
12	if ((local_10 != 0) ||
12	undefined2 extraout_var_25;
12	undefined2 extraout_var_26;
12	undefined2 extraout_var_27;
12	undefined2 extraout_var_28;
12	undefined2 extraout_var_29;
12	undefined2 extraout_var_30;
12	undefined2 extraout_var_31;
12	undefined2 extraout_var_32;
12	undefined2 extraout_var_33;
12	undefined2 extraout_var_34;
12	undefined2 extraout_var_35;
12	undefined2 extraout_var_36;
12	undefined2 extraout_var_37;
12	undefined2 extraout_var_38;
12	undefined2 extraout_var_39;
12	undefined2 extraout_var_40;
12	undefined2 extraout_var_41;
12	undefined2 extraout_var_42;
12	undefined2 extraout_var_43;
12	undefined2 extraout_var_44;
12	undefined2 extraout_var_45;
12	undefined2 extraout_var_46;
12	undefined2 extraout_var_47;
12	undefined2 extraout_var_48;
12	undefined2 extraout_var_49;
12	double local_68;
12	sVar4 = local_24;
12	local_24 = FUN_21009700();
12	for (local_84 = 0; (short)local_84 < 4; local_84 = local_84 + 1) {
12	iVar6 = (short)local_84 * 2 + 8;
12	(int)local_90 + (short)local_84 * 0x10 + 0x957,0,local_90[1],
12	local_54 = 8;
12	local_54 = param_3 + 1;
12	for (param_3 = local_28; param_3 < local_54; param_3 = param_3 + 1) {
12	iVar6 = (int)local_988;
12	*(byte *)((int)local_90 + (-(uint)(uVar7 != 0) & 9) + 0x95b + local_988 * 0x10) =
12	*(byte *)((int)local_90 + (-(uint)(uVar8 != 0) & 9) + 0x95b + local_988 * 0x10)
12	switch(local_84) {
12	local_a04 = CONCAT22(local_a04._2_2_,0xfff);
12	local_24 = FUN_2115c0d2(CONCAT22(sVar4,param_10),CONCAT22(sVar4,param_11),
12	0xeb851eb8,0x3f9eb851,local_d8c);
12	local_24 = FUN_2115c0d2(CONCAT22(sVar4,param_10),CONCAT22(sVar4,param_11),0,
12	0x3fe00000,local_d8c);
12	*(uint *)(local_90 + local_988 * 8 + 0x4ae) &
12	*(byte *)((int)local_90 + local_988 * 0x10 + 0x95b) =
12	(float10)1000.0);
12	(float10)(double)CONCAT44(uStack_a08,local_a0c) +
12	(float10)(double)CONCAT44(uStack_9f0,local_9f4)) *
12	local_954,0,0xb,((int)param_3 / 2) * 2 + 9);
12	puVar1[1] = auStack_9bc[local_988 * 2];
12	*puVar1 = *(undefined4 *)(local_9c0 + local_988 * 8);
12	puVar1[1] = auStack_9e8[local_988 * 2];
12	*puVar1 = *(undefined4 *)(local_9ec + local_988 * 8);
12	0x10),param_1),
12	0x10),param_2),(short)local_84 * 2 + 1,
12	local_24 == 0 &&
12	*(undefined1 *)((int)local_90 + (short)local_84 * 0x10 + 0x957) =
12	CONCAT22((short)local_84 >> 0xf,param_2),
12	FUN_21007370(param_10,0,0);
12	for (local_84 = 0; (short)local_84 < 1000; local_84 = local_84 + 1) {
12	iVar6 = (int)(short)local_84;
12	CONCAT22((short)((uint)iVar6 >> 0x10),param_11),&local_70);
12	*(undefined4 *)((int)local_90 + param_3 * 8 + 0x415),
12	*(undefined4 *)((int)local_90 + param_3 * 8 + 0x419),0,0,
12	*(char *)((int)&local_c + (int)local_1c) =
12	CONCAT22((short)(uVar4 >> 0x10),local_1c[2]));
12	,local_c[1],CONCAT22((short)(uVar2 >> 0x10),local_c[2]));
12	*(uint *)(local_10 + 0x3d1) = *(uint *)(local_10 + 0x3d1) & 0xffffffef;
12	*(uint *)(local_10 + 0x3d1) = *(uint *)(local_10 + 0x3d1) & 0xffffffdf;
12	local_6c = (short)sVar2;
12	param_8 = 1;
12	local_c = *(short **)(local_c + 0x7ea9);
12	sVar3 = FUN_21171bda(param_1,&param_1);
12	if (param_6 == (undefined4 *)0x0) {
12	if (((short)param_2 != 0) && ((short)param_2 != 1)) {
12	FUN_211850f0(param_1,4,param_2);
12	if (*psVar7 != 0) {
12	if (*(short *)(param_2 + 4) == 3) {
12	if (*(short *)(param_1 + 0x3a) == 0) {
12	FUN_21185130(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x36),0);
12	FUN_211850f0(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x36));
12	if (param_2 == 6) {
12	sVar1 = FUN_211ce8b0(param_1);
12	for (local_34 = (ushort)local_38; (int)(short)local_34 < (int)(local_10 & 0xff);
12	local_34 = local_34 + 1) {
12	puVar6 = (uint *)FUN_21183ed0();
12	return CONCAT22(sVar4,0xd675);
12	/* WARNING: Could not find normalized switch variable to match jumptable */
12	puVar2 = (undefined1 *)0x0;
12	*(undefined1 *)(param_1 + 0x6d5) = 8;
12	*(undefined1 *)(param_1 + 0x6d7) = 0x40;
12	*(undefined1 *)(param_1 + 0x956) = 1;
12	return 0xd8c1;
12	local_1c = (uint)(byte)(bVar4 * (char)*(undefined2 *)(param_1 + 6));
12	cVar3 = *(char *)(param_1 + 0x6d9 + local_1c);
12	*(byte *)(param_1 + 0x6d9 + local_1c) = *(byte *)(param_1 + 0x6d9 + local_1c) & 0xc0;
12	*(byte *)(param_1 + 0x6d9 + local_1c) = *(byte *)(param_1 + 0x6d9 + local_1c) | local_14;
12	if (param_2 != 0xffff) {
12	for (local_c = 0; (short)local_c < 8; local_c = local_c + 1) {
12	for (local_c = 0; (short)local_c < 4; local_c = local_c + 1) {
12	(ushort)*(byte *)(param_1 + 0x12);
12	sVar5 = (short)param_2 / 2;
12	if (param_3 < 0x15) {
12	*(byte *)(param_1 + 0x95b + (short)local_c * 0x10) =
12	*(byte *)(param_1 + 0x964 + (short)local_c * 0x10) =
12	*(uint *)(param_1 + 0x95c + (short)local_c * 0x10) &
12	((local_30[0] & 0xffff) << 0xc | 0xff000fff);
12	*(byte *)(param_1 + 0x95b + sVar5 * 0x10) =
12	*(byte *)(param_1 + 0x964 + sVar5 * 0x10) =
12	*(byte *)((int)local_24 + bVar11 + 0x6d9) =
12	local_9c = 0;
12	*(byte *)((int)local_24 + (local_20 & 0xff) + 0x789) =
12	local_88 = 0;
12	local_88 = 1;
12	sVar6 = *(short *)((int)local_24 + 0x791);
12	local_18 = CONCAT22(local_18._2_2_,sVar6);
12	if ((*param_10 == 0) && (sVar6 == *(short *)((int)local_24 + 0x791))) {
12	*(byte *)((int)local_24 + param_3 + 0x789) =
12	*(ushort *)((int)local_24 + 0x791) |
12	*(ushort *)((int)local_24 + 0x791) &
12	*(byte *)((int)local_24 + 0x6d7) =
12	while ((local_20 & 0xff) < 4) {
12	cVar4 = *(char *)((int)local_24 + (local_20 & 0xff) * 0x10 + 0x95b);
12	cVar3 = *(char *)(local_24 + (local_20 & 0xff) * 8 + 0x4b2);
12	*param_10 = *param_10 |
12	(ushort)(cVar4 != *(char *)((int)local_24 + (local_20 & 0xff) * 0x10 + 0x95b
12	)) |
12	(ushort)(cVar3 != *(char *)(local_24 + (local_20 & 0xff) * 8 + 0x4b2)) |
12	(ushort)*(byte *)(local_24 + 9);
12	cVar4 = *(char *)((int)local_24 + (local_c & 0xff) + (local_1c & 0xff) * 0x10 + 0x957);
12	if (sVar6 < 0x3e9) {
12	if (sVar6 == 1000) {
12	else if (sVar6 == 10) {
12	if (sVar6 != 100) {
12	if (sVar6 != 10000) {
12	if (*param_10 == 0) {
12	uVar10 = (undefined2)((uint)puVar2 >> 0x10);
12	*(uint *)(param_1 + 0x7ac) = *(uint *)(param_1 + 0x7ac) & 0xfffffdff;
12	*(undefined1 *)(local_c + 0x36b) = *(undefined1 *)(local_c + 0x36b);
12	uVar1 = CONCAT22(uVar2,8);
12	if (((int)(short)param_2 & 0xffff8000U) == 0) {
12	if ((int)uVar2 < 0) {
12	param_1 = (int)(short)param_2 & 0xffff8000U;
12	switch(param_2[5]) {
12	local_8 = FUN_21146493(param_1,*param_2,1,param_2[3],*(undefined4 *)((int)param_2 + 0x6d5),0,
12	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 0xc0;
12	for (local_8 = 0; local_8 < 8; local_8 = local_8 + 1) {
12	*(undefined1 *)(param_1 + 0x793) = 0xff;
12	*(ushort *)(param_1 + 0x798) = *(ushort *)(param_1 + 0x798) & 0xf000;
12	*(ushort *)(param_1 + 0x798) = *(ushort *)(param_1 + 0x798) | 0xc0;
12	if (sVar1 < 4) {
12	if (sVar1 < 6) {
12	if (sVar1 != 6) {
12	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0x20;
12	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0x28;
12	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 10;
12	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0xa4;
12	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 5;
12	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0xf8;
12	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0x2f;
12	*(byte *)(param_1 + 0x6d6) = *(byte *)(param_1 + 0x6d6) | 0x40;
12	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) & 0x51;
12	*(byte *)(param_1 + 0x6d5) = *(byte *)(param_1 + 0x6d5) | 0xb;
12	switch(local_14[0]) {
12	if (DAT_212117d8 != '\0') {
12	sVar1 = *psVar3;
12	local_c = param_4 & 1;
12	return CONCAT22(uVar3,0xd8e9);
12	*(undefined1 *)(param_1 + 0x6d5) = (undefined1)local_20;
12	*(char *)(param_1 + 0x6d6) = (char)((uint)local_20 >> 8);
12	local_14 = *param_3;
12	*(uint *)(param_1 + 0x8ea + param_2 * 4) & ~(1 << (param_4 & 0x1f));
12	*(uint *)(param_1 + 0x8ea + param_2 * 4) | 1 << (param_4 & 0x1f);
12	*param_4 = *(uint *)(param_1 + 0x8ea + param_2 * 4);
12	FUN_211734ff(param_3,param_2);
12	if (0x17 < param_3) {
12	else if (iVar4 < 0x3e9) {
12	if (iVar4 == 1000) {
12	else if (iVar4 < 0x1f5) {
12	if (iVar4 == 500) {
12	if (sVar2 != 100) {
12	case 0xdc:
12	case 0x7d:
12	case 0x96:
12	int local_8c;
12	*(undefined4 *)param_6 = *puVar1;
12	*(undefined4 *)((int)param_6 + 4) = puVar1[1];
12	*(undefined4 *)param_7 = *(undefined4 *)(iVar5 + 8);
12	*(undefined4 *)((int)param_7 + 4) = *(undefined4 *)(iVar5 + 0xc);
12	iVar5 = **(int **)(param_2 + 0x94e);
12	*(undefined4 *)param_6 = *(undefined4 *)(iVar5 + param_5 * 0x10);
12	*(undefined4 *)((int)param_6 + 4) = *(undefined4 *)(iVar5 + 4 + param_5 * 0x10);
12	*(undefined4 *)param_7 = *(undefined4 *)(iVar5 + 8 + param_5 * 0x10);
12	*(undefined4 *)((int)param_7 + 4) = *(undefined4 *)(iVar5 + 0xc + param_5 * 0x10);
12	uVar4 = FUN_21133cc0(param_1,param_2,1,CONCAT22(sVar3,local_c),8,&local_30,0,
12	if ((*(short *)(param_2 + 0x7b0) == 0x521) &&
12	uVar4 = FUN_21133cc0(param_1,param_2,1,CONCAT22((short)((uint)iVar5 >> 0x10),local_c),
12	iVar5 = ((int)param_3 / 2) * 2 + 9;
12	&local_78,0,
12	uVar4 = FUN_2117f0c8(param_8,param_6);
12	iVar2 = *(int *)(*(int *)(param_2 + 0x94e) + 4);
12	local_30 = 0x40;
12	**(double **)(*(int *)(param_2 + 0x94e) + local_2c * 4) = (double)local_20;
12	local_14 = FUN_21133cc0(param_1,param_2,1,4,1,&local_90,0,CONCAT31(uVar8,(undefined1)local_8),
12	*(double *)(param_2 + 0x916) = (double)((int)(char)local_90 >> 4 & 0xf);
12	if (((uint)local_90 & 8) == 0) {
12	local_90 = (float)((uint)local_90 & 0xffffff0f);
12	local_2c = (short)(char)local_90;
12	local_90 = (float)((uint)local_90 | 0xf0);
12	local_2c = -(short)(char)local_90;
12	*(double *)(param_2 + 0x916) =
12	(double)CONCAT44(uStack_94,local_98) * *(double *)(param_2 + 0x916);
12	if (-1 < iVar7) {
12	*(byte *)((int)local_8c + local_38 + -4) =
12	*(double *)(**(int **)(param_2 + 0x94e) + local_38 * 0x10) = (double)fVar10;
12	CONCAT31((int3)((uint)(local_38 * 2) >> 8),
12	((int)local_8c + local_38 * 4 + -2)));
12	CONCAT31((int3)cVar2,
12	local_8 & 0xff,3);
12	for (local_38 = 0; local_38 < 7; local_38 = local_38 + 1) {
12	((int)local_8c +
12	*(undefined4 *)(iVar7 + 0x10) = 0;
12	*(undefined4 *)(iVar7 + 0x14) = 0;
12	*(undefined4 *)(iVar7 + 0x18) = 0;
12	*(undefined4 *)(iVar7 + 0x1c) = 0x3ff00000;
12	(double)local_90;
12	CONCAT31((int3)(char)((ushort)local_2c >> 8),(undefined1)local_8),3);
12	**(double **)(*(int *)(param_2 + 0x94e) + 0x80) = (double)local_8c[0];
12	sVar3 = FUN_21133cc0(param_1,param_2,1,CONCAT22(local_2c >> 0xf,local_c),8,&local_90,0,
12	puVar6 = (undefined1 *)(int)local_28;
12	if (7 < (int)puVar6) break;
12	iVar7 = *(int *)(*(int *)(param_2 + 0x94e) + local_28 * 4);
12	*(undefined4 *)(iVar7 + 0xc + local_30 * 0x10));
12	iVar7 = *(int *)(*(int *)(param_2 + 0x94e) + local_30 * 4);
12	local_24 = (float)**(double **)(*(int *)(param_2 + 0x94e) + 0x80);
12	local_18 = local_51c;
12	for (local_8c = 0; local_8c < 0x20; local_8c = local_8c + 1) {
12	local_2c = 0x200;
12	puVar6 = (undefined1 *)(int)param_3;
12	for (local_28 = 0; local_28 < 8; local_28 = local_28 + 1) {
12	iVar7 = local_8c * 2 + 9;
12	local_14 = FUN_21133cc0(param_1,param_2,2,CONCAT22((short)((uint)local_18 >> 0x10),local_c),
12	CONCAT22((short)((uint)iVar7 >> 0x10),local_2c),local_18,0,
12	CONCAT31((int3)((uint)local_18 >> 8),(undefined1)local_8),iVar7);
12	local_1c = 0x40;
12	else if (uVar3 == 3) {
12	local_8 & 0xff,iVar2);
12	iVar2 = (int)param_4;
12	for (local_18 = 0; local_18 < local_14; local_18 = local_18 + 1) {
12	dVar1 = ((param_7 - param_8) *
12	((*(double *)(param_11 + 2) - *(double *)(param_11 + 4)) /
12	(double)((*param_11 - param_11[1]) + 1))) / (param_5 - param_6);
12	*param_9 = param_7 - ((double)((*param_11 - param_11[1]) + 1) * dVar1 * param_5) /
12	(*(double *)(param_11 + 2) - *(double *)(param_11 + 4));
12	piStack_2ac = &local_60;
12	uVar2 = FUN_21150ea4();
12	piStack_2ac = (int *)0x3;
12	u64::u64((u64 *)&uStack_2b4,100);
12	piStack_2ac = (int *)0x2;
12	piStack_2ac = (int *)0x408f4000;
12	uStack_2b4._4_4_ = (undefined1 *)0x0;
12	uStack_2b4._0_4_ = 100;
12	iVar4 = (int)local_30;
12	local_18._0_2_ = (ushort)uVar5;
12	for (local_44 = 0; (int)local_44 < (int)(uint)*(ushort *)(local_78 + 0xa89);
12	local_44 = local_44 + 1) {
12	local_10 = 100;
12	local_1c = (float)(uint)param_6;
12	for (local_18 = 0; local_18 < local_c; local_18 = local_18 + 1) {
12	if (param_8 < 20.0) {
12	local_34 = param_6;
12	fVar3 = 0.0;
12	*param_3 = 1.0;
12	if ((int)uVar1 < 0) {
12	for (local_34 = 0; local_34 < local_30; local_34 = local_34 + 1) {
12	CONCAT22(uVar3,local_c[1]),
12	CONCAT22((short)((uint)puVar2 >> 0x10),local_c[2]));
12	if (param_3[local_1c] <= (short)local_2c[8]) {
12	param_2 = uVar1;
12	*(byte *)(param_2 + 0x6d5) = *(byte *)(param_2 + 0x6d5) & 0xef;
12	uVar3 = FUN_21146493(*param_1,*local_1c,1,local_1c[3],*(undefined4 *)((int)local_1c + 0x6d5)
12	if (*pdVar1 <= 950.0) {
12	if (*pdVar1 <= 750.0) {
12	if (*pdVar1 <= 65.0) {
12	if (*pdVar1 <= 20.0) {
12	uStack_24 = 0x40100000;
12	local_8 = (short)uVar1;
12	*(undefined1 *)((int)param_1 + 0xfd4f) = 8;
12	LPCSTR lpModuleName;
12	FUN_21183470(param_1,&DAT_21217d50);
12	if (((local_c != (int *)0x0) && (local_c[1] = local_c[1] + -1, local_c[1] == 0)) &&
12	(local_c != (int *)0x0)) {
12	if (param_3 != (undefined4 *)0x0) {
12	HMODULE pHVar3;
12	uVar5 = 1000;
12	uVar4 = 1000000;
12	puVar3 = (u64 *)u64::u64((u64 *)&local_c,(u64 *)&param_2);
12	uVar4 = 1000;
12	u64::u64((u64 *)&stack0xffffff4c,(u64 *)&local_c);
12	puVar3 = u64::operator%=(puVar3);
12	u64::u64((u64 *)&puStack_bc,(u64 *)&local_c);
12	puVar3 = u64::operator/=(puVar3);
12	uVar3 = uVar3 % 10;
12	FUN_21184e80(this);
12	(*(undefined4 *)(param_1 + 0xc),param_2,param_3,0x40000000);
12	uVar2 = *(uint *)((int)in_stack_00000024 + 0x1c);
12	if (param_1 != (float *)0x0) {
12	puVar7 = puVar1;
12	puVar5 = puVar5 + uVar2;
12	in_stack_00000028 = in_stack_00000028 + 1;
12	param_4 = param_2;
12	in_stack_00000024 = (float *)((int)in_stack_00000024 + 0x38);
12	in_stack_00000034[0x38] = in_stack_00000034[0x38] + (int)in_stack_00000028;
12	fVar3 = *param_1;
12	fVar4 = param_1[1];
12	pfVar10 = pfVar10 + 1;
12	uVar6 = param_4 & 0xffff;
12	puVar7 = (uint *)param_5;
12	param_5 = (float *)((uint *)param_5 + 1);
12	iVar9 = *in_stack_00000034;
12	uVar6 = (uint)param_4 & 0xffff;
12	&param_9,param_12,param_13);
12	local_10 = (float)((int)local_10 + 1);
12	FUN_211886d0(*(undefined2 *)(iVar5 + 0x14),
12	CONCAT22((short)((uint)&param_10 >> 0x10),*(undefined2 *)(iVar5 + 0x24)),0,1,
12	FUN_211886d0(*(undefined2 *)(iVar5 + 0x14),param_7,1,0,0,0,fVar15,fVar13,&param_10,
12	param_4 = -NAN;
12	FUN_211886d0(CONCAT22(uVar8,*(undefined2 *)(iVar5 + 0x14)),uVar17,1,0,
12	FUN_211886d0(*(undefined2 *)(iVar5 + 0x14),param_7,1,0,0,0,fVar15,fVar14,&param_10,
12	if ((1 < (param_8 & 0xffff)) && ((param_8 & 0xffff) < 4)) {
12	undefined2 uVar11;
12	FUN_211886d0(CONCAT22(uVar8,*(undefined2 *)(iVar3 + 0x14)),uVar6,1,0,
12	FUN_211886d0(*(undefined2 *)(iVar3 + 0x14),param_7,1,0,0,0,fVar2,uVar13,&local_14,
12	param_2 = (uint *)ftol();
12	*param_9 = *param_9 + (param_3 + param_6) * 2;
12	*param_9 = *param_9 + (param_3 + param_6) * 4;
12	psVar8 = local_c;
12	case 0x70:
12	int local_94;
12	uVar15 = uVar15 + 1 + sVar6;
12	local_38 = pcVar7;
12	local_8 = (uint)CONCAT11(1,(byte)param_2 & 0xf) << 0x10 | param_1 & 0xffff;
12	sVar4 = FUN_2100a800(param_1);
12	sVar4 = FUN_211a0e40(local_8,local_dc,local_d4,&local_3c,local_d8,local_6a);
12	FUN_2118e080(local_3c + 0x276,0x28);
12	pcVar3 = param_4;
12	strcat(pcVar7,pcVar2 + 0x52);
12	if (*(short *)(pcVar2 + 0x2ec) == 4) {
12	if ((*(int *)(pcVar2 + 0x268) != 0) ||
12	(*(int *)(pcVar2 + 0x26c) != -0x40100000)) {
12	if (*(int *)(pcVar2 + 0x270) != 1) {
12	sVar4 = FUN_2100a800(CONCAT22(uVar12,*(undefined2 *)
12	(pcVar2 + 0x50)));
12	if (*(int *)(pcVar2 + 0xbc) == 0x14) {
12	(double)param_2,0,&DAT_2120cff0
12	,1,&local_8,local_a,local_18,0,
12	*local_1c = '\0';
12	sVar4 = FUN_210088f0(local_8,0,local_24,0,
12	sVar4 < 0)))) ||
12	sVar4 < 0)))))) ||
12	>> 0x10),
12	*param_5 = local_8;
12	*param_6 = local_2c;
12	if (pcVar5 == (char *)0x0) {
12	uVar6 = FUN_210094a0();
12	*(short *)(local_8 + 0x62) = sVar15;
12	uVar14 = (uint)uVar2;
12	cVar1 = *param_1;
12	FUN_21185a40(*param_3);
12	local_10 = (char *)0x0;
12	param_2[2] = 0;
12	local_14 = 1.4013e-45;
12	iVar11 = FUN_21185a00((local_8 & 0xffff) << 6);
12	*(int *)(param_2 + 2) = iVar11;
12	param_1 = *(char **)(param_2 + 2);
12	sprintf(param_1,&DAT_2120b9cc,pcVar8);
12	uVar1 = *(undefined2 *)(pcVar8 + 0x40);
12	iVar5 = *(int *)(param_2 + 0x12);
12	param_1 = param_1 + sVar13 + 1;
12	iVar11 = (int)(short)local_c;
12	} while (iVar11 < (int)(local_8 & 0xffff));
12	if (local_10 == (char *)0x0) {
12	lVar2 = atol(pcVar1 + 2);
12	if (pcVar1 == (char *)0x0) {
12	pcVar2 = (char *)((uVar10 & 0xffff) * 0x70 + param_1);
12	puVar8 = (undefined4 *)puVar8[0x25]) {
12	param_1[0x85] = 0;
12	param_3 = (char *)0x4;
12	if ((sVar3 < 0) ||
12	sVar5 = strlen(_Dest);
12	strcat(_Dest,pcVar4);
12	int *local_5c;
12	uVar17 = param_3;
12	local_3c = puVar2[0x28];
12	local_38 = 0xce18;
12	if (param_2 == (uint *)0x1) {
12	local_38 = 0xce2c;
12	local_4c = (double)(ulonglong)local_10;
12	local_38 = 0xcc6a;
12	local_8 = 0x40;
12	FUN_21185a40(iVar2);
12	iVar3 = *(int *)(param_1 + 0x276);
12	iVar5 = *(int *)(param_1 + 0x276);
12	uVar7 = *(undefined4 *)(iVar5 + 0xbc);
12	goto LAB_21191b3b;
12	iVar4 = *(int *)(iVar4 + 0x94);
12	iVar3 = *(int *)(iVar3 + 0x94);
12	setScannableDependentChannel();
12	undefined4 *local_1c;
12	&local_54);
12	uVar8 = (ushort)((uint)puVar6 >> 0x10);
12	goto LAB_2119393e;
12	local_8 = -0x2724;
12	*param_11 = 0.0;
12	float fVar7;
12	if ((float)piVar2 == 0.0) {
12	param_1 = 0.0;
12	if (fVar1 == 100.0) {
12	*param_5 = 2.5e-05;
12	goto switchD_211951c4_caseD_13;
12	if (param_5 == 0.0) {
12	sVar1 = FUN_21198050(param_1,param_2,&param_2);
12	fVar4 = (float10)1.0;
12	*(float *)(param_1 + 1);
12	(float10)param_5);
12	*psVar1 = 1;
12	uVar15 = 0xffffd678;
12	sVar8 = strlen(pcVar10);
12	FUN_2119aa20(sVar4,*puVar1,CONCAT22(uVar9,puVar1[1]),param_4);
12	strcpy(_Str + (short)sVar6,&DAT_2120c6cc);
12	sVar1 = strlen(param_4);
12	if ((uVar1 != 0) && (uVar2 == uVar1)) {
12	return 0xd679;
12	iVar7 = FUN_21009150(param_1,0x25);
12	float local_3c;
12	goto LAB_2119c2cf;
12	setI32Attribute(*(undefined4 *)(local_8 + 0x1b2),
12	float fVar9;
12	float fVar11;
12	*param_8 = 4;
12	if ((param_4 != -1.0) && (param_4 < 0.0)) {
12	fVar9 = 1.4013e-45;
12	fVar9 = 0.0;
12	for (iVar12 = *(int *)(param_1 + 0x276); iVar12 != 0; iVar12 = *(int *)(iVar12 + 0x94)) {
12	setVoidPtrAttribute(*(undefined4 *)(iVar3 + 0x1b2),*(undefined4 *)(iVar12 + 0x98),3,
12	param_8);
12	setI32Attribute(*(undefined4 *)(iVar3 + 0x1b2),*(undefined4 *)(iVar12 + 0x98),0x1f,
12	(*(undefined4 *)(iVar3 + 0x1b2),*(undefined4 *)(iVar12 + 0x98),1,
12	if (*(short *)(iVar12 + 0x2fa) == 0) {
12	(int)(short)local_c);
12	scale(*(undefined4 *)(iVar3 + 0x1b2));
12	sVar5 = -0x28a3;
12	puVar5 = (undefined4 *)puVar5[0x25];
12	goto LAB_2119d8e5;
12	if ((short)param_5 != 1) {
12	return local_34;
12	iVar8 = FUN_21099070(iVar2);
12	local_5c = 0xce22;
12	local_54 = iVar2;
12	local_50 = *(undefined4 *)(iVar3 + 0x1a0);
12	local_5c = 0xcdfa;
12	sVar4 = *(short *)(*(int *)(iVar3 + 0x12e) + uVar10 * 2);
12	if ((sVar4 == 0x2011) || (sVar4 == 0x2012)) {
12	local_44 = *(undefined4 *)(iVar3 + 0x1a0);
12	local_68[0] = (-(uint)(*(int *)(iVar3 + 0x276) != 0) & 5) + 1;
12	local_58 = uVar10;
12	local_60 = (int)sVar4;
12	local_68[0] = 3;
12	else if (iVar5 == 7) {
12	uVar6 = FUN_2100a860(iVar2,local_68);
12	sVar4 = *(short *)(*(int *)(iVar3 + 0x156) + uVar10 * 2);
12	uVar10 = FUN_2104fde0(iVar2,CONCAT22((short)((uint)*(undefined2 **)(iVar3 + 0x13a) >> 0x10
12	),**(undefined2 **)(iVar3 + 0x12e)),
12	iVar5,param_1,local_c);
12	if ((((sVar4 == 0xd) || (sVar4 == 0x1f)) ||
12	((*(short *)(iVar3 + 0x1e) == 1 && ((short)param_1 != 1)))) {
12	uVar9 = **(undefined2 **)(iVar3 + 0x13a);
12	**(undefined2 **)(iVar3 + 0x12e));
12	uVar10 = FUN_21006e70(iVar2,local_30,**(undefined2 **)(iVar3 + 0x13a),
12	else if (*(undefined4 **)(iVar3 + 0x17c) == (undefined4 *)0x0) {
12	if (((short)local_10 != 0) || (local_8 != 0)) {
12	goto LAB_2119ecac;
12	uVar10 = in_stack_00000018;
12	iVar6 = FUN_21099070(in_stack_00000018);
12	goto switchD_2119f3d1_default;
12	iVar5 = FUN_21099070(param_1);
12	iVar5 = *param_5;
12	sVar2 = FUN_210990d0(param_6);
12	local_64 = 0xce22;
12	local_5c = param_1;
12	local_58 = *(undefined4 *)(param_4 + 0x1a0);
12	local_64 = 0xcdfa;
12	if (*(int *)(param_4 + 0x124) != 0) {
12	sVar2 = *(short *)(*(int *)(param_4 + 0x12e) + (int)param_5 * 2);
12	if ((sVar2 == 0x2011) || (sVar2 == 0x2012)) {
12	local_4c = *(undefined4 *)(param_4 + 0x1a0);
12	local_70[0] = (-(uint)(*(int *)(param_4 + 0x276) != 0) & 5) + 1;
12	local_60 = (uint)param_5;
12	local_68 = (int)sVar2;
12	local_70[0] = 3;
12	uVar10 = (uint)(short)local_1c;
12	if (*(short *)(param_4 + 0x128) == 0) {
12	uVar10 = CONCAT22((short)(uVar10 >> 0x10),
12	sVar2 = *(short *)(*(int *)(param_4 + 0x156) + (int)param_5 * 2);
12	if (uVar13 == 0) {
12	if ((short)local_44 != 0) goto LAB_211a020f;
12	if ((short)psVar7 != 0) goto LAB_211a02db;
12	psVar7 = (short *)FUN_21062850(param_1,local_1c,local_38,local_24,local_74,local_80,local_7c
12	if (((short)psVar7 != 0) ||
12	return (short)param_7;
12	param_5[4] = sVar3;
12	*param_13 = param_3;
12	return param_8 & 0xffff;
12	iVar5 = DAT_212223dc;
12	if ((short)param_11 == 3) {
12	sVar6 = *(short *)(iVar19 + 0xe);
12	if (puVar5 != (ushort *)0x0) {
12	pcVar6 = param_4;
12	if ((short)local_10 < 0) break;
12	size_t sVar4;
12	char *local_c;
12	sVar4 = strlen(pcVar13);
12	goto LAB_211a6144;
12	if (sVar5 != 0) goto LAB_211a6711;
12	if (sVar1 < 0) goto LAB_211a6fc0;
12	sVar3 = strlen(pcVar5);
12	puVar7 = (undefined4 *)puVar7[0x25];
12	sVar2 = *(short *)(local_c + 6);
12	uVar5 = param_6;
12	if ((short)uVar3 < 0) goto LAB_211a75ac;
12	sVar4 = strlen(pcVar6);
12	goto LAB_211a75ac;
12	FUN_211aac80(local_c,1);
12	FUN_211aac80(local_c,3);
12	if (sVar4 != 0x1a) {
12	if ((0x14 < *(short *)(local_c + 6)) && (*(short *)(local_c + 6) < 0x17)) {
12	uVar12 = uVar12 + 1;
12	local_8 = -0x29bf;
12	local_1c = uVar12;
12	uVar9 = uVar9 + uVar16;
12	if (uVar17 <= uVar9) {
12	uVar9 = *param_5;
12	FUN_21185a40(iVar16);
12	if ((short)local_8 != 0) goto LAB_211a904a;
12	iVar16 = (int)sVar2;
12	} while (sVar2 < (short)param_1);
12	local_8 = 0xffffd641;
12	if (0 < (int)puVar15) {
12	local_18 = puVar15;
12	uVar7 = uVar7 + uVar12;
12	if (uVar17 <= uVar7) {
12	uVar7 = *local_2c;
12	local_18 = (undefined2 *)((int)local_18 + -1);
12	} while (local_18 != (undefined2 *)0x0);
12	if ((short)iVar1 == 0) {
12	if ((0 < sVar2) && (sVar2 < 0x41)) {
12	goto switchD_211a9f16_caseD_2;
12	if (DAT_212233e0 == 0) {
12	if ((short)uVar2 != 0) break;
12	iVar10 = iVar10 + param_2;
12	sVar8 = (short)iVar10;
12	pfVar6 = pfVar5;
12	goto LAB_211abc6c;
12	if (*(short *)(param_3 + 0x1c) == 7) {
12	iVar7 = *(int *)(iVar7 + 0x94);
12	if (psVar3 == (short *)0x0) {
12	if ((short)local_c != 0) goto LAB_211ae1c4;
12	local_c = 0xffffd8ef;
12	uVar3 = FUN_211ae9e0(uVar3,param_2,param_4,0,0,0,0);
12	iVar7 = DAT_21223668;
12	if (*psVar3 != 0x1a) {
12	local_10 = param_1 >> 0x10 & 0xf;
12	*param_5 = 4;
12	uVar4 = param_1 >> 0x10 & 0xf;
12	uVar3 = *puVar9;
12	*param_15 = 0.0;
12	} while (uVar10 < uVar1);
12	if ((uVar1 != 0) && (uVar10 == uVar1)) {
12	if ((short)param_4 == 3) {
12	iVar7 = *(int *)(iVar8 + 8);
12	iVar8 = *(int *)(iVar7 + *psVar9 * 4);
12	if (sVar3 < 1) goto LAB_211b308f;
12	if ((sVar3 < 0) || (7 < sVar3)) {
12	uVar8 = 0xffffffff;
12	*param_5 = 0xf;
12	*param_4 = 0xc97c;
12	if (0x27 < param_3) {
12	if (param_5 < 0xc) {
12	iVar17 = param_22 + iVar4 * 0x3c;
12	sVar13 = *(short *)(param_4 + sVar14 * 2);
12	((sVar13 == 0x20 &&
12	uVar16 = *(ushort *)(param_7 + 0x3a);
12	if (*(short *)(iVar1 + 0x10) ==
12	*(short *)(*(int *)(param_7 + 0x3c) + (uint)uVar15 * 2)) break;
12	psVar1 = psVar1 + 0x1e;
12	uVar4 = uVar4 - 1;
12	} while (uVar4 != 0);
12	pfVar2 = pfVar2 + 0xf;
12	return -0x29bb;
12	fVar4 = param_3;
12	*piVar6 = *piVar6 + sVar4 + 1;
12	uint *puVar21;
12	*param_21 = 0;
12	piVar17 = *(int **)(local_8 + 0x276);
12	local_14 = piVar17;
12	puVar7 = param_9;
12	*(undefined4 *)(local_8 + 0x1da) = 1;
12	puVar21 = param_9;
12	puVar21 = puVar21 + 1;
12	if (piVar17 != (int *)0x0) {
12	} while (piVar17 != (int *)0x0);
12	if (puVar20 != (uint *)0x0) {
12	*(undefined4 *)(local_8 + 0x1da) = 0;
12	param_14 = iVar8;
12	(local_c,s_NI_ChannelName_2120701c,
12	puVar22 = &DAT_2120c98c;
12	(**(code **)(iVar8 + 0x24))(local_c,s_p__NI_UnitDescription_21207005 + 3,puVar22);
12	(local_c,s_p__NI_UnitDescription_21207005 + 3,s_Volts_2120c99c);
12	puVar22 = &DAT_2120c994;
12	(local_c,s_p__NI_UnitDescription_21207005 + 3,&DAT_2120c990);
12	(**(code **)(*local_c + 0x2c))(local_c,s_NI_DeviceNumber_2120c9a4,(int)(short)param_1);
12	piVar18 = piVar18 + 0xe;
12	piStack_34 = local_2c;
12	piVar17 = (int *)(param_14 + 0x1c);
12	sVar4 = *(short *)((int)piVar18 + 0x2fa);
12	piVar18 = (int *)piVar18[0x25];
12	(**(code **)(*local_c + 0x24))(local_c,s_NI_ChannelName_2120701c,iVar8);
12	switch(piVar17[-1]) {
12	local_10 = (int *)0x2c;
12	*piStack_34 = (int)param_18;
12	local_18 = (uint *)((int)local_18 + 1);
12	piStack_34 = piStack_34 + 1;
12	param_17 = (int *)0x5;
12	param_17 = (int *)0x0;
12	param_15 = (int *)0x2;
12	param_17 = (int *)0x1;
12	param_15 = (int *)0x4;
12	piVar17 = piVar17 + 0xe;
12	piVar18 = param_19;
12	param_17 = *(int **)(local_8 + 0x1c2);
12	puVar20 = (uint *)0x0;
12	(**(code **)(*piVar18 + 0x10))(piVar18,puVar20,&local_c);
12	puVar20 = (uint *)((int)puVar20 + 1);
12	} while (puVar20 < param_8);
12	param_18 = param_9;
12	piVar17 = (int *)piVar17[0x25];
12	param_18 = param_18 + 1;
12	piVar18 = (int *)0x2c;
12	} while (uVar19 < *(uint *)(local_8 + 0x1ca));
12	uVar10 = ftol(2);
12	if (param_19 == 0) goto LAB_211bb7a5;
12	uVar1 = param_6[1];
12	uVar2 = param_6[2];
12	param_5[3] = param_3[3];
12	uVar1 = param_3[5];
12	param_5[4] = uVar6;
12	iStack_48 = 0;
12	*(undefined4 *)(local_8 + 0x1ea) = 0;
12	iStack_18 = *(int *)(param_11 + 10);
12	*(undefined4 *)(param_11 + 0x1c),0,0,1,0,1,1,0x51,0x51);
12	if (*(int *)(local_8 + 0x1ba) != 0) {
12	setI32Attribute(uVar9,*(undefined4 *)(iVar13 + 0x98),0x1e,
12	~-(uint)(*(int *)(local_8 + 0x1da) != 0) & (uint)param_15);
12	iVar7 = *(int *)(local_8 + 0x1be) * *(int *)(iVar3 + 10);
12	setBufferAttrs(uVar9,*(undefined4 *)(iVar13 + 0x98),
12	*(undefined4 *)(local_8 + 0x1de),*(undefined4 *)(iVar3 + 0x1c),
12	*(int *)(iVar3 + 0x1c) * *(int *)(iVar3 + 10));
12	if (param_3 != *(uint *)(local_8 + 0x1ba)) {
12	(param_15 = (int *)((int)param_15 + 1),
12	param_3 - *(int *)(local_8 + 0x1ba) <= param_15)) break;
12	iStack_48 = *(int *)(iVar13 + 0x120);
12	param_11 = uVar14;
12	setI32Attribute(uVar9,*(undefined4 *)(*(int *)(local_8 + 0x1c2) + (int)param_15 * 4)
12	setBufferAttrs(uVar9,*(undefined4 *)(*(int *)(local_8 + 0x1c2) + (int)param_15 * 4),
12	param_15 = (int *)((int)param_15 + 1);
12	} while (param_15 < *(uint *)(local_8 + 0x1ca));
12	if (*(int *)(local_8 + 0x1be) != 0) {
12	(param_15 = (int *)((int)param_15 + 1), *(uint *)(local_8 + 0x1be) <= param_15))
12	iVar7 = *(int *)(local_8 + 0x1be) * *(int *)(param_11 + 10);
12	*(int *)(param_11 + 0x1c) * *param_14 + *(int *)(iVar13 + 0x120),0,
12	*(int *)(local_8 + 0x1be),param_15,iVar7,iVar7,
12	if (((short)uVar9 != 0) && (iVar13 = FUN_21183e00(param_12), iVar13 != 0)) {
12	if (((local_10 != 0) && (*(int *)(local_10 + 0x1c1) != 0)) &&
12	sVar4 = (short)param_18[6];
12	puVar2 = param_18;
12	if (sVar4 != 0) goto LAB_211be448;
12	(double)uVar14 * *(double *)(local_8 + 0x1ee);
12	(*param_13)(param_3,param_4,param_5,param_6,uVar9,param_8,param_9,param_10,iVar3,uVar14,
12	param_17 = param_17 + uVar14 * param_3;
12	*param_14 = local_3c;
12	iVar13 = *(int *)(iVar3 + 10) - *param_14;
12	(*param_13)(param_3,param_4,param_5,param_6,uVar9,param_8,param_9,param_10,iVar3,iVar13,
12	(puVar11 = &param_17, (bVar12 & 0xf) == 6)) {
12	*param_14 = *param_19;
12	(*(uint *)(local_10 + 0x1ad) <
12	local_38 = local_38 - 1;
12	while (sVar4 = FUN_2104c0b0(param_1,*(undefined4 *)(iVar3 + 0x1c),param_14,param_18,
12	uVar6 = *param_7;
12	if (param_5 == 3) {
12	if (((char)local_2c != '\0') || (local_5 != '\0')) {
12	psVar10 = (short *)*param_10;
12	iVar19 = (int)sVar6;
12	} while (sVar6 < (short)local_10);
12	puVar12 = *(ushort **)(psVar2 + 6);
12	iVar9 = *(int *)(psVar2 + 6);
12	local_18[iVar20] = 1;
12	sVar16 = *param_3;
12	puVar12[iVar20] = 1;
12	puVar12[iVar20] = sVar16 << 2;
12	switch(*psVar2) {
12	*(undefined2 *)(iVar9 + (short)iVar19 * 2) = 0x52fd;
12	*(undefined2 *)(iVar9 + (short)iVar19 * 2) = 0x532f;
12	*(undefined2 *)(iVar9 + (short)iVar19 * 2) = 0x5339;
12	*(undefined2 *)(iVar9 + (short)iVar19 * 2) = 0x5320;
12	goto LAB_211c01e1;
12	sVar6 = psVar2[5];
12	iVar9 = *(int *)(local_c + 9);
12	local_44 = CONCAT22(local_44._2_2_,**(undefined2 **)(psVar2 + 6));
12	*(undefined4 *)(*(int *)(*(int *)(local_c + 0x15) + local_4c) + iVar9 * 4)
12	(*(int *)(*(int *)(local_c + 0x15) + 4 + local_4c) + iVar9 * 4) =
12	iVar9 = local_40;
12	(*(int *)(puVar12 + iVar19 * 0x17 + 0x13) +
12	*(undefined2 *)(*(int *)(puVar12 + iVar19 * 0x17 + 0xb) + iVar20 * 2) =
12	*(undefined2 *)(*(int *)(puVar12 + iVar19 * 0x17 + 0xb) + 2 + iVar20 * 2);
12	if (((iVar5 == 0x21) &&
12	(sVar16 = *(short *)(iVar17 + 2 + iVar20 * 2), sVar16 != 0)) {
12	*(short *)(iVar17 + iVar20 * 2) = sVar16;
12	uVar8 = puVar12[iVar19 * 0x17 + 2];
12	iVar20 = (int)sVar6;
12	uVar8 = (ushort)uVar13;
12	if (param_5[sVar2] < 0) {
12	undefined4 *puVar24;
12	if ((sVar3 != 2) && ((char)local_64 != '\0')) {
12	iVar16 = *(int *)(puVar14 + 0xd);
12	uVar10 = local_30;
12	else if ((short)local_68 !=
12	} while ((short)uVar5 < (short)puVar14[2]);
12	uVar10 = uVar15;
12	if (local_30 == 0xd) {
12	*(undefined2 *)(*(int *)(puVar14 + 0xd) + iVar9 * 2));
12	local_2c = CONCAT22((short)((uint)*(int *)(puVar14 + 0xd) >> 0x10),
12	*(short *)(*(int *)(puVar14 + 0xd) + iVar9 * 2) + -1);
12	local_24 = (uint)(short)(ushort)bVar19;
12	local_8 = CONCAT22(local_8._2_2_,uVar8);
12	if (0 < (short)local_2c) {
12	(double)*(float *)(*(int *)(*(int *)(puVar14 + 0x15) +
12	(short)local_18 * 4),&local_40);
12	uVar15 = *(uint *)(*(int *)(puVar14 + 0xf) + (short)local_14 * 4);
12	if (((short)local_34 != 0) &&
12	local_24._2_2_ = (undefined2)(local_24 >> 0x10);
12	local_24 = CONCAT22(local_24._2_2_,
12	local_24 = CONCAT22((short)((uint)*(int *)(puVar14 + 0xd) >> 0x10),
12	uVar15 = *(uint *)(*(int *)(puVar14 + 0xf) + iVar9 * 4);
12	iVar9 = (int)(short)(ushort)bVar19;
12	if (0 < (short)(ushort)local_24) {
12	local_c = FUN_211586c1(psVar18,uVar13,local_8,
12	iVar9 = (int)(short)local_18;
12	(short)local_14 * 4) + iVar9 * 2));
12	uVar15 = local_1c + 1;
12	local_1c = uVar15;
12	} while ((short)uVar15 < (short)(ushort)local_24);
12	sVar3 = *(short *)(uVar15 + (short)local_14 * 2);
12	if ((sVar3 == 6) || (sVar3 == 0xf)) {
12	if (sVar3 == 10000) {
12	local_8 = CONCAT22((short)local_14 >> 0xf,
12	*(short *)(*(int *)(puVar14 + 0xb) +
12	(short)local_14 * 2) + (short)local_1c);
12	uVar15 = FUN_21170b4a();
12	local_18 = (short)local_1c * 4;
12	(double)*(float *)(*(int *)(*(int *)(puVar14 + 0x15)
12	cVar1 = FUN_21152619(local_30);
12	uVar15 = FUN_2116aa50();
12	cVar1 = FUN_21152636(local_30);
12	(*(int *)(puVar14 + 0xd) + iVar9 * 2));
12	(short)(ushort)local_24 * 4)
12	iVar9 = *(int *)(puVar14 + 0xd);
12	goto LAB_211c2318;
12	local_48 = 10.0;
12	local_48 = 25000.0;
12	CONCAT22((short)((uint)iVar16 >> 0x10),
12	uVar15 = local_3c;
12	goto LAB_211c3149;
12	sVar3 = puVar14[2];
12	local_2c = (uint)sVar3;
12	iVar12 = (int)*(short *)(*(int *)(puVar14 + 0xd) + iVar16);
12	psVar7 = *(short **)(*(int *)(puVar14 + 0xf) + iVar9);
12	local_2c = local_2c - 1;
12	} while (local_2c != 0);
12	0x10),puVar14[2]),
12	*(undefined4 *)(puVar14 + 3),*(undefined4 *)(puVar14 + 0xd),
12	param_2,0);
12	if ((sVar3 == 8) || (sVar3 == 0x11)) {
12	iVar9 = (int)*(short *)(local_20 + *(int *)(puVar14 + 0xd));
12	psVar7 = *(short **)(local_18 + *(int *)(puVar14 + 0xf));
12	if (local_38 != 0x23) {
12	else if (**(int **)(puVar17 + 0x13) == 0x21) {
12	iVar16 = **(int **)(puVar17 + 0x13);
12	uVar15 = FUN_21180015(param_7,local_20,local_8,
12	puVar17 = puVar14;
12	puVar14 = (undefined2 *)
12	CONCAT22((short)((uint)puVar14 >> 0x10),
12	param_7 = (int)(short)local_1c;
12	} while (param_7 < *(int *)(param_4 + 1));
12	uVar15 = FUN_21150ea4(uVar8,uVar13,1);
12	uVar15 = FUN_21150ea4(uVar8,uVar13,0);
12	if ((short)param_7 == 0x1e) {
12	uVar15 = 2 - ((char)local_54 != '\0');
12	uVar15 = (uint)((char)local_54 != '\0');
12	iVar9 = FUN_21009150(param_2,0x25);
12	uVar15 = FUN_21151c34(uVar8,uVar13,1,uVar15,0,1,param_2);
12	uVar15 = FUN_211522de(uVar8,uVar13,1,param_2);
12	uVar15 = FUN_21151c34(uVar8,uVar13,2,uVar15,0,1,param_2);
12	goto LAB_211c3b82;
12	psVar7 = param_4;
12	*param_10 = -1;
12	param_4 = local_c;
12	uVar5 = CONCAT44(40000,param_2);
12	piVar10 = local_54;
12	FUN_21137720(*(undefined4 *)(iVar1 + 10));
12	if (*(short *)(param_2 + 0x14) == 1) {
12	goto LAB_211c65bc;
12	local_1c = puVar4;
12	u64::u64((u64 *)local_30,puVar5);
12	if (param_2[6] != 0) {
12	*(ushort *)(param_3 + 0x2a) =
12	goto LAB_211c88a4;
12	if (sVar3 < 0) goto LAB_211c88a4;
12	local_5 = local_5 | 1;
12	local_5 = local_5 | 2;
12	if ((ushort)param_2 != 2) {
12	bVar12 = true;
12	if (bVar12) {
12	piVar11 = local_10;
12	piVar11 = param_5;
12	} while (*piVar11 != param_3);
12	if ((ushort)param_8 != 0) {
12	iVar6 = *(int *)(iVar6 + 0x94);
12	CONCAT22(extraout_var_00,*(undefined2 *)(iVar6 + 0x374)),
12	if (param_3 == -1.0) {
12	} while (*piVar1 != local_14);
12	goto LAB_211cab46;
12	if (((sVar5 == 0) || (sVar3 < 0)) && (sVar5 = sVar3, sVar3 < 0)) {
12	FUN_211c7110(local_8);
12	if (*(short *)(local_8 + 0x14) == 1) {
12	local_40 = uVar5;
12	return 0xd88c;
12	goto LAB_211ccc3a;
12	if ((short)local_8 < 0) break;
12	} while ((short)iVar4 < (short)local_c);
12	if (0xb < param_6) {
12	*psVar1 = 4;
12	goto switchD_211cef1b_caseD_10c;
12	switch(*psVar5) {
12	goto switchD_211cf32f_caseD_2f;
12	goto switchD_211cf32f_caseD_0;
12	if ((param_1 == 0x12) || (param_1 == 0x18)) {
12	goto switchD_211cf868_caseD_109;
12	goto switchD_211cf819_caseD_0;
12	if (param_3 <= sVar2) {
12	goto LAB_211d01dd;
12	} while (sVar3 < param_4);
12	sVar2 = FUN_21142820(iVar1);
12	sVar2 = getDevicePtr(iVar1,&local_8);
12	*param_10 = (int)param_1;
12	switch(iVar11) {
12	local_1c = puVar22;
12	if ((short)local_34 == 0) {
12	*param_12 = (double)local_64;
12	sVar4 = FUN_2116aa50(local_3c,local_44,
12	uVar20 = (undefined2)((uint)local_30 >> 0x10);
12	local_40 = (uint *)CONCAT22(uVar20,sVar4);
12	iVar11 = iVar12 * 0xa8d + -0xa77;
12	uVar13 = (uint)(short)local_40;
12	uVar23 = uVar13 & 0x80000001;
12	bVar27 = uVar23 == 0;
12	bVar27 = (uVar23 - 1 | 0xfffffffe) == 0xffffffff;
12	*param_14 = (ushort)*(byte *)((int)local_8 +
12	*(short *)(*(int *)(puVar26 + 3) + (int)local_c * 2) * 0xa8d);
12	uVar23 = param_7 & 0xffff;
12	uVar23 = 2;
12	uVar8 = *(ushort *)(local_2c + 0x52);
12	if (uVar23 == *(uint *)(*(int *)(local_2c + 0x54) + (uint)uVar6 * 4)) break;
12	uVar8 = *(ushort *)(local_2c + 0x3a);
12	goto LAB_211d15bf;
12	goto LAB_211d17c8;
12	goto LAB_211d17c5;
12	uVar13 = param_7 & 0xffff;
12	iVar11 = FUN_211a0bf0(0,local_2c + 0x58);
12	piVar14 = (int *)((int)piVar14 + 0x16);
12	goto LAB_211d1a5f;
12	case (uint *)0x4:
12	case (uint *)0xe:
12	local_30 = (uint *)0x0;
12	sVar4 = FUN_21171bda(local_3c,&local_4c);
12	(local_18 != (uint *)0xd)) {
12	iVar11 = FUN_21099070(local_8);
12	uVar15 = 0x66bc;
12	uVar15 = 0x5df2;
12	uVar15 = 0x4682;
12	case (uint *)0xf:
12	if (0 < (short)puVar26[2]) {
12	iVar11 = *(int *)(puVar26 + 0x15);
12	sVar5 = *(short *)(*(int *)(puVar26 + 3) + local_2c * 2);
12	if (sVar5 <= (short)local_24[8]) {
12	} while ((int)local_2c < (int)(short)puVar26[2]);
12	local_8 = (uint *)((int)local_8 + 0x2e);
12	*(undefined4 *)(puVar26 + 0xe) = param_5;
12	*(undefined4 *)(puVar26 + 0x10) = param_6;
12	puVar26[0xc] = (ushort)param_7;
12	case (uint *)0x10:
12	case (uint *)0x11:
12	*(ulonglong *)((int)puVar22 + sVar5 * 8 + sVar7 * 0xa8d + -0xc0) =
12	case (uint *)0x12:
12	sVar7 = *(short *)(*(int *)(puVar26 + 0x13) + (int)local_c * 4);
12	if ((sVar5 < 0) || (3 < sVar5)) goto LAB_211d1434;
12	*(ulonglong *)
12	sVar5 * 8 + *(short *)(*(int *)(puVar26 + 3) + (int)local_c * 2) * 0xa8d + -0x40) =
12	case (uint *)0x13:
12	switch((ushort)param_7) {
12	case (uint *)0x14:
12	if (local_28 != (uint *)0x0) {
12	puVar26 = (undefined2 *)
12	(*(int *)(*(int *)(local_10 + 0x3f) + 2) + (int)local_1c * 0x2e);
12	*(double *)((int)puVar22 + sVar5 * 8 + sVar7 * 0xa8d + -0xc0) = *param_12;
12	uVar15 = *(undefined4 *)(local_68 + 0x28);
12	case (uint *)0x15:
12	*(double *)((int)puVar22 + sVar5 * 8 + sVar7 * 0xa8d + -0x80) = *param_12;
12	case (uint *)0x16:
12	if (((short)param_7 != 0xe) && ((short)param_7 != 0xf)) goto switchD_211d17f4_caseD_5;
12	*param_11 = uVar8;
12	if (uVar8 == 0xe) {
12	else if ((uVar8 == 0xf) && (param_4 == 0)) {
12	case (uint *)0x17:
12	if (local_28 == (uint *)0x0) goto LAB_211d1aac;
12	sVar5 = *(short *)(*(int *)(*(int *)(*(int *)(*(int *)(psVar19 + 0x3f) + 2) + 0x1e +
12	local_58 = (uint *)CONCAT22(uVar20,sVar5);
12	iVar11 = (int)local_8 + iVar12 * 0xa8d + -0xa77;
12	uVar15 = ftol(1);
12	case (uint *)0x18:
12	uVar15 = ftol(0);
12	case (uint *)0x19:
12	sVar5 + -0xe0 + *(short *)(*(int *)(puVar26 + 3) + (int)local_c * 2) * 0xa8d) =
12	case (uint *)0x1a:
12	sVar5 + -0xd8 + *(short *)(*(int *)(puVar26 + 3) + (int)local_c * 2) * 0xa8d) =
12	puVar25 = local_48;
12	sVar4 = FUN_211d4b50(local_10,local_38,local_34,&local_c,&local_44,(int)&local_28 + 2,&local_8
12	if (0 < (short)(ushort)local_c[1]) {
12	if (*(short *)(*(int *)((int)local_c + 6) + iVar11 * 2) == (short)local_44) {
12	iVar12 = iVar12 + 0x18;
12	} while (iVar11 < (short)(ushort)local_c[1]);
12	sVar4 = FUN_211492d2(local_3c,local_44,&local_8,local_4e,local_4e);
12	sVar4 = *(short *)(*(int *)(puVar26 + 0x13) + (int)local_c * 4);
12	local_58 = (uint *)CONCAT22(uVar20,sVar4);
12	sVar4 = FUN_21171bda(CONCAT22(uVar20,*puVar26),&local_18);
12	iVar11 = (int)local_18 + iVar12 * 0xa8d + -0xa77;
12	*(undefined2 *)((int)local_18 + iVar12 * 0xa8d + -0xa77)));
12	puVar6 = (ushort *)0x6982;
12	else if ((short)param_7 == 2) {
12	FUN_211d73b0(param_1,0x42cc,0xc97c);
12	FUN_211d73b0(param_1,0x42cc,*(undefined4 *)(&DAT_2120cd8c + param_6 * 4));
12	if (param_6 < 0xc) {
12	if (param_6 < 8) {
12	if (param_6 < 0x18) {
12	if (param_2 != 0xc918) {
12	FUN_211d73b0(param_1,0x83a4,0xc5e4);
12	if (param_2 == 0xc918) {
12	FUN_211d73b0(param_1,0x83a4,*(undefined4 *)(&DAT_2120ccec + param_6 * 4));
12	if (param_5 == 0x14) {
12	goto switchD_211d5ea7_caseD_c800;
12	*(undefined4 *)(&DAT_21226fb4 + iVar4) = 1;
12	FUN_211d73b0(param_1,0x42cc,*(undefined4 *)(&DAT_2120ccec + param_6 * 4));
12	iVar1 = ((short)param_1 * 0xf + -0xf + (param_1 >> 0x10 & 0xf)) * 0x1f0;
12	if (param_2 == 0xffffffff) {
12	if (0x10 < param_5) {
12	return -0x27a6;
12	8 LVSBLBVW
12	24 i386
12	FindDevLA.vi
12	1 = Set END bit on the last byte of transfer
12	status[15]- GPIB error detectedA=data string contains count data bytes from the GPIB device.
12	Open GPIB DriverPD
12	0 NULLend - Do nothing at end of transfer.OKdata string contains the data bytes that the VI sends to the GPIB device.
12	Instr Error Out Cluster.ctl*
12	Instr Error In Cluster.ctl/
12	error in (no error)HG
12	error in (no error),G
12	error in (no error) L
12	error in (no error)DNc
12	error in (no error)HP
12	error in (no error)RD
12	error in (no error)\
12	error in (no error)HF
12	error in (no error)0F-
12	error in (no error)DIc
12	error in (no error)HL
12	error in (no error)[
12	error in (no error)H
12	True if either primary or secondary addresses are outside ot the range 0-31.  address error indicates whether a range error has occurred.
12	error in (no error)4.O
12	error in (no error)01-
12	error in (no error)41
12	Calculate A16 OffsetND
12	error in (no error)4bO
12	error in (no error)<e
12	[W(string) source:  an indication of where an error occurred, usually the name of the VI.1-(bool) status: TRUE if an error has occurred.
12	error in (no error)L
12	error in (no error)'
12	Inductance Decade Box (H Terminal)
12	file path is the path name of the file. If file path is empty (default value) or is Not A Path, the VI displays a File dialog box from which you can select a file. Error 43 occurs if the user cancels the dialog.
12	Capacitor Range ary
12	sVar5 = FUN_2100a860((short)puVar3[0x14],&local_44);
12	- `Press 'Enter' when ready.`
12	hFTAB
12	uVP
12	COSMt
12	FPHPt
12	Chv>
12	vFf=
12	Pj4j
12	;Et
12	StdString
12	10.0
12	Browse...
12	+++++++++++++++
12	ffff33
12	ff33ff
12	ff3333
12	33ffff
12	33ff33
12	3333ff
12	""""""
12	LabVIEW
12	$LIbd
12	8BDHP
12	`CPTM
12	refnumum
12	pLIbd
12	Oldest compatible LabVIEW.U
12	@icl8
12	qvwww
12	BB8C
12	#bfff
12	X4%/
12	04+0
12	@| +
12	Bl +
12	440{
12	!\
12	bx /
12	Oldest compatible LabVIEW.O
12	84 3
12	8l
12	""""
12	'8'
12	Hm
12	Ticl4
12	L07-
12	T08-
12	`0;-
12	\( G
12	aPapa
12	4DLDR
12	continuous trigger
12	Volts DC
12	Volts AC
12	2-wire ohms
12	4-wire ohms
12	autorange
12	200mV, 200 ohms
12	2V, 2 kohms
12	20V, 20 kohms
12	200V, 200 kohms
12	1000Vdc, 700 Vac, 2 Mohms
12	20 Mohms
12	, F4 - 4 wire k
12	/Build command string and
12	+Read measurement and
12	0(8)
12	@9$A
12	b\4>
12	4@0q
12	4@0s
12	<4H0
12	t4J3
12	`4J3
12	h4O0
12	T4P3
12	X4U/
12	$4j3
12	X@sP
12	$Dxc
12	Mh|B
12	|0--
12	rH 3
12	0450
12	049/
12	X@DP
12	04T0
12	@4mb
12	,h4q
12	task ID out<P@
12	port number'
12	LVINLBVW?
12	a5p7
12	Tests to PerformM
12	Cal ModeM
12	TRec0
12	Continue ButtonH
12	error codeM
12	@0Input String2@P
12	Input Terminatorm@
12	Return Terminator2@P
12	Modeo.`
12	LHIST
12	F*V,
12	CALONO
12	11MD
12	LEADSHRT.viH
12	CPOR
12	CLRPARO
12	E3T5
12	`STRG
12	Error FlagW
12	EEPROM.VIS
12	Cal Factor Erasure
12	Ps_u
12	REV_CHK.viV
12	TEST FAILED!W
12	T_Setup.viU
12	@Error\FC Outgencode.cGenCopyProcs3
12	FyV{
12	BXQZ
12	HeWg
12	Caldate.viV
12	# Smpl`
12	SETLD_RD.VIU
12	AaRc
12	dSTRG
12	` W
12	04]0+
12	B]f
12	4r0
12	6Whl
12	source out@0
12	port width (8)M
12	ZPTH0
12	Devicei,
12	GAIN_CAL.VIW
12	LSTRG
12	LEAK_VLT.VIW
12	ISRC_CAL.VIW
12	Meas. HighPTH0
12	'[max characters per line]  (no limit:0)PTH0
12	O8|>
12	IND_CAL.VIV
12	SlopeR
12	*0U2a
12	Key Focus6@P
12	Symbols 0(All).
12	.cal
12	XICON
12	VPQR
12	!!f3
12	f=*S
12	Wh@
12	FSRj
12	t'!!f
12	@VW
12	$_^[]
12	QVRP
12	t[f=
12	tsf=
12	F2PQ
12	PEf;U
12	Af;M
12	_^]
12	FWP
12	EVW3
12	!WPW
12	I,PQ
12	F~PQ
12	Sjdj
12	Eu
12	NPh
12	NWh'
12	jRj/
12	E="
12	PQjqj/
12	EQPj
12	QRjRj/
12	Cf;_
12	QYf#
12	+'^]
12	y!!S
12	E Pf
12	Eh@B
12	PQVj
12	WPh)
12	767U7
12	KHzR
12	KIK@
12	0 = com1, 1 = com2
12	Timeout is in seconds.
12	8ZG\
12	ADDR 1
12	ADDR 2
12	q` <
12	@ Error\FC Out"Y
12	test.viO
12	LVINLBVWd
12	Ready
12	Status_Glob.vi^
12	DIO table for main board test.viV
12	Leakage Voltage
12	Leakage Current
12	DIO table for main board test.viH
12	0 - 18uH
12	18uH - 180uH
12	Inductance
12	Running
12	FAIL
12	0+Q+
12	Tests Chosen
12	h<$4
12	3130ND
12	Global.viU
12	Global.viV
12	DIO_R-W.VI[
12	High RangeV
12	QRhhEh
12	start path
12	Error\FC InP
12	port width (8)@
12	{EEU
12	deviceF
12	task ID out$
12	line direction mapL
12	task ID&
12	[user-defined descriptions].
12	deviceM
12	old\P
12	o<b4 g
12	False W
12	iQRP
12	Input String6@P
12	Input Terminator@
12	Return Terminator6@P
12	output error&
12	SQRVWQRP
12	XFPTD
12	lCPMp
12	StatusGlobal(
12	DIO_R-W.VISE
12	f""
12	WAIT.VIHD
12	Sample
12	Population
12	"T @
12	`BDPW
12	tRTSG
12	hVCTP
11	uint local_ec;
11	uint local_68;
11	int local_5a;
11	uVar10 = uVar9;
11	undefined2 unaff_BP;
11	bVar8 = false;
11	uVar1 = uVar4;
11	return (uint *)0x0;
11	if (uVar1 < uVar3) {
11	uVar3 = *puVar4;
11	uVar5 = 0x1000;
11	uVar2 = uVar2 << 1;
11	if (lVar7 != 0) {
11	iVar2 = 4;
11	puVar6 = puVar7;
11	undefined2 *puVar11;
11	if (iVar2 == 0) break;
11	} while (uVar8 != 0);
11	12e87 Open GPIB Driver.vi
11	12e9b Open GPIB Driver.vi
11	12eaf Open GPIB Driver.vi
11	12ec3 Open GPIB Driver.vi
11	12ed7 Open GPIB Driver.vi
11	12eeb Open GPIB Driver.vi
11	12eff Open GPIB Driver.vi
11	12f13 Open GPIB Driver.vi
11	12f27 Open GPIB Driver.vi
11	INSTR_WTB.VI
11	pos offset (bytes:0).
11	Inductance Box Cal Data File"@2
11	*.calCPlease choose the file containing the capacitance calibration data.PTH0
11	error in (no error)PD
11	LV_DIG_PORT_WRITESetCINArraySize, elmtNum %ld out of range 0 <= elmtNum < %ldnon-array detected
11	CINStartLoad: loaderror= %d, error=%ldLV_DIG_PORT_READSetCINArraySize, elmtNum %ld out of range 0 <= elmtNum < %ldnon-array detected
11	/(i16) port width: the total width in bits of the port. For example, you can combine two 4-bit ports into an 8-bit port on an MIO board by setting port width to 8.
11	Last Range Cal'd&
11	error in (no error).
11	=type of dialog determines what type dialog box will be displayed, if any. Regardless of its value, the VI outputs error information and message describing the error.
11	displays no dialog box. This is useful if you want to have programmatic control over how the error is handled.
11	(the default value) displays a dialog box with a single OK button. After the user responds, the VI returns control to the main VI.
11	displays a dialog box with buttons allowing the user to either continue or stop. If the user cancels, the VI calls the Stop function to halt execution.
11	exception action is a way for you to create exceptions to error handling. You can treat what is normally an error as no error, or treat a no error condition as an error using this parameter.
11	(the default value) performs no error exception handling.
11	cancels error under the following conditions:
11	sets error under the following conditions:
11	error code is a numeric error code. If error in indicates an error, the VI ignores error code. If not, the VI tests it. A non-zero value signifies an error.
11	cancel error on match
11	user-defined codes is an array of the numeric error codes you define in your VIs. The VI searches this array after searching the internal list of error codes. Codes in the range of 5000 to 9999 are reserved for users.
11	user-defined descriptions is an array of descriptions of user-defined codes. If an incoming error matches one in user-defined codes, the VI uses the corresponding description from user-defined descriptions in message.
11	error source is an optional string you can use to describe the source of error code. The VI uses the string in message if there is an error.
11	monnie#Hid error arrays; cosmetic changes.
11	monnie)Additions and changes to DAQ error codes.
11	monnie Correction to error description.
11	monnie+Corrected description for errors 69 and 71.
11	DAQ overFlowErr:  Because of system limitations, the driver could not read data from the device fast enough to keep up with the device throughput; the onboard device memory reported an overflow error.
11	DAQ sc2040InputModeErr: When you have an SC2040 attached to your device, all analog input channels must be configured for differential input mode.
11	DAQ semanticsErr:  An error was detected in the input string; the syntax of the string is correct, but certain values specified in the string are inconsistent with other values specified in the string.
11	LabVIEW: Argument error; that is, an input parameter is invalid.
11	GPIB EARG:  Invalid argument or arguments.bLabVIEW:  File already open.
11	GPIB ESAC:  Command requries GPIB Controller to be System Controller.FLabVIEW:  Generic file I/O error.
11	GPIB ENEB:  Non-existent board.ILabVIEW:  File permission error.
11	GPIB EDMA:  DMA hardware error detected.=LabVIEW:  Disk full.
11	GPIB EOIP:  New I/O attempted with old I/O in progress.9LabVIEW:  Too many files open.
11	GPIB EFSO:  File system operation error.PLabVIEW:  Resource file not found.
11	GPIB EBUS:  GPIB bus error.JLabVIEW:  Resource not found.
11	GPIB ESRG:  SRQ stuck on.?LabVIEW:  Image memory error.
11	GPIB EBNP:  Board not present.ALabVIEW:  Configuration token not found.
11	GPIB ETAB:  Table error.$LabVIEW:  Configuration parse error.%LabVIEW:  Configuration memory error.#LabVIEW:  Bad external code format.#LabVIEW:  Bad external code offset.$LabVIEW:  External code not present.
11	LabVIEW:  Destroy window error.
11	GPIB NADDR:  No GPIB address input.CLabVIEW:  Print driver error.
11	GPIB NSTRG:  No string input (write).QLabVIEW:  Operating system error during print.
11	GPIB NCNT:  No count input (read).$LabVIEW:  Memory error during print.
11	LabVIEW:  Print dialog error.
11	LabVIEW:  Generic print error. LabVIEW:  Invalid device refnum.
11	LabVIEW:  Device not found.!LabVIEW:  Device parameter error.
11	LabVIEW:  Device unit error.NLabVIEW:  Can't open device.
11	LabVIEW:  Generic error.%LabVIEW:  Operation canceled by user.
11	LabVIEW:  Message out of range.
11	GPIB EPAR:  Serial port parity error.
11	qTCP ncSysConnAbortedErr:  The system caused the connection to be aborted.
11	GPIB EORN:  Serial port overrun error.
11	rTCP ncConnRefusedErr:  The connection was refused by the server.
11	aTCP ncNotConnectedErr:  The connection is not established.
11	GPIB EFRM:  Serial port framing error.
11	TCP ncAlreadyConnectedErr: The connection is already established.
11	<TCP ncConnClosedErr:  The connection was closed by the peer.6Interapplication Mgr amInitErr:  Initialization error.
11	DDE:  Invalid command code.GDDE: Occurrence timeout; the transaction timed out before it completed.
11	error descriptions (hidden)*@@
11	&port width is the total width in bits of the port. For example, you can combine two 4bit ports into an 8-bit port on an MIO board by setting port width to 8.
11	=port width is the total width in bits or the number of lines of the port. For example, you can combine two 4bit ports into an 8-bit port on an MIO board by setting port width to 8.
11	start of read offset (chars.:0 )8
11	Next Range to cal&q
11	power up with
11	)))Turn on Active Load
11	u0&gf
11	) s
11	Error
11	v/f=
11	C;]
11	QRWV
11	DDO t
11	E PW
11	`BCos
11	Replace
11	Stop
11	!LVIN
11	"LVIN
11	#LVIN
11	%LVIN
11	&LVIN
11	'LVIN
11	<MQ<
11	vVf=
11	Sj$
11	vDf=
11	fFf
11	DAQTABLS: AI_TASK ALLOCATE, device %d, group %d.DAQTABLS: freeing all LVAIGroupDesc structs.DAQTABLS: AO_TASK ALLOCATE, device %d, group %d.DAQTABLS: freeing all LVAOGroupDesc structs.DAQTABLS: DIO_PORT_TASK ALLOCATE, device %d, port %d.DAQTABLS: freeing all LVDIGPortDesc structs.DAQTABLS: allocating new memory ...DAQTABLS: using existing memory.DAQTABLS: pointer is 0x%lxSetCINArraySize, elmtNum %ld out of range 0 <= elmtNum < %ldnon-array detected
11	file size (bytes)&
11	#p%
11	$hhP
11	460
11	Zedk
11	033333333
11	cfffffffffff
11	GffffffFffffffffffffffffffffffffffff
11	Logical address to read buffer from-)(U32)
11	Maximum number of bytes to transfer
11	0 = Abort if not DOR
11	1 = Poll till DOR
11	0 = Terminate transfer on END bit
11	1 = Do not terminate transfer on END
11	1 = Terminate transfer on LF bit
11	0 = Do not terminate transfer on LF
11	Bit 3
11	1 = Terminate transfer on CR bit
11	0 = Do not terminate transfer on CR
11	1 = Terminate transfer on EOS bit
11	0 = Do not terminate transfer on EOS
11	Bits 8 to 15 = EOS character (valid if EOS termination).*(U32)
11	User abort occurred during I/O
11	Transfer aborted - Device not DOR
11	Read buffer
11	rE<<
11	s?k/
11	BJQYlsP
11	Transfers the specified number of data bytes from a Message-Based device into a specified local memory buffer, using the VXIbus Byte Transfer Protocol.$
11	WSrd.vid 1rd
11	ADirL
11	STRG`
11	retcount M
11	status M
11	buf
11	mode M
11	count '
11	WSrd.vi-
11	02 8=T
11	+*****:::::::::::::::::::::::::::::*:
11	VXI logical address to write buffer to.*(U32)
11	- User abort occurred during I/O
11	Transfer aborted - Device not DIR
11	0 = Abort if not DIR
11	1 = Poll till DIR
11	0 = Clear END bit on the last byte of transfer
11	Write buffer
11	4D+
11	VVVVVV
11	YC<<
11	T8L(
11	Transfers the specified number of data bytes from a specified local memory buffer to a Message-Based device, using the VXIbus Byte Transfer Protocol.$
11	WSwrt.vi 1rd
11	retcount R
11	mode  L
11	buf '
11	WSwrt.vi'
11	<VICD
11	PCPTM
11	dLIds
11	xDFDS
11	M3\v
11	A^,g3
11	g,q3
11	c5o;
11	488.2 timeoutX
11	4882TMO.vi@
11	25000Y
11	N4[uN5[u
11	#333323#33333333333333333333
11	- <L
11	A!PJ
11	on mac?H
11	]&le
11	0driver names4
11	`)o2
11	0driver namesX
11	@-\R
11	on mac?`
11	async I/O?P
11	a*n1a+n1
11	^'kd^(kd
11	driver names'
11	.!;K.";K
11	(VICD
11	<CPTM
11	PLIds
11	dDFDS
11	xDSTM
11	{9~
11	333333333333333333333333333333333333333333333333333333333?23333332333333333333333333333
11	*:**:::*******::::::::::::::::::::::::*:
11	refnumfnu8
11	0driver names0
11	8!F`
11	;$I-
11	refnumfnuX
11	t|0
11	0Pl
11	<_"g(c%
11	%hQB
11	c8kh
11	_<gBc?
11	refnumf0
11	@ d#
11	8Y{k
11	","|
11	i(j
11	!<#|
11	) ),
11	*P)L
11	9$8h
11	,@, ,
11	D({D
11	@/@Y
11	7/@1h
11	2T2pk{s
11	3<3\3|
11	484x
11	B*l6
11	6\6|6
11	8(/ 3<<
11	3\485
11	3|4x5$5
11	4X8h0
11	8(8H8h
11	B*l7
11	9T9p
11	;D;t
11	:\8h0
11	;t>l
11	\;D6
11	<H=Ht0
11	<H>0>
11	>>L
11	<H>>l,
11	@l@(
11	MDZH
11	C0CL
11	C\C|C
11	B8C@
11	D(DH
11	DhEDE`
11	DhF<FX
11	FFh0
11	DhG4GP
11	DhH,HH
11	DhI$I@
11	EpE
11	NtNT,
11	OOpO@4
11	XQHQ(,
11	NTEpE
11	FhG`G
11	Q(z@
11	5Dv|
11	u|=dDH3<
11	_(f
11	05$h
11	tDu`u
11	,u,u|
11	0tDu
11	0tDv`v
11	(v,5D<
11	$yMp4
11	$zpMp
11	{d|P|
11	$}PMp4
11	0{d~t~0
11	0{d~
11	@Mp4
11	C|D(
11	%<$\
11	UpVl
11	[LbT
11	b8[h
11	l|iD
11	nDn|
11	n`oD
11	o(p,
11	0driver names6
11	~uy"
11	bus6
11	refnum6
11	>ELSZP
11	0driver names&@
11	<%H,<&H,
11	.gpib0ND
11	platGlob.viV
11	9"E_9#E_
11	driver namesR
11	refnumR
11	refnumr
11	.gpib0
11	.A".A
11	x?""""f>
11	x?bffff>
11	#"fff
11	):::::*:****:**:::::::*:::::::::::::::::::::::::::*:
11	6PDb
11	["iJ
11	bus&
11	address (NOADDR)&
11	count(
11	status$
11	system errorX
11	dLL\lT\
11	T4#3
11	M$L#,
11	A?MEGB
11	l4#/
11	84#0
11	al4?<E8B
11	A|0#
11	$\4#
11	h@$P
11	TNdi
11	|J<%
11	x'T'(:
11	@0%.
11	U^u~
11	[npyesm
11	xedpnjim
11	[den`im
11	d@%P
11	rM~S
11	jZ '
11	+,9,
11	9l4'/
11	D P
11	` '
11	!P '
11	!!P@'P
11	"0"4'
11	8!P9,
11	4(0%X&l&(t
11	%XQx&8
11	4(0%X&
11	%XQD&
11	%X,(
11	+,%X"
11	*|*L4(
11	+, )
11	RH,4
11	-h )
11	qd0);+
11	.D.4Z
11	.` )
11	/</,
11	/X )
11	SL/x
11	0| )
11	/x006(
11	4)00
11	_,1D
11	2h2$
11	5X5(4)
11	0*;+
11	9,9L9l *
11	QxQDQ
11	9l0|
11	Srp*
11	;4+/
11	>p +
11	> >p
11	?p +
11	MD? ?p
11	TP@,i
11	A| +
11	U A,E
11	F\4+0=
11	BPkxI
11	P4+0=
11	D84+0
11	C,TPCxi
11	D8 +
11	F@F0
11	F\ ,
11	F\@,P
11	GGT4,
11	,Bl4-/
11	H\ -
11	HH\4-0G
11	O<H|>
11	4-0H
11	I<>p
11	J -
11	JpJ,
11	iLJ<J
11	KM$
11	4-0J
11	LlL(
11	N( -
11	fhL8c
11	M$ -
11	M$4-
11	Nd -
11	<:L;0
11	mode4-
11	aL4-/
11	VX^0V
11	4-0VXWlW(
11	VXZ@W8Xp4-0VXW
11	(XTXD
11	Xp -
11	(Z@X
11	Xp@-P
11	Y Yh4-
11	`XaL
11	_|`x
11	[<\@\$\
11	a,.
11	[<]\
11	a,`80..[<]
11	\\]tW
11	](]tW
11	@[<^0]tW
11	`8`X4.
11	B](m
11	@@[<_,_|
11	0.-[<`
11	aa,aLH.
11	B](`x
11	@@[<V
11	refnumf4.
11	b|bL4.
11	c, /
11	c,,/
11	fhcLc
11	d dTd
11	JM$
11	40/
11	400e,f,
11	fH 0
11	~x40
11	i,400
11	h, 0
11	@h\e
11	i, 0
11	error&0
11	timeout (488.2 global)(0
11	count&0
11	488.2 timeout 1
11	`8@1P
11	(oHo8
11	o\ 2
11	oo\42
11	242/
11	qd 2
11	rT 2
11	r|4
11	|4rT,2
11	tdt
11	tx 2
11	o|t0
11	420s
11	uX 2
11	{$R|z(o|v
11	_,^0Z@S
11	PSLS
11	RHPtP@
11	y0yxH4
11	(z(y
11	qd-h
11	mode44/
11	|4 4
11	|do\440{
11	o\[<XpVX;
11	M$04-
11	@|44
11	o04-
11	84N
11	F04;M
11	8BH5
11	pLr(^
11	~x45
11	d05.
11	errorL5
11	Xpo\s
11	tfH05-
11	?pp5
11	OpO<
11	U UTMD
11	PJ 5
11	PJ05-
11	|J 5
11	4e,g
11	i,45
11	c,h,
11	address (NOADDR),5
11	address (NOADDR)@52
11	refnum,6
11	O'i386
11	Ph,CUh
11	V]emt{
11	GPIBOpen.viH
11	rS~hrT~h
11	FFFFM
11	FFFFMD
11	FFFFFFFFMD
11	8000V
11	4882TMO.viND
11	FFOD
11	400MD
11	\#hI\$hI
11	FFFF'
11	address (NOADDR)M
11	CK7 CK
11	Core GPIB Read.viS
11	7QCa7RCa
11	#"ff>
11	6Selects the GPIB bus on which to perform the operation.  The VI addresses the interface indicated by bus as a Listener.  If you have only one GPIB interface in your computer, the default bus number is 0. For additional GPIB interfaces, see the software installation instructions included with your GPIB board.
11	Termination mode specifies how the GPIB driver should determine when the read is finished.  All values from 0-255 (0x0-0xFF) will be taken to be an eos byte which wll stop the read when it is recieved in the data stream or when end is detected.  STOPend 256 (0x100) (the default) indicates to stop the read when end is detected.  The read  will always stop when the requested count has been read.
11	This integer represents a GPIB address.  The low byte is the primary GPIB address (0-30) and the high byte is either 0 or a secondary GPIB address (96-126 or 0x60-0x7E).  Use MakeAddress.vi to construct a GPIB address which uses secondary addressing.RNcount. The VI returns up to count data bytes from the device in data string.
11	,@FPHP
11	AMfVm
11	Vf_m
11	Qo]u
11	GPIB error,
11	4t
11	mode&
11	data stringX
11	p4$3
11	H4$3
11	@4$3
11	GPIB error&$
11	status($
11	mode&$
11	JRYl
11	($Reads data bytes from a GPIB device.$
11	Receive.viX
11	Core GPIB ReadL
11	data stringQD
11	GPIB errorN
11	statusO
11	modeH
11	Oldest compatible LabVIEW.OD
11	Receive.viB
11	g<O8<
11	x?bffffFf
11	#ffff>
11	x?"bff
11	1M?_
11	MD[l
11	AK5T<
11	T5]<
11	O>[D
11	K<]n
11	H2`q
11	bus@
11	dMrg
11	,l
11	mode,
11	busaddress list,
11	system error$
11	numeric GPIB statusX
11	n|D
11	pL!,
11	"p,!
11	t4!/
11	Hd<!
11	xHdp
11	6(6H6h
11	tHHK
11	X0!-
11	P0!
11	(pI
11	|(xLx
11	6HB<D
11	D B<6
11	d(h)
11	GTc
11	edppr
11	8*d*
11	,4,`,
11	m4m`nDDm
11	O3oS
11	TCiS^K
11	,T3iC^;
11	1x'x4#/
11	OZoz
11	Ujju_o
11	(4#0
11	LU`jj_e
11	!x0#
11	\0#.
11	d<#D
11	80#E
11	H0#E
11	4!\!L
11	!x %
11	! !x,%
11	#p4%0!
11	#p %
11	{X# #p8%:
11	"p(@$D0%;#
11	% %
11	_,0%;#
11	%l%\p
11	#p0%;#
11	&d&T
11	'x %
11	1x<%
11	'x( (
11	(  %
11	(|0%;#
11	(|2|
11	+`4%/
11	*p %
11	4%0)
11	+` %
11	$$@&P
11	1x '
11	yP1(1x4'00
11	D2`2P
11	2| '
11	2$2|@'P
11	3,3t4'
11	_,%
11	T4(/
11	74 (
11	744(06
11	|\7T6h
11	9X:9
11	:( (
11	9X},9
11	9X;:
11	;( (
11	4(09X;
11	<4 (
11	=4 (
11	9X~d=dM
11	04(09X>
11	>4 (
11	P4(09X>
11	9X{$>h
11	F,<4
11	>4@(2
11	h4)/
11	4)0@$@
11	@$},@t:(
11	@$A(@
11	AD )
11	@$}`@
11	B< )
11	Ll@)P
11	CC@C
11	D  *
11	D @*P
11	F, +
11	|4+/
11	HdIH
11	HdxLH
11	4+0HdI
11	4+08
11	P@+P
11	N<4+
11	D~dM|M
11	XRHH
11	4-0R
11	S4 -
11	T4-/
11	XT4d
11	U0 -
11	zTz y
11	S4U0
11	Y\Z(n4Z
11	^`h`g
11	^$0-
11	Yx_L
11	eXZTgd
11	t0-.Y
11	`@-P
11	]t]D4-
11	^$ .
11	8^`_ .
11	^`_,,.
11	^$h@f
11	[bxe8h
11	Zpb\bL
11	8b bx
11	bx_8/>Z(b
11	cl /
11	e80/?
11	d8dT
11	e8 /
11	e8,/
11	[ _,h
11	80/-
11	clH/
11	,0/-Y
11	<^`i
11	n`_, /
11	[ ,/
11	<klkL,/
11	kL@/P
11	l lTl
11	YxZ(i@m
11	^`n` 0
11	n` 0
11	o,o,0
11	ohoX
11	o@0P
11	p\40
11	on`
11	X-<QL
11	X-X0
11	4|_x
11	9<tP
11	tEt3
11	XV(VD
11	Yx^D^
11	i@mLl
11	i@mhv$
11	<410
11	3@1P
11	"L2,
11	refnumf@21
11	T433
11	o44/
11	L440
11	wH45
11	Pp5
11	?45/
11	d450
11	9X@$8
11	o45O
11	5D85N d
11	error(5
11	timeout (488.2 global)(5
11	488.2 timeout 6
11	error"6
11	bus"6
11	bus\6
11	@$9X6
11	.(i386
11	PhD$Uh
11	PhdHUh
11	busaddress list `@
11	busaddress list @@
11	Core GPIB Write.vi@{
11	DREL
11	FFFFW
11	platGlob.viM
11	100O
11	FFFFFFFF\
11	eNqfeOqf
11	address list
11	NEZkNFZk
11	Core GPIB Write.viR
11	2N>^2O>^
11	?>&>&ffffffff~dfffffffdffffffffffffffffffffffffffff
11	This integer represents a GPIB address.  The low byte is the primary GPIB address (0-30) and the high byte is either 0 or a secondary GPIB address (96-126 or 0x60-0x7E).  Use MakeAddress.vi to construct a GPIB address which uses secondary addressing.
11	3Selects the GPIB bus on which to perform the operation.  The VI addresses the interface indicated by bus as a Talker. If you have only one GPIB interface in your computer, the default bus number is 0. For additional GPIB interfaces, see the software installation instructions included with your GPIB board.
11	The end of transfer mode describes the method of signaling the end of the data to the listener.  Its values are:
11	2 (default) DABend - Send eoi with last byte.
11	1 NL end - Send linefeed with eoi after data.
11	address@
11	data string&
11	modeX
11	]?m_eO
11	KBYv
11	9?I_AO
11	#@1_
11	|4 3
11	04 3
11	o%_!
11	O%Z5T-
11	dZ%d5_-
11	8d%o5i-
11	|8 :
11	T:4
11	_:4
11	bus,
11	FNUh
11	$h|
11	-)Sends data bytes to a single GPIB device.$
11	Core GPIB WriteH
11	data stringM
11	byte countF
11	Oldest compatible LabVIEW.VD
11	Send.vi<
11	final countPTH0
11	lDLDR
11	(6p0O
11	,#;l
11	?%NS
11	=#PU
11	@%L+
11	logical address@
11	GPIB addressess4
11	T#cg
11	g+vS
11	h%t+
11	e#xU
11	GPIB addressess@
11	GPIB boardd4
11	GPIB boardd@
11	model coded,
11	`t
11	model codedl
11	AlA@K
11	8d4804(,)(*$0
11	0h4l9
11	H(4
11	L(4
11	/lH!
11	!t!0
11	"h"X
11	$)(`
11	@.D.4
11	@.x.
11	$2$1
11	@1X0
11	L.X1
11	logical address4
11	HXJ|L`MD
11	MDN44
11	7T5\"
11	&4'0p
11	8d90+
11	GPIB addresse"
11	GPIB addressep
11	;`L`KX4
11	1X.x
11	>d>
11	DL>0
11	EH@`D,
11	FtD,?
11	T?h
11	>xA
11	FtG
11	.FtH
11	BG4H
11	HxHXH
11	@@FtH
11	J`It
11	@@Ft9
11	IDK8
11	@@Ft3hL
11	EHDLA
11	GPIB boarddL
11	L@T|UHV
11	@@Ft.
11	KXN4
11	logical address0
11	'RxR
11	RdfffS
11	@O
11	PxN44
11	(PxN4
11	Q(KX4
11	OQxQ\w
11	Q(KX
11	OR(R
11	PxQ(Q
11	O0 S
11	T<T\L@
11	U(T|
11	exUhQ
11	d|V0V
11	W$lH,
11	UhV0,
11	WPW|W
11	Yt]|X@_
11	d|exftgphliTjPkL0
11	X@YtZ
11	hlX`X@,
11	/W$]
11	]|kL]
11	]|^4^$
11	]|hl^hX@4
11	0]|^
11	]|ft^
11	0]|_4_
11	]|_h_H4
11	W$`4`
11	aTa8
11	bdbH
11	cdcL
11	W$e\d
11	W$fXe
11	W$gTf
11	W$hPg
11	W$i8h
11	X@^H4
11	W$j4i
11	W$k0j
11	Ytbx4
11	W$l,k
11	zp{l|h}}
11	lHm8
11	K8mto
11	{lo$o
11	o`oP
11	r`r@4
11	shsH4
11	}tXmt4
11	u$u
11	v v
11	/lHv
11	wxwh
11	lHzTy
11	lH{Pz
11	lH|L{
11	mtt84
11	L@P84
11	G4O4
11	MDPX
11	model code
11	MhtFh
11	MhOh4G
11	Lh4S
11	Ph|]Uh
11	_h|]
11	Mh4Sh
11	Mh4GhO
11	>FNV]P
11	$h0
11	!#Instr Read Model Code (GPIB-VXI).vi
11	model codeO
11	F0CW
11	RREG? %d, 0M
11	Receive.viH
11	3000W
11	RREG? %d, 2M
11	Receive.vi2
11	FPHP#Instr Read Model Code (GPIB-VXI).vi
11	BFFC
11	BDHP#Instr Read Model Code (GPIB-VXI).vi
11	model codeM
11	nPTH0
11	RREG? %d, 0
11	RREG? %d, 2
11	h,uRh-uR
11	6001'
11	U$bfU%bf
11	GPIB addressM
11	@&MR@'MR
11	f``ff
11	```f`
11	`````````
11	``f`
11	LVIN#Instr Read Model Code (GPIB-VXI).vi3
11	-$:k-%:k
11	picl8
11	0#333
11	7UUUU}
11	Logical address of device to get information aboutYU(U16)
11	Base of A24/A32 memory
11	13 Size of A24/A32 memory$ (U16)
11	P$_2
11	a,pT
11	_$rV
11	d&p,
11	X.hN`>
11	I.X<
11	:BJQP
11	Gets information about a specified device from the device information table. The information is contained in a 32-bit unsigned integer.$
11	GetDevInfoLong.vi*
11	LABVIEW.30
11	VXI02CONFIG.LLB
11	longvalue M
11	b-oSb.oS
11	Q%^1Q&^1
11	3233
11	?>&>fffffffff~dffffffdfffffffffff
11	MUUUU_
11	Logical address of device to get information about
11	;(U16)
11	Commander's logical address
11	Mainframe
11	Slot
11	Manufacturer identification number
11	Model code
11	9 Device class
11	Extended subclass (if extended class device)
11	Address space used
11	Memory type and access time
11	Bit vector list of VXI interrupter lines
11	Bit vector list of VXI interrupt handler lines
11	Mainframe extender and controller information (See VXI VI manual)
11	Asynchronous mode control state
11	Response enable state
11	Protocols supported
11	Capability/status flags
11	Status state (Passed/Failed, Ready/Not Ready)$ (U16)
11	V%eS
11	aD<<
11	U&eF]6
11	F&U4
11	Gets information about a specified device from the device information table. The information is contained in a 16-bit unsigned integer.$
11	ateDevInfo.vi
11	GetDevInfoStr.vi
11	status "
11	shortvalue M
11	W&dRW'dR
11	Dr!
11	3333333?233333323333#333
11	+*:::::::::::::::::::::*:
11	0 = NI-VXI library initialized
11	1 = library already initialized
11	-1 = library initialization failed
11	Initializes the NI-VXI library and reads in the resource manager table. The library is automatically initialized when any VXI VI is used in a diagram. If you initialize the library with this VI, you must call CloseVXIlibrary later in your diagram.$
11	InitVXIlibrary.vi*
11	Oldest compatible LabVIEW.[D
11	#333323#3333333333333333333333
11	YES;T@FPHP9
11	;S$:
11	/.>q
11	8/0$
11	21A:
11	initialized4
11	controller4
11	receive modeH
11	timeout@
11	VXI logical addr@
11	GPIB boardl4
11	GPIB-VXI addrdd4
11	GPIB term char en@
11	GPIB addrdl4
11	GPIB term char4
11	map basea"
11	I/O protocol@
11	FDC channel4
11	user data c4!
11	GPIB-VXI map space@#P
11	VXI manu ID4#
11	4L %
11	VXI model code@%
11	FDC modea4%
11	)(*X
11	(0$<$|$
11	VXI map IDa4+
11	#H-R
11	VXI base addr4-
11	.<.|.
11	'$!L$(
11	map sizea01
11	!|*X)('\1
11	1@1P
11	33L3
11	VXI slota41
11	h@3P
11	5 5T5
11	map sizea43
11	instr vtl globalX5L
11	4|$
11	hWh<
11	receive mode`
11	VTL Global.vibal.vi
11	controllerM
11	VXI logical addrM
11	GPIB boardM
11	GPIB-VXI addrM
11	GPIB addrM
11	GPIB term charM
11	map baseXD
11	I/O protocolM
11	GPIB term char enWD
11	FDC channelM
11	user dataM
11	VXI manu IDM
11	FDC modeM
11	VXI model codeM
11	GPIB-VXI map spaceM
11	VXI map IDM
11	VXI base addrM
11	VXI slotM
11	map sizeM
11	send modeH
11	32@933@9
11	0/=p00=p
11	`f``
11	TKtbm
11	c"rA
11	Ata}h
11	code2@P
11	d#q@d$q@
11	Oldest compatible LabVIEW.UD
11	"  "
11	8&x.
11	a p?
11	Ar`{g
11	code<PP
11	b!o>b"o>
11	Oldest compatible LabVIEW.wD
11	}46<
11	source ("")X
11	XZK XZ
11	Hicl8
11	pLVIN
11	a>a.c.c.e.e.i.i
11	_S_Q
11	\@UUU
11	'#(U32)
11	The number of bytes to read.)%(ABC)
11	The data read from the device.3/(U32)
11	The number of bytes actually transferred.
11	read buffer<
11	return count4
11	@d%
11	byte count (0)&
11	4! +
11	code4$
11	source ("")@&P
11	instr handle in0'
11	Q"l7(
11	W'\0
11	@Y-\0
11	\-`0
11	\-`2
11	Hp+
11	error out4+
11	<! ,,
11	( h
11	code41
11	sourceX4L
11	%|04
11	#D,:
11	$t0:.
11	L0:-
11	24L;,
11	d0;.
11	T0=.
11	0D@c
11	TY<)
11	L4@b
11	) j(
11	FDTC
11	AHHL
11	|@0@-
11	,(h\@
11	! !h
11	?0@-
11	status ,A
11	"L A
11	'T B
11	V$%P%04B3
11	%0 B
11	&dY4B3"
11	&D B
11	7't
11	'T4B
11	( B
11	((,(h B
11	B|M
11	)4Bb
11	b`P@
11	?0B-
11	c [,
11	(,@B1
11	h.L.
11	buf(C
11	1H4C3
11	/P/4
11	/d C
11	(//d4C3
11	080
11	0L C
11	Y4C3-
11	-$0l1
11	141
11	1H C
11	X`-X
11	B|-$-X
11	1h-X
11	3033d C
11	4` C
11	3d0C-
11	5T C
11	5t C
11	X,jH`4[L4,1h
11	"L5T(
11	WP\T
11	bus4C
11	h`}
11	5T5tp
11	]:9
11	: 0C
11	D4`4C
11	<p0C
11	0C.24<
11	=< C
11	@24,h>4,
11	24>dS
11	8>4,
11	=\>4
11	24?$?@?\
11	DTFHL<D
11	K<L8L
11	O`0D
11	"X,D
11	O`AhAH,D
11	AH4DO
11	B`,D
11	B`4DQ
11	C0Cd
11	D@D0
11	4E/@XD
11	4E0DTE
11	DTE<E
11	DTK<E
11	8E>@XFD
11	"XH0Gx,E
11	@FL8F
11	B`0E?FF
11	Fp E
11	@FK<G
11	0E?FGDG4
11	@FL
11	GxGX0E?
11	GX E
11	@FJ
11	0E?FH
11	8E4@XH
11	@HLO`H
11	AH0E5HLI
11	0E5HLIl
11	@HLL
11	GX0E5HLI
11	@HLO
11	HLJ`
11	@XK *t
11	B`Fp4F
11	hZ@h
11	@XOD*
11	@XJDO
11	.0F-
11	HmP
11	@U0S
11	0HEU0U
11	@U0Vt
11	%05T4H
11	'T<H
11	7kj
11	V$VtS
11	B|6
11	X,WPz
11	HP@Z
11	gh H
11	B|b
11	gh0H-
11	,4H
11	X,P@[,4H
11	x]h0H
11	]44H
11	@g$e`
11	j(HJ
11	hbDg
11	g$24
11	8DJc
11	Hb`c J
11	jHb`c 4J
11	^\:P
11	cc d
11	nD0J-
11	e`b`d
11	}\d|d(4Jbg$]
11	d( J
11	j(,J
11	1H J
11	@g$a
11	g$ftfX
11	@g$c@dH
11	gh"J
11	receive modeDJc
11	dH J
11	|e`a
11	,h304Jbb
11	Z\Z|p
11	j( J
11	gh4J
11	(\Tj
11	k@ad
11	l` J
11	[L\Tl`<J
11	j(Yl`
11	(\J
11	ndnD4Jb
11	GPIB-VXI addr0J-
11	o<ox J
11	p@ J
11	gh J
11	qp`{
11	S@J1
11	r`stsX
11	r`ts
11	r`u u
11	u\u<4K3
11	u< K
11	Y4K3r`v0v
11	vlnD4K3r`v
11	vL K
11	r`}\v
11	d(4K3r`w<w(
11	$<KD
11	0KEx
11	yPy@
11	yl0KE
11	yl K
11	z\z8
11	Z [,z
11	|P@z
11	{t{d
11	|0|x
11	nD4L
11	p`u<4L
11	ylp@4L
11	nDvL4L
11	d|nd,L
11	le,b
11	tj(4Lb
11	0@LP
11	o<4N
11	0o<HN
11	X4Nb
11	status@NP
11	source ("") O
11	byte count (0)4Ob
11	,4Ob
11	\@O2
11	receive mode<P
11	(<P
11	(h4P
11	U0HP
11	@|M
11	map sizeahP
11	sourceHP
11	0i386
11	Mh$gh
11	Mh0Uh
11	"h0U
11	Mh|h@
11	xh`r
11	Mh42h
11	Mhx?hx?
11	MhTDh
11	MhFhTD
11	PhFUh
11	MhLHhF
11	PhLHUh
11	@hLH
11	JQdw~
11	HP LaserJet IIISi PostScript
11	c:\tmp\output.epsX
11	ZZde
11	Instr Read.vi Message.vie.vi
11	DX([/X)e/
11	Instrument is not initializedT
11	-1231T
11	Error inQD
11	-1231S
11	ReceiveS
11	WSrd.viT
11	errorQ
11	-1205ND
11	ReceiveND
11	-1231Y
11	r`PTH0
11	return count[
11	instr handle ino
11	byte count (0)<P@
11	byte count (0)2P@
11	@return count
11	Oldest compatible LabVIEW.WD
11	############
11	Instr Read.vi}
11	8TRec<
11	dDSIM
11	hicl8
11	~DDD|
11	<>>~
11	Tthe number of bytes actually transferred."
11	The data to be written.
11	return count"
11	return count@
11	error in (no error)@d%
11	PHp
11	write buffer ("")&
11	write buffer ("")@
11	instr handle in4
11	code4!
11	source ("")@#P
11	instr handle in0$
11	G$b9%
11	D e<
11	2 At
11	M)R2
11	@O/R2
11	R/V2
11	R/V4
11	Hp(
11	error out4(
11	status4*
11	code4.
11	sourceX1L
11	O$,1
11	$<pL8,
11	808.
11	l49
11	T0;.
11	\(0;-
11	)H0;-
11	retcount 4;/
11	@<1
11	mode  4<
11	8@=P
11	8!84=
11	)h+HH>
11	H<>D
11	)h,>
11	rtvd
11	(,)H
11	$0$4?
11	d0@.<p%
11	9<9\<
11	=d4@
11	0@E
11	(, @
11	)H0@E
11	`*<*
11	-$ A
11	*h4A3
11	*h A
11	+h+H4A3
11	+H A
11	,d,D4A3
11	,D A
11	-x5L
11	GPIB error4A
11	0D^X
11	status &B
11	status,B
11	-$4B
11	,D4B
11	`/`m
11	P.8-
11	8]07
11	0@BP
11	@<p'<9
11	:X0B-
11	A0B-
11	X:<S
11	`LB,
11	%D,B
11	9|=d>
11	@<p"
11	=$=D9| B
11	@<p'
11	0B-<p=
11	=d B
11	@<p:
11	>0:X0B-
11	<p>`Sh
11	>0:X B
11	>0:X
11	@d,B
11	>0,B
11	<p?0?L?h
11	9<=$=
11	>|4B
11	>|=$,C
11	HX<C
11	K,K|K
11	NP0C
11	@dA(
11	9\AT=
11	=D C
11	NPAtAT,C
11	AT4CO
11	Bl,C
11	Bl4CQ
11	C<Cp
11	DLD<
11	4D/@dD
11	4D0D`E
11	D`EHE(4D0
11	E( D
11	D`K,E
11	8D>@dFP
11	Bl0D?F
11	F| D
11	GPG@
11	Gd0D?
11	Gd D
11	8D4@dH
11	J ,D
11	@HXNPH
11	AT0D5HXI
11	@HXLxIH=d0D5HXIx
11	@HXK
11	Gd0D5HXI
11	@HXM
11	HXJPT
11	@dK`L
11	BlF|4E
11	@dL\L
11	I(4E
11	@dN4&
11	ATHX
11	J=D4E
11	@dO0N
11	PxPh
11	Q QTQ
11	utHF
11	utvdrt
11	X0XPX
11	$;DXX
11	\d~d
11	controller G
11	;D'<:
11	]0]P<G
11	$\\
11	`6P8
11	b0b\b
11	Fa n
11	LaP G
11	Ba oL
11	ap G
11	Ba n4
11	Ba q
11	\(,G
11	jh,G
11	a |Hb
11	cd4H3
11	cd H
11	d`dD
11	d|4H3
11	d| H
11	n4e0
11	fDf$4H3
11	f$ H
11	bus<HD
11	h0jh0HEg
11	hph`
11	i(d|0HE
11	T/|i
11	VXI logical addr H
11	@a o
11	jh,H
11	jh@HP
11	f$4I
11	}<4I
11	cdaP4I
11	ap4I
11	qlq\
11	s\ I
11	rts(s
11	s< I
11	@rt%
11	s<4Ibrts
11	@rt(
11	write buffer ("")0I
11	@vdx(v
11	0JEvdw
11	@vdx
11	wPw00JE
11	w0 J
11	@vdv0w
11	{(zT4Jb
11	z4 J
11	z44Jby
11	;DzTX
11	xx{D4Jb
11	send moder
11	L~H}\,J
11	@|HlH|
11	|H}(}
11	@|Hl
11	}\]P4Jb|H}
11	}< J
11	@|Hk
11	<DJc
11	<]P4Jb
11	`]P4Jb
11	v0x(x
11	send mode@J2
11	@a q
11	map sizea<K
11	map sizea\L
11	sourceHL
11	Mhtrh
11	Mhdvhtr
11	MhH|h a
11	bhH|
11	Mhp<h$
11	Mh`Dh
11	Fh`D
11	MhXHh
11	PhXHUh
11	@hXH
11	FM`sz
11	Transfers the specified number of data bytes from a specified local memory buffer to a device, using either the VXIbus Byte Transfer Protocol (in the case of VXIbus message-based devices), or IEEE 488.2 bus Protocol (in the case of GPIB devices).$
11	Instr Write.vite.vivivi
11	instr handle inRD
11	3!@s3"@s
11	DN*Q1N+[1
11	Instrument is not initializedMD
11	WSwrt.viND
11	Error inMD
11	SendQ
11	-1230T
11	errorQD
11	-1205Q
11	-1230P
11	SendND
11	VTL Global.viQ
11	-1230
11	instr handle outo
11	write buffer ("")<P@
11	@return count2P@
11	q ~vq!~v
11	write buffer ("")'
11	Instr Write.vit
11	,TRec9
11	DDSIM
11	#p(
11	?>&>fffffff~dffffffdfffffffffff
11	/Primary GPIB address ranging from 0 to 30.  Used to form the low order byte of the GPIB address which will be accepted by 488.2 functions.  The value of 31 (default) means return the NOADDR constant (0xFFFF) as the packed address.  The VI places primary address in the lower byte of the packed address.
11	Secondary GPIB address ranging from 0 to 30.  Used to form the high order byte of the GPIB address which will be accepted by 488.2 functions. The value of 31 (default) means use no secondary address. The VI places secondary address in the upper byte of the packed address.
11	VThis integer represents a GPIB address.  The low byte is the primary GPIB address (0-30) and the high byte is either 0 or a secondary GPIB address (96-126 or 0x60-0x7E).  packed address contains primary address in its lower byte and secondary address in its upper byte. You can use packed address as the address input to the GPIB 488.2 VIs.
11	A<bEi
11	EbNi
11	@kLq
11	primary address&
11	secondary address&
11	secondary address"
11	address error"
11	packed addressX
11	6`^
11	!0"06p
11	4`3d3
11	0(8)L)
11	x(8#
11	x3d*
11	x+t+d
11	x$1D
11	h!0#
11	h)h+
11	1D4`1
11	01D2X2
11	1D3d2$*
11	5@5\
11	Combines primary address and secondary address in a specially formatted packed address for devices that require both a primary and secondary GPIB address.$
11	96PD
11	FFFFH
11	31]D
11	secondary addressN
11	packed addressgencode.cGenDispatchEntry
11	primary address'
11	Oldest compatible LabVIEW.dD
11	MakeAddr.vi/
11	,LIds
11	@DFDS
11	TDSTM
11	HW$Ta
11	1333s
11	?>&>&fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffFffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffFffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff~dffffffffffffffffffffffdfffffffffffffffffffffffffff
11	T$Y-
11	@V*Y-
11	Y*]-
11	Y*]/
11	DD
11	code4)
11	O$,+
11	0--
11	K0.-
11	H8.4
11	P4./
11	|4.0
11	84.0
11	G(0.5
11	(0.5
11	X84.0
11	8,.
11	l0.?
11	80.?
11	(0.?
11	0.?
11	l4.Q
11	tG(,0
11	01.
11	\816
11	4017
11	`!,1
11	source41
11	NKL5
11	1 fff7
11	t"p,1
11	B01-
11	,"p$
11	%`,1
11	%`&801
11	uX 1
11	,X#P
11	&8 1
11	$|#P41
11	4('h5t
11	'|01
11	B'|(
11	(8 1
11	(X 1
11	(x,1
11	%`,2
11	) *,)@+
11	)` 2
11	*x,2
11	(8*x(X,
11	(x42
11	+` 5
11	205-
11	%`,5
11	-0-P-
11	-P,5
11	'|3\3L
11	+45O
11	0\0L
11	0p 5
11	1P0 0p,5
11	-P0p
11	+`2h
11	B'|4D0
11	(8) ,
11	HX 5
11	(X)@-0
11	(x)`-
11	3p 5
11	@'|4D.03p45O
11	3p+,45
11	'<4x5
11	4D,5
11	14:PK
11	8h8|
11	88ELL5,
11	9TVX
11	$(05.
11	B9$9
11	:0@51
11	=$=lH7
11	?< 7
11	@$@X
11	A8AT
11	T07-
11	-47/8
11	C<470
11	B0C(
11	C< 7
11	C<,7
11	B047
11	B9$D
11	YxBE, 7
11	G( 7
11	,X"<
11	HX 7
11	Hx 7
11	HXHxH
11	v47"
11	ElIP
11	JLL ,7
11	JLL
11	:l 7
11	B9$C
11	L ,7
11	:0ELL P
11	ht@71
11	9TM,L
11	laa  8
11	O,483
11	N0 8
11	Ll|<M
11	N0483LlN
11	483LlO
11	O, 8
11	208-
11	PHP|U
11	R@@48
11	SxlpS
11	4;0SxTp
11	U@4;'!
11	)` ;
11	U@)` ;
11	U@)`
11	E,L4;
11	\LBW
11	EL ;
11	X(,;
11	L  ;
11	PP|U
11	^L:04;
11	Z( <
11	Z(4<
11	Z(X(
11	\, <
11	\,4<
11	VXI logical addr4<
11	1@<P
11	_p@4<
11	_@H=
11	aDa4
11	aX >
11	aX<>
11	Z(\,_
11	aXE
11	X(4>/
11	b\ >
11	b\4>0a
11	4>0a
11	c< >
11	Nh4>/
11	d0 >
11	4>0c
11	d`aX
11	e  >
11	c<4>
11	b\e 4>
11	h8l(
11	20>-
11	htUt >
11	EhT
11	^,ht4>
11	@>Fv
11	k ,>
11	kkd >
11	jHj(0>G
11	j( >
11	0k nl0>G
11	jHL>
11	SxSDR
11	LlH>
11	ix@>1
11	oh4?3
11	nXn<
11	nl ?
11	nl4?3l
11	4?3l
11	oTo@
11	oh ?
11	~Lo
11	rPr
11	rd @
11	sD @
11	{@4@
11	{@sD
11	4@/v
11	u<u,
11	|pupm
11	uP4@
11	9T{`
11	w4wP,@
11	vTzt
11	0@.v
11	z xP
11	x<x\x
11	PHxP
11	20@-
11	z y<P
11	hT4@
11	x<yl~
11	x<yl
11	8z ,@
11	{@ @
11	{@,@
11	zT4@
11	4@/9T
11	xy<x
11	N0 @
11	zT,@
11	longvalue 4@
11	4@0~
11	HX,A
11	]p4B/v
11	zT4B0
11	w4B/
11	N0,B
11	?@BP
11	|@4B
11	OLPH
11	Dsdy
11	PTC!
11	\0C%
11	D8C(
11	X4C'
11	)` C
11	X)` C
11	-0LC,
11	H0C-
11	Nl C
11	d@CP
11	@C1
11	bus0D
11	=@FP
11	p4H"
11	statustu H
11	(0HE
11	4H"
11	/4H"
11	+4I"
11	data string4I
11	X, I
11	primary address J
11	DB4J
11	D4N3
11	4N/#$
11	L4N0
11	D4N0
11	YX4O
11	mX4O
11	h4P3
11	bus<PD
11	x0PE
11	T@QP
11	-@SF
11	$@TP
11	@L4U/
11	$4U0
11	6d U
11	P4U/#$
11	P4U0
11	l@4U
11	'l W
11	$X4W3
11	$X W
11	%h4W3
11	%h W
11	*T4W3
11	&l4W3
11	&l W
11	084W3
11	bus,W
11	*T X
11	*T@XP
11	&l4Y
11	'l4Y
11	3X Y
11	08 Y
11	4@YF
11	1d Y
11	2<0YG
11	P0YG
11	2< Y
11	2<,Y
11	2<4Y0
11	4L4Y0
11	%h4Y0
11	3X,Y
11	4L Y
11	4L4YQ
11	80 Z
11	804Z
11	800Z-
11	;T4Z
11	:xf0
11	#04Z
11	K4ZO
11	Cl Z
11	G@4]3
11	G@ ]
11	HH4]3
11	HH ]
11	IX ]
11	44]3
11	JX ]
11	bus4]
11	IX4]
11	JX\]
11	T 0^E
11	T  ^
11	HH0^E
11	X, ^
11	4^/#$
11	YX ^
11	source (""),^
11	Hx\^
11	-D _
11	f P|U
11	|H@_1
11	dx4`3
11	laa 4`/
11	|H4`/
11	cT `
11	|H4`0
11	dx,a
11	dx@aP
11	b$4b
11	cT,b
11	*,*x-
11	4b/9T
11	ix4b0
11	ix b
11	m\4b3
11	m\ b
11	ox4b3
11	n`Nb
11	laa ,b
11	ox b
11	ox@bP
11	rt4d3
11	rt d
11	sx d
11	laa ,d
11	sx4e
11	|H4e0
11	|@e1
11	n` f
11	4f/
11	|H4f0
11	rt4f0
11	\@4f
11	4g/9T
11	LlSx~
11	hl4g/
11	=4g/
11	UD g
11	`@hP
11	`4j3
11	bus4j
11	H4j/
11	$4l/
11	X4l0
11	^L l
11	%PTl
11	$0l&
11	4l"
11	44l"
11	4,l#
11	\0l$
11	X@mP
11	X4o3
11	bus4o
11	\0oE
11	L4o0
11	T4o0
11	T4oQ
11	\4r0
11	L4r0
11	t4r0
11	D4r0
11	<4r/
11	x4r/
11	,4r0
11	D4s3
11	bus s
11	t4uQ
11	VXI base addr(w
11	VXI base addr<wD
11	80wE
11	controller4x
11	.Dxc
11	controllerDxc
11	24xb
11	-Dxc
11	L4xb
11	,4xb
11	VXI slotae
11	VXI manu ID4x
11	@4xb
11	@xFW
11	$0xG
11	$4xb
11	pDxc
11	T4xb
11	VXI base addr4x
11	4xb
11	2Dxc
11	<4xb
11	`4xb
11	GPIB-VXI addrs
11	"lLx
11	}Dxc
11	VXI base addr@x2
11	,L y
11	.H4yg
11	.H y
11	- y
11	80yG
11	-,4y
11	p4yb
11	2<Dyc
11	9D y
11	2<4yb
11	9D(y
11	VXI base addr\y
11	2Dyc
11	<<4yb
11	<< y
11	<\@yP
11	>(@4y
11	A`Lz
11	GL z
11	kd(z
11	kd4zb
11	IH4z
11	KH@4z
11	\,Z(Y
11	$4{b
11	O|,{
11	O|4{
11	e@\LZH4{
11	O\E
11	0~L{
11	instr vtl globalsp4{
11	4{0
11	t4{O
11	2@{1
11	logical address$|
11	44|3
11	map sizeaD|c
11	P4|b
11	VXI logical addr |
11	9D|c
11	04|b
11	instr vtl global<|
11	VXI base addr(|
11	map sizeH|
11	map size |
11	sourceH|
11	ri386
11	Phh.
11	Mh|'h|'
11	:h$9
11	Mh0Bh
11	Mh$9h0B
11	Mh<#
11	ah<#
11	MhhN
11	PhhN
11	WhhN
11	MhxShlL
11	~hxS
11	Mh4H
11	Ph4H
11	wh4H
11	Mhlh
11	9hlh
11	Mhdz
11	Mhly
11	Mh`a
11	MhL@
11	PhL@
11	Mh W
11	MhP%
11	MhLX
11	Mh0#
11	Mhl7
11	MhX0
11	MhLS
11	shortvalue @
11	longvalue@
11	Initializes the software connection to the instrument.  In the case of VXI instruments controlled via NI-VXI, initializes the NI-VXI library, reads in the resource manager table, calculates A16 configuration addresses, determines memory requirements, and stores base addresses into A24 or A32 space.  For VXI instruments controlled via GPIB-VXI, performs all of the above except initialization of NI-VXI libraries.  You must run the INSTR Close VI once for every time you run this VI.$
11	GPIB-VXIR
11	RS-232O
11	VXIP
11	GPIB]
11	InitVXIlibrary.viND
11	GetDevInfoShort.viND
11	Init VXI Libraryb
11	Determine Memory
11	Space`
11	C000]
11	GetDevInfoLong.viND
11	-1202MD
11	MakeAddr.viND
11	FFND
11	RmEntry? %dND
11	C000MD
11	%dOD
11	256OD
11	15QD
11	-1202^
11	GetDevInfoShort.vi`
11	Slot, Manu ID, ModelMD
11	GetDevInfoShort.viMD
11	GetDevInfoShort.viQD
11	-1202ND
11	15ND
11	DU%X,U&b,
11	instr handle outUD
11	RmEntry? %d
11	source ("")'
11	`f`f
11	VVVVVVVVVV
11	+++++++++++
11	+V#+#+VVV+###+++
11	+++++++++####++
11	+++V+V++V+##++
11	##+V+
11	Instr Initialize Interface.viY
11	statusPTH0
11	logical addressPTH0)
11	4x
11	TReck
11	FTAB0
11	'<Ox
11	cbfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
11	GfffffffffffFffffffffffffffffffffffffffffffffffffffffffffffff
11	:::*
11	+***:**:***:::*****:::::::::::::::::::::*:
11	@@D@D
11	@@D@DS
11	instrument descripter,
11	instr handle outns*
11	instrument descripter4
11	|@
11	#p$
11	code4%
11	O$,'
11	|0(%
11	T8*(
11	4*0$
11	0@*P
11	VGeP
11	WBcH
11	0+I
11	(4,0
11	t\Yey
11	\Ydi`a
11	\iey`q
11	]a4,
11	!p ,
11	x!(!p
11	"` ,
11	#XH-
11	$h'<
11	"`<-
11	D.\) x$4
11	,t,X.@
11	%-L
11	%h14
11	%h%0-.$
11	&t&$
11	B%8%
11	!p -
11	&T&4&
11	!p<-
11	B%8&
11	($ -
11	@%8,
11	8.:%+8]
11	0.;++
11	+P .
11	+,0,
11	+P0.-
11	B%8-
11	-,,.
11	1`-, .
11	-x-,-
11	%.$
11	8.:%h0h]
11	/t0.;
11	/@2T]
11	/T .
11	($0.;
11	0.;.
11	040$e
11	0H .
11	%h(D4
11	/0.-
11	-x .
11	B%80
11	d4./
11	=< .
11	4.0::
11	:l .
11	4.0:;H;8
11	;|@`4.0:;
11	;\ .
11	:<8<(
11	:<l<L4.0
11	<L .
11	:=(=
11	=\=<4.0
11	=<,.
11	>X>t
11	:l4/
11	?8p4
11	=<Bhoh4//
11	@`4/0
11	?T@L
11	@` /
11	;\4/
11	t4//
11	AdA
11	Ax /
11	A0Ax
11	Bh /
11	B =<4/"
11	"R$WB
11	(@`A
11	${4/
11	G,G400
11	GpG`
11	G 0
11	H`HP
11	Ht400
11	Ht 0
11	LPIH
11	IPI@
11	J4Jh
11	K$Q(K
11	410K$L
11	L0 1
11	K$LPK
11	L0H1
11	N@gtN
11	410N@OLO
11	O` 1
11	N@Q(O
11	Ax41
11	P,PH
11	^T1
11	Q\[Z
11	41"`
11	@R$RhR
11	Q\S\S
11	@Q\C
11	,T$ 1
11	TPTlS
11	,1#V
11	@Q\]XQ
11	V8Vx,1
11	Vx,1#@
11	W\WxQ
11	V8Vx
11	W41
11	Z\41
11	V841/Q
11	XDYXY
11	Yl 1
11	XDY$Yl
11	410XDZHZ
11	Z\ 1
11	410XDZ
11	XDWZ|U
11	R$XD
11	fdkL41
11	Vx41/
11	a( 1
11	^X 1
11	_4_$
11	_h_H410
11	_H 1
11	`X`8410
11	`8 1
11	aHa(410
11	b4bh
11	c\ 2
11	cHc8
11	c|a(420b
11	c\42
11	^X42
11	dHdd
11	a(c\
11	f42/
11	fPf
11	fd 2
11	420e
11	gT 2
11	gtgAx42
11	Nm,2
11	.` 2
11	j,s0j
11	420j,k8j
11	kL 2
11	j,l4k|n
11	lhm0
11	342/
11	y8n(42/
11	nHl4n
11	420nHoTo
11	oh 2
11	o =<
11	420nHo
11	nHpo
11	rH42
11	q qpq
11	r4r$
11	G43/
11	w  3
11	tP 3
11	u`u@430
11	u@ 3
11	vPv0430
11	v0 3
11	zHw@w 430
11	w ,3
11	|x<xX
11	y|yl
11	n( 4
11	w 440m
11	tP44
11	d44/
11	440{\|h|$
11	|| 4
11	|4n(
11	{\s0|
11	}H}d
11	n(||
11	X440~`
11	440~`
11	(440
11	X44Q
11	450x
11	`45/
11	}450
11	6z.}
11	450il
11	`450il
11	V89:
11	|09;
11	l09;
11	c<=D
11	H0=E
11	`0=E
11	L=,
11	=H =
11	D@ =
11	X]X]
11	,4>/
11	(0>E
11	0@.
11	8@4@
11	h@AP
11	h0BE
11	l0BE
11	$0C.
11	d@4D
11	p<ED
11	p0EE
11	D4E/
11	$0FE
11	d@GP
11	p@IP
11	nT L
11	\pT|
11	Vx,L
11	<LD
11	U\0LE
11	44L/
11	TLL,
11	t0L-
11	NT,L
11	_X L
11	p@LP
11	"H O
11	p0OE
11	!` O
11	<0OE
11	#,4O0
11	04O0
11	#,0O.
11	<0O-
11	aP,O
11	((,O
11	((@OP
11	- ,P
11	' P
11	.` Q
11	-x Q
11	.`4Q
11	'4Q
11	-x4Q
11	!`,Q
11	T`0Q
11	_x Q
11	9l,R
11	9l@RP
11	=H0TE
11	?| T
11	9l0TE
11	AP T
11	@`4T0
11	APLT,
11	@`0T.
11	B0 T
11	<0T-
11	E\,T
11	E\@TP
11	D ,U
11	L\0U
11	D@ U
11	H ,U
11	H @UP
11	H 0VE
11	Jt0VE
11	Jt V
11	J 4V
11	B00V-
11	AP4V
11	U\,V
11	U\@VP
11	_X X
11	HT|]
11	h$ X
11	j$ Y
11	j$4Y
11	n(4Z
11	od@4[
11	o4H\
11	q\ \
11	q\0\5
11	rt4]
11	primary address ^
11	zp4^3
11	y\ ^
11	y\4^3
11	zp ^
11	zp4^
11	80^-
11	,4a3
11	primary address,a
11	(0aG
11	P@aP
11	Lb,
11	K0b-
11	s<8b4
11	h4b/
11	4b/
11	h0b5
11	l0b5
11	84b0
11	T8b>
11	s\pc
11	.@cP
11	@4c
11	s\,e
11	C@e2
11	,4fg
11	map sizea f
11	X4f/
11	84f0
11	,4f"
11	0Tf!
11	`fff
11	map sizea,f#
11	04fb
11	initialized4f
11	map sizea,f
11	54f/
11	initialized\f
11	z4f"
11	-x,f
11	0f.
11	T0fG
11	|0fG
11	(0fG
11	0h;
11	(0h;
11	map sizea0hE
11	|@4h
11	T@4i
11	,4jO
11	@4j
11	instr vtl global4k
11	4kb
11	84kb
11	t4kb
11	_4kb
11	y\4kb
11	p4kb
11	h@<k
11	$4lb
11	X@lP
11	X4mb
11	(@mP
11	H@nP
11	p<\p
11	s0zHy
11	pl4?
11	(4rg
11	80rG
11	(0rG
11	X~`{\m
11	rHnHj,e
11	Q\N@K$I
11	?T:@
11	nHN@e
11	j,{\
11	(0r-
11	map sizea4rb
11	>l r
11	$ !
11	"&"#
11	VXI map IDa&r
11	VXI logical addr&r
11	timeout"r
11	VXI slota r
11	FDC channel"r
11	user data$r
11	send mode(r
11	sourceHr
11	timeout r
11	GPIB term char&r
11	GPIB addrdr"r
11	GPIB addrdr
11	4V}ki386
11	Mh`~h
11	Ph`~Uh
11	sh`~
11	Mhlih
11	bhli
11	Mh$Kh
11	xh$K
11	MhT?h
11	Mh:hT?
11	Ph:Uh
11	@h:
11	MhHnh
11	Mh@NhHn
11	eh@N
11	Mh,jh
11	Mh\{h,j
11	Pht/Uh
11	Sh+h8%
11	Sh8%h+
11	Sh$hd
11	ShDXh$R
11	Sh$RhDX
11	Vhh\Q
11	Mhlw
11	Mh -
11	Mh<+
11	Mh|<
11	Mh<>
11	Mhx7
11	Mh v
11	t&SPVh
11	$h>
11	Converts the instrument grammar to an instrument handle.  Copy or wire the instrument handle out to the instrument handle in control of your instrument driver VI to communicate with the instrument.$
11	::MD
11	WHdOWIdO
11	INSTR{RS-232U
11	[~0-9:}]+V
11	[~:]:[~:]+MD
11	::[~0-9]+S
11	^:[~:]+ND
11	INSTR{GPIBU
11	INSTR{VXIZ
11	INSTR{GPIB-VXIMD
11	vxiP
11	GPIBMD
11	GPIB-VXIMD
11	MakeAddr.viMD
11	10000W
11	MakeAddr.viH
11	-1200H
11	256QD
11	256Y
11	VTL Global.viP
11	FPHP$Instr Parse Instrument Descriptor.vi
11	BDHP$Instr Parse Instrument Descriptor.vi
11	[~0-9:}]+
11	[~:]:[~:]+
11	::[~0-9]+
11	^:[~:]+
11	INSTR{GPIB
11	INSTR{GPIB-VXIINSTR{RS-232
11	INSTR{GPIB-VXI
11	INSTR{GPIBINSTR{RS-232
11	~:`:2
11	~0-9:}
11	X`:2
11	`:`:2
11	~0-9
11	`:`:
11	instrument descripter<P@
11	+V++++++++++++V#
11	LVIN$Instr Parse Instrument Descriptor.vib
11	TRecc
11	*::::**:**:**:::::::::::::::::::::::::*:
11	(ABC) Uniquely identifies the instrument to establish communications with.  The grammar for the instrument descriptor is shown below.  Parameters are shown in lower-case and optional parameters are shown in square brackets ([]).
11	GPIB:   INSTR{GPIB[bd]::prim addr[::sec addr]}
11	VXI:  INSTR{VXI::logical addr}
11	GPIB-VXI:   INSTR{GPIB-VXI[bd]::logical addr[prim addr]}
11	Optional Parameter Default Values:
11	bd - GPIB board (0)
11	prim addr - GPIB primary address (1)
11	sec addr - GPIB secondary address (none)
11	logical addr - VXI logical address
11	EXAMPLE:  A GPIB instrument on GPIB board 0, at primary address 5, and no secondary addressing.
11	INSTR{GPIB::5}"
11	instrument descriptor (INSTR{})4Q
11	instrument descriptor (INSTR{})4
11	source ("")H
11	code4&
11	0B`@
11	h*0_
11	VDT0+
11	P@-1
11	source ("")(.
11	error outD.c
11	status@.1
11	source ("")(/
11	d4/3
11	instrument descripterum
11	h40b
11	h |40b
11	@@02
11	b41O
11	h X
11	| 1
11	, |41
11	0!X!
11	"D"t
11	!l01G!
11	`!l)
11	"$ 1
11	#8"D
11	$$@12
11	$$ 2
11	42g#
11	.l02-
11	`#8*
11	.l(d
11	instr handle out42
11	*@$x
11	"$$$,2
11	,P*\
11	|)l.L 2
11	.L-D-
11	.L42
11	b02-
11	<-d@
11	initialized&2
11	instrument descriptor (INSTR{})$`0
11	instrument descriptor (INSTR{})$@0
11	Instr Open.viarison.vi
11	;Instr Openi
11	Instr Initialize Interface.vip
11	$Instr Parse Instrument Descriptor.viH
11	VTL Global.viM
11	source ("")M
11	instr handle out^
11	INSTR{GPIB-VXI::4}
11	instrument descriptor (INSTR{})L
11	error outUD
11	;Instr Open
11	source ("")$0@
11	instr handle out$0@
11	++VV
11	+V+###VVV
11	VV###+VV
11	+V###V+V
11	V###+VVV
11	+V##VVV+V
11	V#VV+VV+
11	+VVVVVV+
11	VVVV+V+
11	+VVVVV+
11	VVVVV+
11	+VVV+
11	Instr Open.vig
11	instrument descripterPTH0*
11	sPTH0#
11	TRec"
11	FkHT
11	error out&
11	ffffff`
11	<3<`
11	fffff`
11	<HIST
11	\LIbd
11	pBDHP
11	Colors [4]D
11	mean$
11	serpdrv
11	output error>
11	04:3
11	0@Input String
11	Oldest compatible LabVIEW.L
11	TEST PASSED!X
11	SETLD_RD.VIH
11	?PbM
11	`FTAB
11	Added several Instr. Driver errors; they are now handled like DAQ errors (either negative or positive value is recognized); delted four Analysis errors (-20057 through -20060) and corrected descriptions of several others.
11	Typo correction.
11	^.h4
11	DLIfp
11	4A0
11	CALB_SET.VIH
11	D/A Data
11	STR
11	ESR MSG
11	@0StatusGlobalgPTH0
11	tDSTM
11	D/A MSG
11	QRhhIh
11	$8 P
11	deny read/write
11	deny write-only
11	deny none
11	QRhhhhh
11	pQRh
11	8^QRhh
11	eQRP
11	_^QRP
11	QRhPhh
11	d:\automated\lv51\lvsource\gencode.cGenResetProcf
11	@+QRhh
11	t*QRP
11	TEST PASSED!H
11	t$QRRWh
11	<FPTD
11	PCPMp
11	SETLD_RD.VIPTH0
10	uVar9 = local_1c;
10	while (iVar1 != 0) {
10	*piVar2 = 0;
10	undefined2 unaff_DI;
10	byte in_CF;
10	undefined2 param_9,undefined2 param_10,undefined2 param_11,undefined2 param_12,
10	pcVar2 = (code *)swi(0x21);
10	if (iVar4 == 0) break;
10	uVar2 = puVar3[1];
10	if (puVar6 == (uint *)0x0) {
10	void Ordinal_10(void)
10	local_6 = 0;
10	FUN_21006340(param_1,0);
10	FUN_210064e0(param_1,0,0);
10	local_10 = 6;
10	char *local_30;
10	local_28 = (char *)0x0;
10	local_30 = (char *)0x0;
10	if (((short)local_2c == 0) &&
10	FUN_21004300(param_1);
10	undefined4 uVar21;
10	if (sVar8 == 8) {
10	if (sVar8 == 4) {
10	*(short *)(iVar3 + 0xaf8) = *(short *)(iVar3 + 0xaf8) + 1;
10	if ((uVar6 & 0xd5c8) != 0) {
10	sVar9 = (short)param_4;
10	if (sVar9 == 4) {
10	iVar13 = (int)sVar10;
10	switch((short)param_4) {
10	uVar7 = 0x2000;
10	FUN_211850f0(*(undefined4 *)(iVar2 + 0xc),0xe,(int)*(char *)(iVar2 + 0xae3));
10	(*(short *)(iVar2 + 0xaf8) = *(short *)(iVar2 + 0xaf8) + -1, *(short *)(iVar2 + 0xaf8) == 0))
10	FUN_2105f760(0x21,CONCAT22(uVar15,*(undefined2 *)(iVar2 + 0xaf6)),iVar2 + 0x273);
10	uint extraout_ECX_00;
10	if (sVar4 == 0x31) {
10	sVar4 = (short)iVar5;
10	local_20 = local_c;
10	*param_2 = 0x14a;
10	ushort *local_24;
10	ushort *local_60;
10	*param_22 = 0;
10	local_c = 0x203;
10	undefined1 local_98 [32];
10	iVar1 = param_1 + 1;
10	FUN_211850f0(*(undefined4 *)(param_2 + 0xc),10,0);
10	else if ((short)local_c == 1) {
10	else if (sVar8 == 1) {
10	} while (uVar10 < local_8);
10	uVar10 = local_8;
10	local_28 = local_28 + -1;
10	return (int)(short)local_54;
10	char local_a0;
10	_close((int)(short)local_c);
10	ushort local_84;
10	sVar6 = (short)local_14;
10	if (iVar7 < 0) {
10	if ((short)local_2c != 0) {
10	undefined *puVar3;
10	FUN_211850f0(*(undefined4 *)(iVar2 + 0xc),2,(int)*(char *)(iVar2 + 0xae0));
10	FUN_2105f6b0(0x21,*(undefined2 *)(iVar2 + 0xaf6),iVar2 + 0x273,0);
10	FUN_211850f0(*(undefined4 *)(param_2 + 0xc),4,0);
10	undefined1 local_36 [2];
10	byte bVar16;
10	iVar2 = param_10;
10	iVar8 = sVar6 * 0x7a;
10	if ((param_2 & 1) != 0) {
10	if ((short)param_2 < 2) {
10	iVar8 = FUN_21136300(uVar7);
10	puVar9 = (undefined4 *)FUN_21136300(uVar7);
10	iVar8 = local_24;
10	local_54[0] = 0;
10	piVar11 = (int *)*piVar11;
10	if (sVar5 != 9) {
10	undefined4 *puVar15;
10	iVar5 = param_7;
10	if (*(short *)(param_2 + 0x14a) != 0) {
10	if (param_8 == 3) {
10	sVar8 = (short)local_8;
10	if (param_6 < 2) {
10	local_28 = param_4;
10	FUN_21185030(*(undefined4 *)(param_2 + 0xc),0xb);
10	uVar7 = 0xffffffff;
10	sVar11 = 1;
10	local_3c = (undefined2)local_1c;
10	if (((short)local_8 == 0xd) || ((short)local_8 == 0xe)) {
10	*(byte *)(param_2 + 0x42d) = *(byte *)(param_2 + 0x42d) | 1;
10	*(byte *)(param_2 + 0x42d) = *(byte *)(param_2 + 0x42d) | 2;
10	if ((sVar4 == 0xd) || (sVar4 == 0xe)) {
10	if (sVar4 != 0x12) {
10	local_c = iVar13;
10	char *pcVar11;
10	undefined1 local_84 [32];
10	undefined2 local_64;
10	char *local_8;
10	if ((short)local_14 == 1) {
10	if ((short)local_14 == 2) {
10	if (uVar14 == 1) {
10	if (uVar12 == 1) {
10	else if (uVar12 == 2) {
10	uint extraout_EDX_02;
10	uint local_84 [10];
10	sVar13 = (short)param_1;
10	local_2c = (*DAT_21214104)(0x1001,param_1);
10	if ((short)local_2c == -0x2a3a) {
10	(*DAT_21214108)(0x1008,param_1);
10	uVar14 = param_4;
10	uVar7 = *puVar1;
10	uVar14 = 1;
10	int local_a0 [10];
10	local_1c = uVar14;
10	undefined1 *puVar15;
10	undefined1 local_c4 [32];
10	int *local_6c;
10	char local_29;
10	if (!bVar7) {
10	iSync *piVar3;
10	if ((-1 < sVar4) &&
10	_STCMgrControlUser_12(uVar7);
10	if (0 < (int)param_5) {
10	undefined8 local_30;
10	byte local_12 [2];
10	byte local_10 [2];
10	byte local_e [2];
10	byte local_c [2];
10	byte local_a [2];
10	byte local_8 [2];
10	byte local_6 [2];
10	FUN_210978c0(psVar2,5,0x80);
10	undefined1 local_22 [2];
10	uStack_38 = 0;
10	local_34 = dVar1;
10	uint *local_4c;
10	int *local_48;
10	iVar14 = (int)sVar13;
10	uVar7 = extraout_var_02;
10	if (sVar4 != 0) break;
10	return 0xd63c;
10	param_3 = (int *)((int)param_3 + 1);
10	undefined8 local_48;
10	char local_28;
10	char local_25;
10	if (param_1 == 0xc814) {
10	if (param_1 == 0xc80a) {
10	double local_74;
10	char *local_20;
10	local_20 = -1;
10	FUN_210b6b80(0,1,s_kWRMGateMutex_2120914c,0,0);
10	undefined4 *local_10;
10	iVar4 = FUN_210b5520(param_2,piVar9,1);
10	iVar4 = 9;
10	if (iVar5 != 1) {
10	undefined4 local_1e0;
10	undefined4 local_1dc;
10	undefined4 local_1d8;
10	undefined4 local_170;
10	undefined4 local_15c;
10	uVar4 = (undefined2)((uint)piVar3 >> 0x10);
10	local_1c = local_24;
10	*param_2 = 0x1e;
10	if (param_1 == 0x4b00) {
10	if (param_1 == 0x46b4) {
10	*param_2 = 0x4e;
10	if (param_1 == 0x6658) {
10	*param_2 = 0x66;
10	*param_2 = 0x62;
10	if (param_1 == 0x66bc) {
10	*param_2 = 0xa7;
10	if (param_1 == 0x44c0) {
10	if (param_1 == 0x447a) {
10	if (param_1 == 0x4588) {
10	if (param_1 == 0x7080) {
10	if (param_1 == 0x6fb8) {
10	else if (param_1 < 0x7aa9) {
10	if (param_1 == 0x70e4) {
10	if (param_1 == 29000) {
10	if (param_1 == 0x7b0c) {
10	if (param_1 == 0xc486) {
10	if (param_1 == 0x7c9c) {
10	if (param_1 == 32000) {
10	iVar5 = (int)param_4;
10	bVar4 = (byte)param_2;
10	undefined4 *puStack_50;
10	case 0x5a:
10	case 0xa0:
10	local_10 = local_20;
10	short *local_38;
10	param_7 = iVar5;
10	if (local_80 == 0) {
10	local_80 = 1;
10	tBufferFactory local_2c [8];
10	local_14 = local_10;
10	if (param_1 == 0x7d64) {
10	return 0xd691;
10	case 0xca6c:
10	case 0xca8a:
10	case 0xca9e:
10	case 0xcaee:
10	case 0xcaef:
10	if (param_3 != 0x42cc) {
10	case 0xc71a:
10	if (param_4 != 0x83a4) {
10	if (local_68 == 0) {
10	case 0x447a:
10	if (param_3 == 0x4446) {
10	*param_3 = 0x27;
10	else if (param_1 < 0x701d) {
10	case 0xc544:
10	*param_3 = 0x20;
10	*param_3 = 0x21;
10	*param_3 = 0x22;
10	*param_3 = 0x23;
10	*param_3 = 0x24;
10	*param_3 = 0x25;
10	if (param_1 == 0xc81e) {
10	case 0xc7ba:
10	case 0xc7c4:
10	case 0xc7c5:
10	case 0xc7c6:
10	case 0xc7c8:
10	case 0xc7c9:
10	case 0xc72e:
10	case 51000:
10	case 0xc742:
10	case 0xc74c:
10	case 0xc756:
10	case 0xc760:
10	case 0xc76a:
10	case 0xc774:
10	case 0xc77e:
10	case 0xc788:
10	case 0xc792:
10	case 0xc79c:
10	case 0xc7a6:
10	case 0x4446:
10	if (param_1 < 0x44ab) {
10	if (param_1 == 0x44fc) {
10	if (param_1 == 0x4c90) {
10	if (param_1 < 0x7c39) {
10	if (*param_4 == -1) {
10	float *pfVar15;
10	double dVar21;
10	local_18 = local_18 + 4;
10	pdVar11 = pdVar10;
10	local_c = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&local_1c);
10	if ((iVar6 == 0) &&
10	_memDelete(local_20);
10	_memDelete(local_24);
10	if (pdVar11 != (double *)0x0) {
10	_memDelete(pdVar11);
10	local_24 = uVar5;
10	double *local_2c;
10	if (param_2 < (int)param_3) {
10	puVar14 = puVar6;
10	return 0xffffb1df;
10	pdVar12 = pdVar16;
10	pdVar16 = (double *)((int)pdVar16 + -1);
10	} while (pdVar16 != (double *)0x0);
10	local_14 = local_20;
10	local_28 = local_28 + (int)param_3;
10	pdVar16 = pdVar16 + -1;
10	*(undefined4 *)param_6 = 0;
10	*(undefined4 *)((int)param_6 + 4) = 0;
10	undefined1 local_b0 [12];
10	undefined8 local_54;
10	puVar5 = tPIMMblockReferenceBase::getPointer((tPIMMblockReferenceBase *)&param_2);
10	local_60 = param_4;
10	int iStack_18;
10	case 0xfa:
10	case 0x10e:
10	case 0x149:
10	case 0x14a:
10	case 0x14b:
10	*param_7 = iVar9;
10	local_c = 0x8000004;
10	if (local_30 == 1) {
10	local_24 = 0.0;
10	uint local_ac;
10	int local_88;
10	case 0x8c:
10	local_1c = local_4c;
10	(**(code **)(*piVar1 + 8))();
10	local_24 = (undefined4 *)0x0;
10	sVar3 = (short)param_7;
10	*param_4 = 0x18;
10	bVar12 = 0;
10	sVar7 = (short)param_2;
10	undefined4 *local_28;
10	local_2c = uVar15;
10	if (puVar6 == (undefined2 *)0x0) {
10	puVar4 = (undefined2 *)0x0;
10	undefined2 uVar21;
10	uint uVar23;
10	iVar13 = local_10;
10	int *piVar18;
10	iVar20 = 0;
10	piVar18 = piVar18 + 1;
10	local_a4 = 0;
10	int local_ac;
10	int local_98;
10	short local_90;
10	uVar4 = extraout_var_07;
10	if (local_78 == 0) {
10	if (local_90 == 0) {
10	local_48 = local_48 + 1;
10	sVar2 = local_c;
10	CONCAT22(local_40 >> 0xf,local_1c[2]));
10	for (local_44 = 0; local_44 < 4; local_44 = local_44 + 1) {
10	for (local_48 = 0; local_48 < 4; local_48 = local_48 + 1) {
10	CONCAT22(local_48 >> 0xf,local_1c[2]));
10	for (local_50 = 0; local_50 < 4; local_50 = local_50 + 1) {
10	short local_60;
10	undefined2 *local_4c;
10	undefined2 local_38 [2];
10	if ((param_2 < 1) || (*(short *)(local_54 + 0x10) < param_2)) {
10	local_38[0] = 0;
10	local_4c = (undefined2 *)0x0;
10	*(uint *)(local_4c + 0x3d6) = *(uint *)(local_4c + 0x3d6) | 8;
10	short local_bc;
10	short local_b4;
10	undefined2 *local_6c;
10	char local_58;
10	char local_48;
10	char local_44;
10	char local_30;
10	local_44 = '\0';
10	local_30 = '\0';
10	local_58 = '\x01';
10	local_14[0] = 0;
10	local_58 = '\0';
10	if (param_7 == 1) {
10	local_48 = '\x01';
10	if (bVar10) {
10	local_30 = '\x01';
10	sVar2 != 0)) {
10	local_38 = 3;
10	char local_34;
10	local_2c = '\0';
10	sVar2 = sVar2 >> 0xf;
10	local_34 = '\0';
10	local_2c = '\x01';
10	else if (param_3 < 4) {
10	undefined4 *local_34;
10	uint *local_14;
10	int extraout_ECX_00;
10	int extraout_ECX_01;
10	float local_48;
10	float local_40;
10	if ((ushort)local_18 != 0) {
10	return (uint)(ushort)local_18;
10	param_5 = 0x2010;
10	puVar6 = (undefined2 *)0x0;
10	undefined1 local_78 [4];
10	undefined1 local_74 [4];
10	local_38 = 2;
10	for (local_38 = 0; local_38 < 2; local_38 = local_38 + 1) {
10	CONCAT22(extraout_var,local_24[2]));
10	sVar4 = (short)param_5;
10	byte local_38;
10	*(undefined1 *)(param_1 + 0x793) = 0;
10	*(undefined1 *)(param_1 + 0x795) = 0;
10	if ((param_5 == 0) && (param_6 == 0x3ff00000)) {
10	sbyte sVar7;
10	sVar7 = (sbyte)((local_c & 3) << 3);
10	(*(char *)(param_1 + 0x12) == '\0')) || (*(char *)(param_1 + 0x13) != '\0')) {
10	uint local_30 [2];
10	byte local_14;
10	if (uVar5 < 0x60) {
10	*(byte *)(param_1 + 0x6d7) = *(byte *)(param_1 + 0x6d7) & 0xef;
10	switch(*(undefined2 *)(param_1 + 10)) {
10	*param_4 = 0x1e;
10	*param_4 = 0x28;
10	float local_2c;
10	if (param_3 != -3) {
10	return CONCAT22(param_3 >> 0xf,0xd8e9);
10	local_c = local_c + param_5 * 4;
10	if (param_5 == 0x11) {
10	if (param_3 == -3) {
10	local_c = param_3 * 4 + 0x60 + param_5 * 2;
10	uVar4 = (uVar4 - 1 | 0xfffffffc) + 1;
10	iVar5);
10	if (param_5 != 0x11) {
10	int local_290;
10	int local_28c;
10	local_1c = 0x1e;
10	int local_74;
10	undefined1 local_60 [8];
10	uint *local_40;
10	char *local_58;
10	local_58 = (char *)0x0;
10	psVar8 = psVar8 + 4;
10	if (local_1c == (char *)0x0) {
10	if (local_24 == (char *)0x0) {
10	pcVar7 = local_1c;
10	undefined1 local_ac [32];
10	iVar9 = iVar9 + 4;
10	*puVar15 = 0;
10	if (param_5 == 0x2a) {
10	uint *local_2c;
10	local_30 = 2;
10	undefined1 local_b8 [32];
10	sVar4 = (short)param_7;
10	short *psVar18;
10	psVar18 = (short *)0x0;
10	uint __cdecl
10	FUN_211a2370(&param_1);
10	return uVar15 & 0xffff;
10	undefined1 local_c4 [4];
10	if (uVar8 == 1) {
10	else if (uVar8 == 2) {
10	*param_12 = uVar8;
10	float local_28;
10	iVar5 = param_9;
10	uVar2 = param_6;
10	sVar2 = FUN_2100a800(param_1);
10	*param_12 = 1;
10	undefined2 *puVar17;
10	sVar6 = FUN_2100a800(param_1);
10	,&local_40);
10	if ((sVar4 != 0) ||
10	if (0 < *psVar10) {
10	param_9,param_10,param_11,param_12,param_13,param_14);
10	} while ((short)param_2 < (short)param_9);
10	uVar6 = param_1 >> 0x10 & 0xf;
10	if ((short)local_8 == -1) {
10	if (param_14 != 0) {
10	undefined4 param_10,undefined4 param_11,uint param_12,undefined4 param_13,
10	FUN_211bb1c0(param_1,&param_2,&param_3,&param_4,&param_5,&param_11,&param_12,&param_13,&param_16);
10	if (((short)param_2 != 2) && ((short)param_2 != 1)) {
10	if ((int)param_12 < 0) {
10	if (((short)param_13 != 1) && ((short)param_13 != 2)) {
10	if (param_16 < 0) {
10	if ((short)param_11 == 2) {
10	param_7 = -1;
10	FUN_211bb290(param_1,param_2,param_3,param_4,param_5,param_11,param_12,param_13,param_16);
10	uint *local_8;
10	goto switchD_211d17f4_caseD_5;
10	*(undefined4 *)(&DAT_21226fb0 + iVar4) = 0x8980;
10	802de shortvalue
10	start path is the path name to the initially displayed directory (or folder) in a file dialog. The default value is Not A Path, which is the path to the last directory (or folder) shown in a file dialog.
10	0 (open) opens an existing file.  Error 7 occurs if the file cannot be found.
10	1 (open or create) opens an existing file or creates a new file if one does not exist.
10	3 (create) creates a new file.  Error 8 occurs if the file already exists.
10	advisory dialog?  Set TRUE (default) if you want a dialog if function=0 and the file does not exist, or if function=2 or 3 and the file exists.
10	at the end of the file plus pos offset.  This is the default value.
10	at the current file mark plus pos offset.
10	convert eol  Set TRUE to convert the LabVIEW end of line marker to the platform-specific marker.  Set FALSE (default value) to do nothing.
10	status is TRUE if an error occurred, or FALSE if not. If status is TRUE, code is a non-zero error code. If status is FALSE, code can be zero or a warning code."
10	advisory dialog?  Set TRUE (default) if you want a dialog if the file does not exist.
10	new file path is the path of the file opened.  You can use this output to determine the path of a file that you open using dialog.  new file path returns Not A Path if the user selects Cancel from the dialog box.
10	You can optionally use the source messages string to pass on the source of the error. Enter one line of text for each element of the error codes array.
10	The error? status  is TRUE on any error.
10	QCloses the file on command or when in incoming error occurs and returns the file size at closure.
10	file size is the size of the file in bytes at the time the file is closed; the value is zero otherwise.
10	at the end of the file plus pos offset.
10	at the current file mark plus pos offset.  This is the default value.
10	convert eol  Set TRUE to convert each platform-specific end of line marker to the LabVIEW marker, line feed.  Set FALSE (default value) to do nothing.
10	Writes a character string to a new byte stream file or appends the string to an existing file.  The VI opens or creates the file beforehand and closes it afterwards.
10	0=1.1MOhm connected to UUT leads; Same as '9'.
10	Settling Time:  Delay(mS) for relays to settle.
10	*Reads a specified number of lines from a byte stream file beginning at a specified character offset.  The VI opens the file beforehand and closes it afterwards.
10	start of read offset is the position in the file, measured in characters (or bytes), at which the VI begins reading.
10	DIO table offsetf
10	DIO table offset^
10	Set Status Message
10	Lead Zero Short/Open
10	offset past match
10	psVar12 = param_4;
10	param_8 = (undefined2 *)0x0;
10	uVar7 = (**(code **)((int)param_8 + 0x7c))(&local_8);
10	]f+
10	Pj0j
10	RPVS
10	10.00
10	OFF/ON
10	dLVIN
10	4v0
10	LVINLBVWAD
10	LVINLBVW&(
10	LVINLBVWe
10	LVINLBVWc
10	p c`
10	LVINLBVW"h
10	LVCCLBVW)t
10	LVINLBVWz
10	LVCCLBVW)0
10	STbx
10	A*^3e
10	3^=e
10	trigger mode (cont:0)&
10	send it to multimeterY
10	TUawTVaw
10	D$04=
10	LVINLBVWg`
10	323333
10	a&p[
10	8'Gl
10	K/Zj
10	@I&R-
10	R&\-
10	L/X5
10	I-\l
10	@r%{,
10	Voltage Reading@
10	FL 884XX Initialize.viZ
10	L0YiL1Yi
10	9(Fk9)Fk
10	instr{gpib
10	b'oZb(oZ
10	instrument descriptorPTH0
10	HVICD
10	\CPTM
10	2$Vk
10	2>Ak
10	E3Th
10	AC$L+
10	L$V+
10	C+Vj
10	H-T3
10	b<qh
10	As"|)
10	task ID outH
10	n1~QvA
10	].lS
10	c=pgc>pg
10	F4SgF5Sg
10	PjhL
10	3?@j3@@j
10	G4Va
10	Y&h_
10	\ h&
10	cGrl
10	' %4\
10	Z'g^Z(g^
10	$MQ$
10	f=SSr0
10	rv'f=
10	rNv^
10	fGf;~
10	Pjh<
10	daqdrvLVSBLVSB
10	H5U`H6U`
10	?(i32) line direction map: specifies the direction of each line in the port. If a bit is 0 in the line map, the line is an input line. If a bit is 1, the line is an output line. Setting line direction map to -1 makes all the lines in a port output lines. Setting line direction map to 0 makes all the lines in a port input lines. Except for the NB-TIO-10 and PC-TIO-10, this is how you must use line direction map. The NB-TIO-10 and PC-TIO-10 are the only boards on which you can configure lines within a port for different directions. The default for line direction map is 0.
10	(u32) task ID: uniquely identifies the group. You use this value as the task ID to refer to this group in subsequent digital port VI calls.
10	port width$
10	*2(<
10	DIO Port Config
10	`MQ`
10	>Vh3
10	h[
10	daqdrvLVSB
10	DAQ: digprtcf.c: allocation failedDAQ: portNumStr = %s (after truncating)DAQ: back from GET_DIGPORTDESC_DATADIGPRTCF: boardType %dDIGPRTCF: hardwarePortWidth %dDIGPRTCF: logicalPortWidth %dDIGPRTCF: numberOfPorts %dGET_DIGPORTDESC_DATALV_DIG_PORT_CONFIGSetCINArraySize, elmtNum %ld out of range 0 <= elmtNum < %ldnon-array detected
10	8HIST
10	40
10	Test Sequence P@
10	P0Current Teste
10	(DSTM
10	<vers
10	0490
10	#fff
10	Result4
10	(ICON
10	Status Cluster @
10	LEADOPEN.viH
10	0.0W
10	8DSTM
10	@ Error\FC Out"2
10	0-Ver. Cmnd(IND)z2
10	@0Input String0;
10	0-Ver. Cmnd(IND)@0
10	70ND
10	69ND
10	68ND
10	67ND
10	66ND
10	4q0
10	Test SequenceM
10	NFCH
10	0@Current Teste
10	4B3
10	Status Cluster 4
10	Gain CalibrationV
10	frequency (Hz) - ignoredpD
10	Error\FC OutO
10	Oldest compatible LabVIEW.Y
10	6>FP
10	P4G3
10	SETLD_RD.VIl
10	ESR_CAL.VIV
10	P_5g
10	EOF reached
10	mark after read (bytes)@0
10	line mode (characters:F)<@P
10	no dialog
10	OK message
10	If the VI detects an error, as described in the status and error code parameters, and if that error code value matches exception code and the error source value matches exception source, the VI sets status out to FALSE, code out to 0, and source out to an empty string. An empty exception source string matches any error source string.
10	If the VI detects no error, as described in the status and error code parameters, but the code value of error in matches exception code and the error source value matches exception source, the VI sets status out to TRUE, code out to the code value from error in, and source out to the source value from error in.
10	no exception
10	olm;
10	monnie#Added scrollbars to source strings.
10	exception handling.  This mechanism is available either to set the error out status FALSE on what is normally an error or to set the status TRUE on what is normally not an error.  If exception action > 0, the error in code and source are checked.  If they match the exception code and source, the error out status is adjusted accordingly.  That is, if the action = 1, the error out status is set to FALSE and code is set to zero and if the action = 2, the error out is set to TRUE and the code is unchanged.  An empty exception source matches any error in source.  H
10	QDSP NumBytesGTZero:  The number of bytes to allocate should be greater than zero.SDSP InvalidDataType:  The data type can only be 4 bytes long(0) or 2 bytes long(1).
10	DSP IndexSizeOffsetErr:  The size+offset should be less than or equal to the size of the DSP Handle Structure which you index into.[DSP IndexSizeGTZero:  The size of the New DSP Handle Structure should be greater than zero.FDSP OffsetGEZero:  The offset should be greater than or equal to zero.KDSP CopyNumGTZero:  The number of data to copy should be greater than zero.uDSP Invalid CopyType:  The entire/partial copy selector can only select between entire copy (0) and partial copy (1).GDSP PathnameTooLong:  The path name should be less than 256 characters.
10	DSP InvalidArrayType:  The array type can only be 32-bit floating point data(0), 16-bit long integer data(1) or 32-bit short integer data(2).:DSP AllocArrayFailed:  Failed to allocate a LabVIEW array.2DSP SourceNumErr:  You can only select one source.bDSP InvalidBytesSelect:  bytes/element selector can only select between 4 bytes(0) and 2 bytes(1).nDSP ErrInGetFunctionHandle:  An error occurred when calling the function GetIndirectFunctionHandle in the CIN.TDSP LoadDLLLibErr:  An error occurred when loading a function in dsp.dll in the CIN.MDSP NotFindFunctionInDLL:  An error occurred when loading dsp.dll in the CIN.
10	DSP GROUP_ERR.  The function ID specified does not belong to any group that is part of the DSP Library currently running on the board.
10	DSP FNC_ERR:  The function ID specified does not correspond to a function that is part of the DSP Library currently running on the board.
10	DSP NoBrdRespToTransfer:  The DSP board on which you are trying to load the COFF file is not responding to the transfer of the file.  Check if there is a board in the slot desired and verify with the DAQCONF utility.
10	DSP AddrSpaceErr:  The COFF file you are trying to load is linked with a memory map that exceeds the maximum memory space allowed by the WE DSP32C chip (2^24).GDSP CoffSectErr:  Found an unimplemented section flag in the COFF file.
10	DSP CoffHdrErr:  The file you are attempting to load to the DSP board is not created using the WE DSP32C tools (not an acceptable COFF file).gDSP COFF_FilePathErr:  Could not find the DSP Library file in the directory set by the DAQCONF utility.dDSP TimeOutErr:  The Kernel did not respond or finish function execution in the selected time limit.GDSP HandleAllocErr:  Failed to allocate a handle in the interface code.pDSP HandleSlotErr:  The DSP Handle used does not belong to the same board on which the function request is made.vDSP NotDSPHandle:  The DSP Handle specified is not valid for this board:  it has either been freed or never allocated.tDSP TransferSizeErr:  The size of requested block transfer does not have enough space allocated for it on the board.bDSP ParamSizeErr:  One of the parameters does not have enough space allocated for it on the board.PDSP PtrNotFound:  The DSP address pointer could not be found to free the buffer.
10	DSP TooManyAllocs:  The Memory Look Up Table is full:  no more allocations allowed before freeing up some DSP handles (maximum allowed = 128).wDSP HandleNotFound:  The DSP Handle specified is not found on this board:  it has either been freed or never allocated.iDSP TooBigAnOffset:  The indexing requested falls outside of the buffer into which indexing is requested.FDSP ZERO_ALLOCATION:  There are no allocated buffers on the DSP board.
10	DSP MEM_HARDWARE_ERR:  The onboard hardware diagnostic software found a memory hardware error.  Running functions on the board is unreliable.fDSP NotPowerOfTwo:  The size of the input array must be a valid power of two:  size = 2^m, 0 < m < 14.HDSP RankErr:  The rank of the filter must meet:  1 <= (2rank+1) <= size.ODSP LenGEOne:  The number of coefficients must be greater than or equal to one.XDSP FilterDesignErr:  The filter cannot be designed with the specified input parameters.lDSP LeakErr:  The leakage coefficient, Leak, must meet:  0 <= Leak <= u, where u is the step-size parameter.FDSP StepSizeErr:  The step-size parameter u must meet:  0 <= u <= 0.1.NDSP AttenGTRipple:  The attenuation must be greater than the ripple amplitude.NDSP NullVectorErr:  The input vector is null.  The unit vector does not exist.JDSP SizeGTZero:  The size of the input sequence must be greater than zero.6DSP WidthGTZero:  The width must be greater than zero.<DSP AttenGTZero:  The attenuation must be greater than zero.ADSP RippleGTZero:  The ripple ampltude must be greater than zero.UDSP Nyquist2Err:  The following conditions must be met: 0 <= f_low <= f_high <= fs/2.GDSP NyquistErr:  The cutoff frequency, fc, must meet:  0 <= fc <= fs/2.YDSP ConvSizeErr:  The number of elements of convolved arrays should be greater than zero.6DSP OrderGTZero:  The order must be greater than zero.@DSP SizeGTOrder:  The array size must be greater than the order.JDSP MixedSignErr:  The sign of y in Ax=y must be all positive or negative.HDSP Interval NumErr:  The number of intervals must be greater than zero.TDSP UpperGELower:  The upper value must be greater than or equal to the lower value.nDSP CyclesErr:  The number of cycles must be greater than zero and less than or equal to the number of samplesEDSP DutyCycleErr:  The duty cycle must meet:  0 <= duty cycle <= 100.,DSP dtGTZero:  dt must be greater than zero.ODSP WinDutyCyclesErr:  The window duty cycle value must be between 0.0 and 1.0.YDSP DelayWidthErr:  The following condition must be met:  0 <= (delay + width) < samples.BDSP WidthGEZero:  The width must be greater than or equal to zero.BDSP DelayGEZero:  The delay must be greater than or equal to zero.@DSP IndexLTSamples:  The index must meet:  0 <= index < samples.?DSP WidthLTSamples:  The width must meet:  0 < width < samples.TDSP DecFactErr:  The decimating factor must meet:  0 < decimating factor <= samples.VDSP OutOfMem:  There is not enough space left on the DSP board for onboard processing.^OutSizeGEInSize:  The output array size must be greater than or equal to the input array size.PDSP xSizeGEySize:  The size of x must be greater than or equal to the size of y.MDSP SizesGTZero:  The sizes of the input sequences must be greater than zero.ODSP Samples GETwo:  The number of samples must be greater than or equal to two.PDSP SamplesGEZero:  The number of samples must be greater than or equal to zero.DDSP SamplesGTZero:  The number of samples must be greater than zero.4Analysis InvSelectionErr:  The selection is invalid.@Analysis TableErr:  The contingency table has a negative number.TAnalysis CategoryErr:  The number of categories or samples must be greater than one.^Analysis InvProbErr:  The probability must be greater than or equal to zero and less than one.GAnalysis ProbabilityErr:  The probability must be between zero and one.AAnalysis FreedomErr:  The degrees of freedom must be one or more.LAnalysis ColumnErr:  All values in the first column of X matrix must be one.PAnalysis PoleErr:  The interpolating function has a pole at the requested value.5Analysis DistinctErr:  The x-values must be distinct.bAnalysis ModelErr:  The Random Effect model was requested when the Fixed Effect model is required.fAnalysis BalanceErr:  The data is unbalanced.  All cells must contain the same number of observations.[Analysis OverflowErr:  There is an overflow in the calculated F-value for the ANOVA Fit VI.zAnalysis DataErr:  The total number of data points must be equal to the product of levels/each factor * observations/cell.SAnalysis:  ObservationsErr:  Zero observations were made at some level of a factor.VAnalysis FactorErr:  The level of factors is outside the allowable range of some data.;Analysis LevelsErr:  The number of levels is out of range .kAnalysis SingularMatrixErr:  The system of equations cannot be solved because the input matrix is singular.DAnalysis SquareMatrixErr:  The input matrix must be a square matrix.
10	Analysis MatrixMulErr:  The number of columns in the first matrix is not equal to the number of rows in the second matrix or vector.<Analysis IntervalsErr:  The number of intervals must be > 0.iAnalysis SizeGTOrderErr:  The number of data points in the Y Values array must be greater than the order.sAnalysis MixedSignErr:  The elements of the Y Values array must be nonzero and either all positive or all negative.XAnalysis StdDevErr:  The standard deviation must be greater than zero for normalization.NAnalysis OddSizeErr:  The number of coefficients must be even for this filter.NAnalysis EvenSizeErr:  The number of coefficients must be odd for this filter.PAnalysis RankErr:  The rank of the filter must meet:  1 <= (2*rank + 1) <= size.XAnalysis EqRplDesignErr:  The filter cannot be designed with the specified input values.iAnalysis LeakErr:  The leakage coefficient, leak, and step-size parameter, u, must meet:  0 <= leak <= u.CAnalysis StepSizeErr:  The step-size, u, must meet:  0 <= u <= 0.1.ZAnalysis:  AttenGTRippleErr:  The attenuation must be greater than the ripple attenuation.8Analysis:  FinalGTZeroErr:  The final value must be > 0.0Analysis WidthGTZeroErr:  The width must be > 0.6Analysis AttenGTZeroErr:  The attenuation must be > 0.<Analysis RippleGTZeroErr:  The ripple amplitude must be > 0.[Analysis BandSpecErr:  The following conditions must be met:  0 <= f_low <= f_high <= fs/2.YAnalysis DecFactErr:  The decimating factor must meet:  0 < decimating factor <= samples.1Analysis: OrderGTZeroErr:  The order must be > 0.MAnalysis NyquistErr:  The cut-off frequency, fc, must meet:  0 <= fc <= fs/2.FAnalysis UpperGELowerErr:  The upper value must be >= the lower value.`Analysis IndexLengthErr:  The following condition must be met:  0 <= (index + length) < samples.XAnalysis IndexLTSamplesErr:  The following condition must be met:  0 <= index < samples.&Analysis DtGTZeroErr:  dt must be > 0.'Analysis DtGEZeroErr:  dt must be >= 0._Analysis DelayWidthErr:  The following conditions must be met:  0 <= (delay + width) < samples.FAnalysis WidthLTSamplesErr:  The width must meet: 0 < width < samples.SAnalysis CyclesErr:  The number of cycles must be > 0 and <= the number of samples.IAnalysis DutyCycleErr:  The duty cycle must meet: 0 <= duty cycle <= 100.RAnalysis MaxXformSizeErr:  The maximum allowable transform size has been exceeded.aAnalysis PowerOfTwoErr:  The size of the input array must be a power of two:  size = 2^m, 0<m<23.eAnalysis ArraySizeErr: The input arrays do not contain the correct number of data values for this VI.@Analysis SamplesGEThreeErr:  The number of samples must be >= 3.>Analysis SamplesGETwoErr:  The number of samples must be >= 2.>Analysis SamplesGEOneErr:  The number of samples must be >= 1.?Analysis SamplesGEZeroErr:  The number of samples must be >= 0.=Analysis SamplesGTZeroErr:  The number of samples must be >0.BAnalysis EqSamplesErr:  The input sequences must be the same size.SAnalysis OutOfMemErr:  There is not enough memory to perform the specified routine.
10	DAQ gpctrDataLossErr:  One of  more data points may have been lost during buffered GPCTR operations due to speed limitations of your system.
10	4DAQ updateRateChangeErr:  A change to the update rate is not possible at this time because 1) when waveform generation is in progress, you cannot change the interval timebase or 2) when you make several changes in a row, you must give each change enough time to take effect before requesting further changes.5DAQ miscFileErr:  An error occurred accessing a file.-DAQ writeFileErr:  Unable to write to a file.-DAQ readFileErr:  Unable to read from a file./DAQ fileSeekErr:  Unable to seek within a file.*DAQ closeFileErr:  Unable to close a file.RDAQ OpenFileError:  The configuration file or DSP kernel file could not be opened.|DAQ noDMACountAvailErr:  The driver could not obtain a valid reading from the transfer-count register in the DMA controller.
10	DAQ dmaChainingErr:  New buffer information was not available at the time of the DMA chaining interrupt; DMA transfers will terminate at the end of the currently active transfer buffer.
10	DAQ overWriteErr:  The driver wrote new data into the input transfer buffer before the data acquisition VI could retrieve the old data.
10	DAQ underWriteErr:  The data acquisition VI did not write new data to the output transfer buffer before the driver attempted to transfer the data to the device for output.
10	DAQ underFlowErr:  Because of system limitations, the driver could not write data to the device fast enough to keep up with the device throughput.
10	DAQ hardwareErr:  The hardware is not responding to the specified operation, or the response from the hardware is not consistent with the functionality of the hardware.
10	DAQ firmwareErr:  The firmware does not support the specified operation, or the firmware operation could not complete due to a data-integrity problem.mDAQ softwareErr:  The contents or the location of the driver file was changed between accesses to the driver.
10	DAQ gateSignalErr:  Attempted to start a pulse width measurement with the pulse in the phase to be measured (e.g., high phase for high-level gating).WDAQ earlyTrigErr:  The trigger occurred before sufficient pretrigger data was acquired.MDAQ noTrigFoundErr:  No trigger value was found in the input transfer buffer.
10	FDAQ overRunErr:  The clock source for the input task is faster than the maximum clock rate the device supports.  If you are allowing the driver to calculate the analog input channel clock rate, the driver bases the clock rate on the board type; so you should check that your board type is correct in the configuration utility.YDAQ earlyStopErr:  The transfer stopped prior to reaching the end of the transfer buffer.^DAQ transferStoppedErr:  The transfer has been stopped to prevent regeneration of output data.MDAQ dataNotAvailErr:  The requested amount of data has not yet been acquired.FDAQ calibrationErr:  An error occurred during the calibration process.GDAQ timeOutErr: The operation could not complete within the time limit.
10	DAQ SCXITrackHoldErr:  A signal has already been assigned to the SCXI track-and-hold trigger line, or a control call was inappropriate because the specified module is not configured for one-channel operation.~DAQ signalConflictErr:  You cannot use this combination of scan and convert clock signal sources for this operation and board.
10	DAQ polarityConflictErr:  You cannot use this combination of scan and sample clock source polarities for this operation and board.kDAQ timebaseConflictErr: You cannot use this combination of scan and sample clock timebases for this board.
10	DAQ rateNotSupportedErr: NI-DAQ was unable to convert your timebase/interval pair to match the actual hardware capabilities of this board.nDAQ multiRateModeErr: Multi-rate scanning cannot be used with the AMUX-64, SCXI, or pretriggered acquisitions.mDAQ DMAnotAllowedErr:  You have set up an operation that requires the use of interrupts.  DMA is not allowed.yDAQ unsafeSamplingFreqErr:  The sample frequency exceeds the safe maximum rate for the hardware, gains, and filters used.iDAQ extScanClockErr:  You cannot use an external scan clock when doing a single scan of a single channel.cDAQ chanClockDisabledErr:  The acquisition cannot be started because the channel clock is disabled.
10	DAQ extConvRestrictionErr:  This board does not allow an external sample clock with an external scan clock, start trigger, or stop trigger.lDAQ digitalTrigAandBErr:  This board does not allow digital triggers A and B to be enabled at the same time.pDAQ digitalTrigBErr:  Digital trigger B is illegal for the number of total scans and pretrigger scans specified.
10	DAQ noTrigEnabledErr:  The number of total scans and pretrigger scans implies that a triggered start is intended, but triggering is not enabled.SDAQ bufferInvalidErr:  A configuration change has invalidated the allocated buffer.NDAQ scanListInvalidErr:  A configuration change has invalidated the scan list.\DAQ clkExceedsBrdsMaxConvRate:  The clock rate exceeds the board's recommended maximum rate.SDAQ badChanInputModeErr:  All channels of this board must have the same input mode.PDAQ badChanCouplingErr:  All channels of this board must have the same coupling.NDAQ badChanPolarityErr:  All channels of this board must be the same polarity.JDAQ badChanRangeErr:  All channels of this board must have the same range.IDAQ badChanGainErr:   All channels of this board must have the same gain.fDAQ invalidRegenModeErr:  The specified analog output regeneration mode is not allowed for this board.sDAQ someInputsIgnoredErr:  Certain inputs were ignored because they are not relevant in the current operating mode.kDAQ noInfiniteModeErr:  Continuous input or output transfers are not allowed in the current operating mode.
10	DAQ invalidReadErr:  An attempt was made to read 0 bytes from the transfer buffer, or an attempt was made to read past the end of the transfer buffer.
10	DAQ invalidOpModeErr: The specified operating mode is invalid, or the resources have not been configured for the specified operating mode.PDAQ multTrigDrvErr:  A signal has already been assigned to the trigger resource.GDAQ noTrigDrvErr:  No signal has been assigned to the trigger resource.NDAQ slaveTrigErr:  The trigger configuration for the trigger slave is invalid.PDAQ masterTrigErr:  The trigger configuration for the trigger master is invalid.
10	DAQ delayTrigErr: The delayed trigger mode is not supported or is not available in the current configuration, or no delay source has been assigned.:DAQ postTrigErr:  No posttrigger source has been assigned.
10	DAQ preTrigErr:  The pretrigger mode is not supported or is not available in the current configuration, or no pretrigger source has been assigned.YDAQ badTrigErr:  The specified trigger signal cannot be assigned to the trigger resource.LDAQ noTrigErr:  No trigger signal has been assigned to the trigger resource.SDAQ multClkSrcErr: A source signal has already been assigned to the clock resource.XDAQ badClkSrcErr:  The specified source signal cannot be assigned to the clock resource.KDAQ noClkSrcErr:  No source signal has been assigned to the clock resource.IDAQ slaveClkErr:  The clock configuration for the clock slave is invalid.JDAQ masterClkErr: The clock configuration for the clock master is invalid.[DAQ badGroupDirErr:  The specified group does not support the specified transfer direction.\DAQ badChanDirErr:  The specified channel does not support the specified transfer direction.YDAQ badLineDirErr:  The specified line does not support the specified transfer direction.
10	DAQ badDirOnSomeLinesErr:  Some of the lines in the specified channel are not configured for the transfer direction specified.  For a write transfer, some lines are configured for input.  For a read transfer, some lines are configured for output.|DAQ transferPauseErr:  A single output channel in a group may not be paused if the output data for the group is interleaved.UDAQ transferInProgErr:  A transfer is already in progress for the specified resource.PDAQ noTransferInProgErr:  No transfer is in progress for the specified resource.7DAQ armedErr:  The specified resource is already armed.6DAQ notArmedErr:  The specified resource is not armed.rDAQ endWriteErr:  No data was written to the transfer buffer because the final data block has already been loaded.
10	DAQ activeWriteErr:  Once data generation has started, only the transfer buffers originally written to may be updated.  If DMA is active and a single transfer buffer contains interleaved channel-data, new data must be provided for all output channels currently using the DMA channel.}DAQ groupWriteErr:  The output data associated with a group must be for a single channel or must be for consecutive channels.JDAQ noWriteErr:  No output data has been written into the transfer buffer.]DAQ multSetupErr:  The specified resources have already been configured by a setup operation.SDAQ noSetupErr:  No setup operation has been performed for the specified resources.<DAQ invalidDSPhandleErr: The DSP handle input is not valid .
10	?DAQ interfaceInteractionErr: You have mixed VIs from the DAQ library and the _DAQ compatibility library (LabVIEW 2.2 style VIs).  You may switch between the two libraries only by running the DAQ VI Device Reset before calling _DAQ compatibility VIs or by running the compatibility VI Board Reset before calling DAQ VIs.RDAQ or DSP DLLInterfaceErr: The DLL could not be called due to an interface error.
10	DAQ badDMAGroupErr:  DMA cannot be configured for the specified group because it is too small, too large, or misaligned.  Consult the device user manual to determine group ramifications with respect to DMA.PDAQ DMAInUseErr:  The specified DMA channel is already in use by another device.8DAQ noDMAAvailErr:  No DMA channel is available for use.=DAQ noDMACErr:  No DMA controller is available in the system.TDAQ intInUseErr:  The specified interrupt level is already in use by another device.<DAQ noIntAvailErr:  No interrupt level is available for use.
10	DAQ virtualMemErr:  The driver is unable to make the transfer buffer contiguous in virtual memory and therefore cannot lock it into physical memory; thus, the buffer cannot be used for DMA transfers.tDAQ physicalMemErr:  A hardware error occurred in physical memory, or no memory is located at the specified address.bDAQ cacheMemErr:  A cache-related error occurred, or caching is not supported in the current mode.cDAQ stackMemErr:  The driver is unable to continue parsing a string input due to stack limitations.NDAQ memPageLockErr:  The operating environment is unable to grant a page lock.
10	DAQ memPageErr:  The transfer buffer contains a page break; system resources may require reprogramming when the page break is encountered.KDAQ memLockErr:  The transfer buffer cannot be locked into physical memory.
10	DAQ or DSP memFullErr:  No more system memory is available on the heap, or no more memory is available on the device, or insufficient disk space is available.
10	7DAQ memAlignmentErr:  The transfer buffer is not aligned properly for the current data-transfer mode.  E.g., the buffer is at an odd address, is not aligned to a 32-bit boundary, is not aligned to a 512-bit boundary, etc.  Alternatively, the driver is unable to align the buffer because the buffer is too small.jDAQ memDisabledErr:  The specified memory is disabled or is unavailable given the current addressing mode.
10	DAQ memConfigErr:  No memory is configured to support the current data-transfer mode, or the configured memory does not support the current data-transfer mode.  (If block transfers are in use, the memory must be capable of performing block transfers.)sDAQ sysOwnedRsrcErr:  The specified resource is owned by the driver and cannot be accessed or modified by the user.
10	DAQ reservedPinErr:  The selected signal requires a pin that is reserved and configured only by NI-DAQ.  You cannot configure this pin yourself.rDAQ groupAssignErr:  A group is already assigned, or the specified line or channel is already assigned to a group.lDAQ noGroupAssignErr:  No group is assigned, or the specified line or channel cannot be assigned to a group.5DAQ counterBusyErr:  The specified counter is in use.
10	DAQ relatedLCGBusyErr:  A related line, channel, or group is in use; if the driver configures the specified line, channel, or group, the configuration, data, or handshaking lines for the related line, channel, or group will be disturbed.1DAQ groupBusyErr:  The specified group is in use.2DAQ chanBusyErr:  The specified channel is in use./DAQ lineBusyErr:  The specified line is in use.+DAQ noGroupAvailErr: No group is available.-DAQ noChanAvailErr:  No channel is available.*DAQ noLineAvailErr:  No line is available.
10	DAQ or DSP deviceSupportErr:  The specified device does not support the requested action (the driver recognizes the device, but the action is inappropriate for the device)._DAQ deviceNotFoundErr:  No device is located in the specified slot or at the specified address.
10	DAQ or DSP unknownDeviceErr:  The specified device is not a National Instruments product, or the driver does not support the device (e.g., the driver was released before the device was supported).tDAQ userOwnedRsrcErr:  The specified resource is owned by the user and cannot be accessed or modified by the driver.
10	JDAQ badScanListErr: The scan list is invalid; for example, you are mixing AMUX-64T channels and onboard channels or are scanning SCXI channels out of order.  Also, the driver attempts to achieve complicated gain distributions over SCXI channels on the same module by manipulating the scan list, and returns this error if it fails.WDAQ DSPInitErr:  The DSP driver was unable to load the kernel for its operating system.
10	DAQ SCXIConfigErr:  The specified SCXI configuration parameters are invalid, or the function cannot be executed with the current SCXI configuration.
10	DAQ multConnectErr:  The specified RTSI signal is already being driven by a RTSI line, or the specified RTSI line is already being driven by a RTSI signal.JDAQ badConnectErr:  The RTSI signal/line cannot be connected as specified.vDAQ noConnectErr:  No RTSI signal/line is connected, or the specified signal and the specified line are not connected.
10	DAQ DAQCardConfErr:  Cannot configure the DAQCard because 1) the correct version of the card and socket services software is not installed; 2) the card in the PCMCIA socket is not a DAQCard; or 3) the base address and/or interrupt level requested are not available according to the card and socket services resource manager.  Try different settings or use AutoAssign in the NIDAQ configuration utility.sDAQ jumperlessBoardErr: NI-DAQ was unable to find one or more jumperless boards you have configured using wdaqconf.FDAQ dupDMAErr:  The DMA channels for two or more devices are the same.vDAQ dmaConfigErr:  The DMA configuration is incorrect given the capabilities of the computer/DMA controller or device.JDAQ dupIntErr:  The interrupt levels for two or more devices are the same.mDAQ intConfigErr:  The interrupt configuration is incorrect given the capabilities of the computer or device.
10	DAQ dupAddressErr:  The base addresses for two or more devices are the same; consequently, the driver is unable to access the specified device.
10	DAQ or DSP cmosConfigErr: The CMOS configuration-memory for the device is empty or invalid, or the configuration specified does not agree with the current configuration of the device, or the EISA system configuration is invalid.^DAQ communicationsErr: The driver is unable to communicate with the specified external device.
10	DAQ osInitErr:  The driver encountered an operating-system error while attempting to perform an operation, or the operating system does not support an operation performed by the driver.~DAQ deviceInitErr:  The driver encountered a hardware-initialization error while attempting to configure the specified device.
10	DAQ or DSP configFileErr:  The driver could not locate or open the configuration file, or the format of the configuration file is not compatible with the currently installed driver.NDAQ functionNotFoundErr:  The specified function is not located in the driver.WDAQ oldDriverErr:  One of the driver files or the configuration utility is out of date.KDAQ noDriverErr:  The driver interface could not locate or open the driver.cDAQ badPortWidthErr: The requested digital port width is not a multiple of the hardware port width.
10	DAQ badIterationsErr:  The analog output buffer iterations count is not allowed.  It must be 0 (for indefinite iterations) or 1.oDAQ badRPGErr:  The individual range, polarity, and gain settings are valid but the combination is not allowed.}DAQ badTotalCountErr:  The total count is inconsistent with the buffer size and pretrigger scan count or with the board type.3DAQ badTrigLevelErr:  The trigger level is invalid.1DAQ badTrigTypeErr:  The trigger type is invalid.6DAQ badExtRefErr:  The external reference  is invalid.PDAQ badTrigRangeErr:  The trigger range or trigger hysteresis window is invalid.3DAQ badTrigCountErr:  The trigger count is invalid.1DAQ badTrigModeErr:  The trigger mode is invalid.BDAQ badPosttrigCountErr:  The posttrigger sample count is invalid.?DAQ badPretrigCountErr: The pretrigger sample count is invalid.%DAQ badGainErr:  The gain is invalid.UDAQ badFilterCutoffErr:  The cutoff frequency specified is not valid for this device.
10	-DAQ badDAQEventErr: For DAQEvents 0 and 1 general value A must be greater than 0 and less than the internal buffer size.  If DMA is used for DAQEvent 1 general value A must divide the internal buffer size evenly, with no remainder.  If the TIO-10 is used for DAQEvent 4 general value A must be 1 or 2.
10	DAQ badBufferSpec:  The requested number of buffers or the buffer size is not allowed; e.g., Lab-PC buffer limit is 64K samples, or the board does not support multiple buffers.
10	DAQ limitsOutOfRange:  The requested input limits exceed the board's capability or configuration.  Alternative limits were selected.tDAQ badWriteOffsetErr:  Adding the write offset to the write mark places the write mark outside the internal buffer.FDAQ badWriteModeErr:  The write mode is out of range or is disallowed.
10	DAQ badWriteCountErr:  Your data array contains an incomplete update, or you are trying to write past the end of the internal buffer, or your output operation is continuous and the length of your array is not a multiple of one half of the internal buffer size.?DAQ badLimitsErr: The limits are beyond the range of the board.-DAQ badTimebaseErr:  The timebase is invalid.2DAQ badClkFrequencyErr.  The frequency is invalid.1DAQ badReadOffsetErr:  The offset is unreachable..DAQ badReadModeErr:  The read mode is invalid.0DAQ badReadCountErr:  The read count is invalid.0DAQ badTimeLimitErr:  The time limit is invalid.ADAQ groupTooLargeErr:  The group size is too large for the board.QDAQ badErrorCodeErr:  The driver returned an unrecognized or unlisted error code.gDAQ badRangeErr:  The analog input or analog output voltage range is invalid for the specified channel.
10	DAQ badIntervalErr:  The analog input scan rate is too fast for the number of channels and the channel clock rate; or the given clock rate is not supported by the associated counter channel or I/O channel.
10	DAQ badCountErr:  The count is too small or too large for the specified counter; or the given I/O transfer count is not appropriate for the current buffer or channel configuration.+DAQ badCounterErr:  The counter is invalid.&DAQ badGroupErr: The group is invalid.
10	DAQ badChanErr:  A channel is out of range for the board type or input configuration; or the combination of channels is not allowed; or the scan order must be reversed (0 last).%DAQ badLineErr:  The line is invalid.0DAQ or DSP badDeviceErr:  The device is invalid.
10	DAQ valueConflictErr:  The value of a numeric parameter is inconsistent with another one, and therefore the combination is invalid.BDAQ invalidValueErr:  The value of a numeric parameter is invalid.
10	DAQ syntaxErr:  An error was detected in the input string; the arrangement or ordering of the characters in the string is not consistent with the expected ordering.*Instr. Driver:  Instrument-specific error.4Instr. Driver:  Function not suported by controller.,Instr. Driver:  Error accessing VXI address.,Instr. Driver:  Error unmapping VXI address.*Instr. Driver:  Error mapping VXI address.%Instr. Driver:  Instrument timed out.-Instr. Driver:  Error in configuring timeout.7Instr. Driver:  Error interpreting instrument response.7Instr. Driver:  Error placing instrument in local mode.+Instr. Driver:  Instrument not initialized..Instr. Driver:  Error reading from instrument.,Instr. Driver:  Error writing to instrument.6Instr. Driver:  Error reading from instrument to file.6Instr. Driver:  Error writing to instrument from file.)Instr. Driver:  Error polling instrument.,Instr. Driver:  Error triggering instrument.*Instr. Driver:  Error clearing instrument.7Instr. Driver:  Instrument identification query failed.+Instr. Driver:  Unable to close instrument.*Instr. Driver:  Unable to open instrument.(Instr. Driver:  Error setting attribute.(Instr. Driver:  Error getting attribute.)Instr. Driver:  Error closing instrument.'Instr. Driver:  Parameter out of range.*Instr. Driver:  Invalid Instrument Handle.=Instr. Driver:  Unable to initialize interface or instrument.*Instr. Driver:  Error finding instruments.&Instr. Driver:  Invalid syntax string.'GPIB EDVR:  Error connecting to device.
10	GPIB ECIC:  Command requires GPIB Controller to be Controller in Charge.?LabVIEW:  Memory full.
10	GPIB ENOL:  Write detected no Listeners.KLabVIEW:  Out of zone.
10	GPIB EADR:  GPIB Controller not addressed correctly.ALabVIEW:  End of file.
10	GPIB:  EABO:  I/O operation aborted.9LabVIEW:  File not found.
10	GPIB EBTO:  DMA hardware uP bus timeout.QLabVIEW:  Duplicate path.
10	GPIB ECAP:  No capability.NLabVIEW:  System feature not enabled.
10	GPIB EOWN:  Sharable board exclusively owned.:LabVIEW:  Cannot add resource.
10	GPIB ESTB:  Serial poll byte queue overflow.4LabVIEW:  Image not found.
10	GPIB ECMD:  Unrecognized command.
10	LabVIEW:  Pen does not exist.ELabVIEW:
10	Configuration type invalid.
10	LabVIEW:  Null window.
10	LabVIEW:  Null menu.
10	LabVIEW:  Print aborted.?LabVIEW:  Bad print record.
10	GPIB EMOM:  Out of memory (MacBus read or write).VLabVIEW:  Device call aborted.
10	GPIB EMIM:  Insufficient memory (MacBus read or write).
10	LabVIEW:  Object ID too low.
10	LabVIEW:  Object ID too high.
10	LabVIEW:  Object not in heap.
10	LabVIEW:  Unknown heap.+LabVIEW:  Unknown object (invalid DefProc).0LabVIEW:  Unknown object (DefProc not in table).
10	LabVIEW:  Null method.
10	LabVIEW:  Unknown message.%LabVIEW:  Manager call not supported.8TCP ncBadAddressErr:  The network address is ill-formed.3TCP ncInProgressErr:  The operation is in progress.RTCP ncTimeOutErr:  The operation exceeded the user-specified or system time limit.'TCP ncBusyErr:  The connection is busy.6TCP ncNotSupportedErr:  The function is not supported.CTCP ncNetErr:  The network is down, unreachable, or has been reset.?TCP ncAddrInUseErr:  The specified address is currently in use.nTCP ncSysOutOfMem:  The system could not allocate the necessary memory.
10	GPIB EOFL:  Serial port receive buffer overflow.
10	GPIB SPTMO:  Serial port timeout; bytes not received at serial port.
10	LabVIEW:  Bad occurrence.<LabVIEW:  Handler does not know what occurrence to wait for.$LabVIEW:  Occurrence queue overflow.%LabVIEW:  File datalog type conflict.!LabVIEW:  Semaphore not signaled.BInterapplication Mgr amUnrecognizedType:  Unrecognized type error.
10	LabVIEW: Memory corrupt.&LabVIEW: Failed to make temporary DLL.
10	LabVIEW: Old CIN version.=LabVIEW kLVE_InvalidState:  The VI is not in a runable state.:LabVIEW kLVE_FPNotOpen:  The VI's front panel is not open.`LabVIEW kLVE_CtrlErr:  The VI cannot run because it has a front panel control in an error state..LabVIEW kLVE_VIBad:  The VI is not executable.0LabVIEW kLVE_NotInMem:  The VI is not in memory.ELabVIEW kLVE_GoDisabled:  VI execution has been disabled in VI Setup.FLabVIEW kLVE_NoSaveData: FPDCO on connector pan thinks it is constant.4LabVIEW kLVE_NoIPRecInSummary: No IP Rec in Summary.;LabVIEW kLVE_CantAllocConPane:  Cannot load connector pane.<LabVIEW kLVE_VariantSizeMisMatch:  Variant tag out of range.7LabVIEW kLVE_NoDefaultOrOp: No default or operate data.1LabVIEW kLVE_CantCreateInstr: VI Creation failed.4LabVIEW kLVE_NoBDHP: Cannot load Block Diagram Heap.3LabVIEW kLVE_NoFPHP:  Cannot load Front Panel Heap."LabVIEW kLVE_Linker: Linker error.QLabVIEW kLVE_NoPrinter:  Printer is not responding.  Check printer configuration.,LabVIEW kLVE_NoHistory: Cannot load History.
10	DDE:  Invalid refnum.
10	DDE:  Invalid string.XDDE DMERRL_ADVACKTIMEOUT:  A request for a synchronous advise transaction has timed out.UDDE DMLERR_BUSY:  The response to the transaction caused the DDE_FBUSY bit to be set.WDDE DMLERR_DATAACKTIMEOUT:  A request for a synchronous data transaction has timed out.
10	DDE DMLERR_DLL_NOT_INITIALIZED:  The DDEML function was called without first calling the DdeInitialize function or an invalid instance identifier was pass to a DDEML function.
10	DDE DMLERR_DLL_USAGE:  An application initialized as APPCLASS_MONITOR has attempted to perform a DDE transaction, or an application initialized as APPCMD_CLIENTONLY has attempted to perform server transactions.ZDDE DMLERR_EXECACKTIMEOUT:  A request for a synchronous execute transaction has timed out.
10	DDE DMLERR_INVALIDPARAMETER:  A parameter failed to be validated by the DDEML:  e.g., the data handle is initialized with a different name-item  or different clipboard data format than that required; the application used a client-side conversation handle with a server-side function, or vice-versa; the application used a freed data or string handle; or more than one instance of the application used the same object.
10	DDE DMLERR_LOW_MEMORY:  A DDEML application has created a prolonged race condition (where the server application outruns the client), causing large amounts of memory to be consumed.5DDE DMLERR_MEMORY_ERROR:  A memory allocation failed./DDE DMLERR_NOTPROCESSED:  A transaction failed.[DDE DMLERR_NO_CONV_ESTABLISHED:  A client's attempt to establish a conversation has failed.VDDE DMLERR_POKEACKTIMEOUT: A request for a synchronous poke transaction has timed out.TDDE DMLERR_POSTMSG_FAILED:  An internal call to the PostMessage function has failed.
10	DDE DMLERR_REENTRANCY:  An application instance with a synchronous transaction already in progress attempted to initiate another synchronous transaction, or the DdeEnableCallback function was called from within a DDEML call function.
10	DDE DMLERR_SERVER_DIED:  A server-side transaction was attempted on a conversation that was terminated by the client, or the server terminated before completing a transaction.CDDE DMLERR_SYS_ERROR:  An internal error has occurred in the DDEML.QDDE DMLERR_UNADVACKTIMEOUT: A request to end an advise transaction has timed out.
10	DDE DMLERR_UNFOUND_QUEUED_ID:  An invalid transaction identifier was passed to a DDEML function.  Once the application has returned from an XTYP_XACT_COMPLETE callback, the transaction identifier for that callback is no longer valid.
10	!"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKL
10	exception handling.  This mechanism is available either to set the error out status FALSE on what is normally an error or to set the status TRUE on what is normally not an error.  If exception action > 0, the error in code and source are checked.  If they match the exception code and source, the error out status is adjusted accordingly.  That is, if the action = 1, the error out status is set to FALSE and code is set to zero and if the action = 2, the error out is set to TRUE and the code is unchanged.  An empty exception source matches any error in source.
10	. Interpret it bit-wise as follows: x4000: serial port VI error; x0001: receiving queue overflowed or character was received after end-of-file character; x0002: character was lost by overwrite; x0004: parity error; x0008: framing error; x0010: break condition; x0020: CTS timeout; x0040:  DSR timeout; x0080: RLSD timeout; x0100: transmission queue was full when new character arrived; x0200: parallel device timeout; x0400: parallel device I/O error; x0800: parallel device not selected; x1000: parallel device out of paper; x8000: requested mode is  not supported or the idComDev parameter is invalid.  Consult the LabVIEW serial port manual for more information.
10	an unidentified location
10	occurred at
10	Possible reasons:
10	error out$@@
10	STTA
10	,@2'new file path (Not A Path if cancelled)"@
10	character string @2
10	M(i32) iteration: controls when the VI performs initialization.  If iteration is 0, the VI configures the port for output and then writes the data.  If iteration is greater than zero, the VI assumes that configuration has already been done and simply writes the data.  You usually wire this input from a While loop iteration terminal.
10	R?$<
10	port width (8).
10	.@0d,
10	task ID^
10	DIO Port Write.vi`
10	Configure
10	for output(
10	(U32) pattern: contains the binary data read from the port. Bit zero is the least significant bit from the port specified by the port number control.
10	J(i32) iteration: controls when the VI performs initialization.  If iteration is 0, the VI configures the port for input and then reads the data.  If iteration is greater than zero, the VI assumes that configuration has already been done and simply reads the data.  You usually wire this input from a While loop iteration terminal.
10	J%YF
10	H#[H
10	pattern.
10	configure for
10	DIO Port Config.vi\
10	DIO Port Read.vi(
10	K&XEK'XE
10	L5[Z
10	_7ne
10	]5pg
10	@].f5
10	f.p5
10	`7l=
10	s9k)
10	WriteQ
10	Read from Digital Port.viH
10	Write to Digital Port .viH
10	`8md`9md
10	M6ZYM7ZY
10	dio data
10	DIO_R-W.VIW
10	on Range
10	1000V
10	Leakage I Data23
10	1000S
10	423!
10	|0 C
10	`|0 C
10	Pass/Fail  Messagee
10	Disabled ItemsD
10	Path to Cap Box Data`
10	f= S
10	RWPQ
10	!u%f
10	SRVW
10	QRVS
10	PQWV
10	NSWPj
10	SWPj
10	t+!!f
10	!_^f3
10	ERPj
10	UPj
10	MRPj
10	QPj
10	Mf;
10	8_^f3
10	PQSR
10	tUf=
10	M _^f
10	EQRPV
10	U_^
10	Rh$
10	jQj
10	MVQ
10	tyf=
10	V*WRP
10	9_^[
10	h$| !
10	E0f=
10	f9E
10	SRPW
10	WPQR
10	Ff;u|
10	PQW
10	E^f
10	$_^[
10	EV3
10	ESV3
10	jBVW
10	T9!!
10	ES3
10	MRPQ
10	SVf=
10	HtHu
10	MVf
10	QWSj
10	NSh
10	t&Jt
10	M$Pf
10	NJQV
10	PjRj/
10	PQjRj/
10	Pj&j%
10	j>jKh
10	IDPR
10	QRSj
10	E$f=
10	N4Wj
10	PQVR
10	QPh8
10	Qh0
10	RPSQ
10	SVWjx
10	M,Qf
10	Ej%P
10	3"!3
10	d5"!
10	JZC@
10	Alr@
10	Transfers the specified number of data bytes from a Message-Based device into a specified local memory buffer, using the VXIbus Byte Transfer Protocol.
10	Transfers the specified number of data bytes from a specified local memory buffer to a Message-Based device, using the VXIbus Byte Transfer Protocol.
10	$Reads data bytes from a GPIB device.
10	)Sends data bytes to a single GPIB device.
10	Gets information about a specified device from the device information table. The information is contained in a 32-bit unsigned integer.
10	Gets information about a specified device from the device information table. The information is contained in a 16-bit unsigned integer.
10	Initializes the NI-VXI library and reads in the resource manager table. The library is automatically initialized when any VXI VI is used in a diagram. If you initialize the library with this VI, you must call CloseVXIlibrary later in your diagram.
10	Transfers the specified number of data bytes from a specified local memory buffer to a device, using either the VXIbus Byte Transfer Protocol (in the case of VXIbus message-based devices), or IEEE 488.2 bus Protocol (in the case of GPIB devices).
10	Combines primary address and secondary address in a specially formatted packed address for devices that require both a primary and secondary GPIB address.
10	Initializes the software connection to the instrument.  In the case of VXI instruments controlled via NI-VXI, initializes the NI-VXI library, reads in the resource manager table, calculates A16 configuration addresses, determines memory requirements, and stores base addresses into A24 or A32 space.  For VXI instruments controlled via GPIB-VXI, performs all of the above except initialization of NI-VXI libraries.  You must run the INSTR Close VI once for every time you run this VI.
10	Converts the instrument grammar to an instrument handle.  Copy or wire the instrument handle out to the instrument handle in control of your instrument driver VI to communicate with the instrument.
10	Send.vi#Instr Read Model Code (GPIB-VXI).vi#Instr Read Model Code (GPIB-VXI).vi#Instr Read Model Code (GPIB-VXI).vi#Instr Read Model Code (GPIB-VXI).vi#Instr Read Model Code (GPIB-VXI).vi
10	Instr Initialize Interface.vi$Instr Parse Instrument Descriptor.vi$Instr Parse Instrument Descriptor.vi$Instr Parse Instrument Descriptor.vi$Instr Parse Instrument Descriptor.vi$Instr Parse Instrument Descriptor.vi
10	tH$4
10	Chris Nielsen
10	Test data outH
10	PASS
10	FC In@0
10	"$
10	T8$4
10	DIO_R-W.VIMD
10	B70PD
10	$VSQWR
10	y>w<
10	y<O8
10	QRhh hhh
10	Y_^P
10	QRhhGh
10	QRhh\h
10	$SQRVW
10	Abort?L
10	QRhhJh
10	Abort?>
10	Error\FC Inb
10	@@D
10	message6@P
10	WhU
10	oldfP
10	error out>
10	dd:\automated\lv51\lvsource\gencode.cGenRangeCheck
10	;GSQRP
10	$4 P
10	@!Abort Button
10	v~wN{
10	gwgk
10	Range"
10	(QRhh
10	Path to Cap Box Data
10	d:\automated\lv51\lvsource\gencode.c
10	Test data inPTH0
10	Test data in @@
10	Test data in,
10	u8QRP
10	E`QRP
10	\` E
10	}#t@
10	x"pf
10	@#H*
10	3g``
10	#>.*2:
9	uint in_DX;
9	undefined1 local_3f;
9	uVar11 = uStack_e4;
9	uStack_e8._2_2_ = 1;
9	uStack_e8._2_2_ = FUN_1000_0012();
9	local_ea = 3;
9	uint *in_AX;
9	int in_CX;
9	iVar1 = 0x1010;
9	undefined2 in_BX;
9	puVar6 = (uint *)puVar6[2];
9	FUN_1008_4868();
9	uVar2 = GETPROCADDRESS(uVar1,in_AX,in_DX);
9	uVar1 = (undefined2)uVar2;
9	if (in_BX != -1) {
9	*(undefined2 *)(in_BX + 0x700) = uVar1;
9	*(undefined2 *)(in_BX + 0x702) = (int)((ulong)uVar2 >> 0x10);
9	uint local_a;
9	void __stdcall16far
9	int local_6;
9	DAT_1008_0016 = 0;
9	DAT_1008_0014 = 0;
9	if ((bool)in_CF) {
9	puVar12 = (undefined4 *)puVar2;
9	puVar7 = (undefined4 *)puVar1;
9	67bff GPIB error
9	Beginning of the file plus pos offset.
9	pos offset specifies in characters how far from the location specified by pos mode that the operation begins. The default value is 0.
9	convert eol? converts the LabVIEW end of line marker to the platform specific marker when set to TRUE. When set to false (the default value), no conversion occurs.
9	error in (no error)U
9	error in (no error)H.
9	Comm Error InPTH0
9	Last Range Cal'd@
9	IND=Short the UUT leads to the
9	Press 'Enter' when ready.W
9	close on error in
9	HDcode out is the error code indicated by the error in or error code.
9	b^exception code is the error code that you want to treat as an exception. By default, it is 0.
9	2.source out indicates the source of the error.
9	}yexception source is the error message that you want to use to test for an exception. By default, it is an empty string.
9	jferror in describes an error that you want to check. If unwired, this VI checks error code for errors.
9	ERROR51code is the error code associated with an error.
9	|xerror out contains the same information as status out, code out, and source out. It has the same structure as error in.
9	mimessage describes the error code that occurred, the source of the error, and a description of the error.
9	General Error Handler.vi7ST
9	[error source] (" ")L
9	$continue or stop message on an error
9	error out o@
9	error in (no error),
9	)type of dialog (continue or stop message)
9	start of read offset (chars.:0 )&`
9	/ProcSet [ /PDF /ImageC /ImageB /ImageI ]
9	kReturns in byte count the number of bytes in the input buffer of the serial port indicated in port number.
9	1) Plug in and turn on LC103 Mainboard test box.
9	2) Attach power adapter and RS-232 cable to LC103
9	3) Connect Fluke 8840A to DVM plugs on front panel of test box.
9	4) Connect Lo Capacity leads to UUT plugs on front of test box.
9	5) Connect 50 pin ribbon cable from PC to right side of test box.
9	Set Status MessageN
9	Inductor Value ary"@@
9	$$5Send DIO setting to tester
9	Capacitor Value ary
9	Relay Settle Time(mS)4
9	51code is the error code associated with an error.
9	status is TRUE if an error occurred, or FALSE if not. If status is TRUE, code is a non-zero error code. If status is FALSE, code can be zero or a warning code.
9	Psource is in most cases the name of the VI or function that produced the error.
9	W(string) source:  an indication of where an error occurred, usually the name of the VI.
9	- sources: `Final_Cal_103FIN.EXE.strings.txt, Source_LV3_1_103f_cal.llb.strings.txt, Source_LV5_1_103f_cal.llb.strings.txt, Source_LV6_103f_cal.llb.strings.txt, Source_lv8_103f_cal.llb.strings.txt`
9	o&gf
9	SVWj
9	PICC
9	%f;E
9	u$G;}
9	LVINt
9	LVCCu
9	PjHj
9	E Pj
9	Pj5j
9	?LVIN
9	-QRP
9	Left
9	Color Box
9	Pass
9	+++++++++++++
9	LLVIN
9	XLVIN
9	pattern is the match pattern specification to display only certain types of files or directories (or folders). See the description of the File Dialog function for more information.
9	Object ID Too Low
9	Object ID Too High
9	Object Not In HeapUnknown Heap
9	Bad DefProc ID
9	DefProc Not In Table
9	Message Out Of Range
9	Null Method
9	Unknown Message
9	4S0
9	$hhhhP
9	2 (create or replace) creates a new file or replaces a file if it exists and you give permission.  Replacement is done by opening the file and setting EOF to 0.  Error 43 occurs if the user elects to disallow the replacement using dialog.
9	new file path is the path of the file opened or created.  You can use this output to determine the path of a file that you open or create using dialog.  new file path returns Not A Path if the user selects Cancel from the dialog box.
9	all filesxD
9	=PTH0
9	not found.
9	*Writes a string of characters to a byte stream file at the specified location; the default location is at the end of file.  The VI does incoming and internal error checking and does not write if an incoming error occurs.
9	mark after write is the location of the character following the last character written.
9	l4R3
9	\HIST
9	pICON
9	#p
9	FL 884XX Initialize.vie.vi
9	Open instrument_D
9	FL 884XX InitializeH
9	Error\FC In4$
9	RangeM
9	Meter Handle InM
9	Meter Handle OutM
9	instr{gpibM
9	TRec$
9	(CPTM
9	<LIds
9	PDFDS
9	dDSTM
9	xvers
9	1333333
9	pDSTM
9	13333
9	Back UpW
9	8ICON
9	Inductance CalibrationW
9	Analysis
9	@@,
9	0DSTM
9	error codeX
9	output refnum$
9	kDy^
9	TDLDR
9	error code4
9	$CPTM
9	LDFDS
9	04#0
9	$BDHP
9	PFTAB
9	1RSRC
9	x?">
9	`4O3
9	tHIST
9	@0Input String05
9	76ND
9	75ND
9	74ND
9	73ND
9	71ND
9	hHIST
9	sPTH0
9	Oldest compatible LabVIEW.N
9	4?0
9	T_Setup.vi]
9	GlobStat.vi]
9	Capacitance CalibrationW
9	D/A TestW
9	PLIbd
9	Communications ErrorW
9	100S
9	@icl4
9	4L0
9	gv #
9	SETLD_RD.VIO
9	GOpens an existing file programmatically or interactively using dialog.  You can optionally specify a dialog prompt, default file name, start path, or filter pattern.   Error 7 occurs if the file does not exist.  Use this VI with the intermediate level Read File+ VIs described below.
9	This subVI tests the error status output of one or more low-level functions or subVIs that output a numeric error code, and creates an error out cluster that can be wired to the Simple or General Error Handler in order to identify the error and describe it to the user.
9	The error in cluster is tested first.  If error? is no-error, the elements of the error codes array are tested next for non-zero values.  The first error found terminates the test, and error out identifies that error.  Use a Build Array function to assemble the individual error codes.
9	close when?  Set TRUE (default) when you want to close the file when this VI is called.  Set to FALSE when you want to close the file only if this VI encounters an incoming error.  This input is useful when you use this VI inside a loop and want to close the file only on the last loop iteration or on an upstream error.  In that case, set close when? TRUE on the last iteration, and terminate the loop on the last iteration or when this VI returns an error.
9	Reads a string of characters from a byte stream file at the specified location; the default location is at the current mark.  The VI does incoming and internal error checking and does not read if an incoming error occurs.
9	count is the number of bytes to read.
9	line mode  Set TRUE to read until a line marker or end of line is encounter or count characters are read.  Set FALSE (default value) to read until count characters are read or end of line is encountered.  A line mark is a carriage return, a line feed, or a carriage return followed by a line feed.
9	character string is the data read from the file.
9	lLIds
9	append to file?  Set to TRUE if you want to append the data to a existing file; you can also set it TRUE to write to a new file.  Set to FALSE (default value) if you want to write the data to a new file or to replace an existing file.
9	new file path is the path of the file to which the VI wrote data.  You can use this output to determine the path of a file that you open using dialog.  new file path returns Not A Path if the user selects Cancel from the dialog box.
9	Initialize?4
9	--------------LOAD SELECT--------------------------------------
9	DEFAULT:
9	LOW Voltage side:
9	1=100k; 2=10k; 3=1k; 4=100; 5=10; 6=2k;
9	7=0%(DA); 8=10% (DA)
9	HIGH Voltage side:
9	9=100k
9	Default: 200mS
9	TEST FAILED!MD
9	WAIT.VIPD
9	T4;3
9	read line
9	number of lines is the maximum number of lines the VI reads.  The default value is -1 line, which means to read the entire file.  For this VI, a line is a character string ending with a carriage return, line feed, or a carriage return followed by a line feed; a string ending at the EOF; or a string that has the maximum line length specified by the max characters per line input.
9	max characters per line is the maximum number of characters the VI reads before ending the search for the end of a line.  The default is 0, which means that there is no limit to the number of characters the VI reads.
9	new file path is the path of the file from which the VI read data.  You can use this output to determine the path of a file that you open using dialog.  new file path returns Not A Path if the user selects Cancel from the dialog box.
9	line string is the data read from the file.
9	EOF? is TRUE if you attempt to read past the end of file.
9	12.0
9	5.4
9	4.7
9	6.0
9	4E0
9	0.0003MD
9	CKI@
9	CKHz
9	KH:R
9	Pass or Fail Global$
9	rwwww
9	$p%
9	E!U#
9	S?bw
9	0P0
9	xxxxxN
9	u3m#
9	Reset UUTp
9	HFPHP
9	d3\#
9	qn{~vv
9	fnq~kv
9	.P #
9	Status_Glob.vi_
9	Out of circuit test\
9	then send pass/fail message.W
9	In circuit testW
9	Out of Circuit
9	QHaJ
9	Capacitance
9	?3?33?3?3
9	LVININSTR_WTB.VI
9	D $,
9	@D$,
9	D$4
9	< $,
9	Approx. 4.0 counts/volt_
9	#"ff
9	DSTRG
9	QRhh`h
9	QRhhOh
9	last mod
9	QRhhRh
9	QRhhUh
9	QRhhLh
9	d$ ZY
9	deny mode (2)
9	oldRP
9	ZXQR
9	udf P
9	p4t0
9	w8~|>
9	True U
9	Xx<O
9	(x<O
9	QRhhMh
9	Hx<O
9	False Z
9	Leakage Data
9	u3QRP
9	$LVSR
9	T_Setup.viH
9	E`QR
9	fffff3ff
9	f3ff33f3
9	3ff3f33f
9	33f33333
9	IEND
9	serpConfig.viPTH0
9	Bytes At Serial Port.viPTH0
9	Serial Port Read.viPTH0
9	APRX_EQL.viPTH0
9	Read Lines From File.viPTH0
8	FUN_1000_a53c();
8	undefined2 local_4;
8	RPC_STATUS RVar1;
8	char local_6c [80];
8	(RPC_CSTR)s_30000_2120706c,(RPC_CSTR)0x0,param_3);
8	RVar1 = RpcBindingFromStringBindingA(*param_3,local_74);
8	FUN_210184a0(local_74[0],local_6c,sVar2 + 1,iVar3);
8	return local_74[0];
8	RpcBindingFree(local_74);
8	RpcStringFreeA(param_3);
8	sVar2 = FUN_21006940(uVar1,2,(int)&param_1 + 2);
8	if (param_1._2_2_ == 0xaa) {
8	if (param_1._2_2_ != 0x55) {
8	if (param_1._2_2_ != 0) {
8	if ((param_1 != 0x6720) && (local_8 != 0x6720)) {
8	psVar4 = local_1c;
8	*psVar4 = sVar2;
8	sVar2 = -0x2a5d;
8	iVar4 = 0x8980;
8	} while (iVar4 < 10000);
8	FUN_21136310(local_8);
8	if (param_2 == 0x1e) {
8	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),0x1c,(int)*(char *)(param_1 + 0xae2));
8	FUN_21183d20(local_24,1,3);
8	uVar5 = extraout_var_03;
8	uVar5 = extraout_var_05;
8	if ((uVar3 & 1) == 0) {
8	if (*(short *)(param_1 + 0x10) != 0x21) {
8	if (*(short *)(param_1 + 0xaf8) != 0) {
8	if (param_2 == 0x1f) {
8	return -0x2811;
8	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),0xb,0x30);
8	if (sVar1 == 0x1f) {
8	SC_HANDLE hSCManager;
8	_SERVICE_STATUS local_20;
8	if (hSCManager == (SC_HANDLE)0x0) {
8	DAT_2120cff8 = 1;
8	if (BVar3 != 0) {
8	BOOL BVar2;
8	local_10 = 4;
8	local_20 = 9;
8	local_e = param_3;
8	local_1c = 0xb;
8	local_20 = 0xd;
8	local_14 = 0x14;
8	local_1c = 0x18;
8	lpOutBuffer = &local_2c;
8	lpInBuffer = &local_2c;
8	local_10 = 0x38;
8	*(undefined4 *)(this + 0x18) = *(undefined4 *)(param_1 + 0x18);
8	*(undefined4 *)(this + 0x1c) = *(undefined4 *)(param_1 + 0x1c);
8	*(undefined4 *)(this + 0x20) = *(undefined4 *)(param_1 + 0x20);
8	uVar1 = *(undefined4 *)(param_1 + 0x28);
8	*(undefined4 *)(this + 0x24) = *(undefined4 *)(param_1 + 0x24);
8	*(undefined4 *)(this + 0x28) = uVar1;
8	daqDevice *this;
8	if ((param_1 & 2) == 0) {
8	iVar1 = *(int *)(in_ECX + -4);
8	_memDelete(in_ECX + -4);
8	return in_ECX + -4;
8	param_20,param_21,param_22,param_23,param_24,param_25,param_26,param_27);
8	param_20,param_21,param_22,param_23,param_24,param_25,param_26,param_27,param_28,
8	param_29,param_30);
8	(**(code **)(*param_1 + 0x530))(piVar1,param_2,param_3,param_4,param_5,param_6);
8	,param_11,param_12,param_13,param_14,param_15,param_16);
8	uVar4 = getDevicePtr(param_1,&param_2);
8	uVar1 = FUN_2104a070(param_1,&param_1);
8	return (uint)(*param_1 == 0x21);
8	piVar4 = param_1;
8	long,unsigned short,unsigned short,long,unsigned short,long,long,unsigned long,unsigned long
8	*,unsigned long *,unsigned short *) */
8	param_26,param_27);
8	float param_18,ulong *param_19,ulong *param_20,ulong param_21,ulong param_22,
8	ulong *param_23,ulong *param_24,ulong *param_25,ulong *param_26,ulong *param_27,
8	param_26,param_27,param_28,param_29,param_30);
8	long,unsigned long *) */
8	short,long,long,long) */
8	(daqDevice *this,ulong param_1,ushort param_2,long param_3,long param_4,long param_5)
8	(daqDevice *this,ulong param_1,ushort param_2,ushort param_3,float param_4,short *param_5,
8	float *param_6,short *param_7,ushort *param_8,short *param_9,LVAIGroupDesc *param_10)
8	long param_12,float *param_13,long param_14,ushort *param_15,long param_16,
8	float *param_12,float *param_13,float *param_14,long *param_15)
8	long,short,char *,short *) */
8	(daqDevice *this,ulong param_1,short param_2,char *param_3,short *param_4)
8	long,long,long *) */
8	(daqDevice *this,ulong param_1,long param_2,long *param_3)
8	long,long,unsigned long,double,unsigned char *,unsigned long *) */
8	(daqDevice *this,short param_1,short param_2,ulong param_3,long param_4,ulong param_5,
8	double param_6,uchar *param_7,ulong *param_8)
8	long,unsigned short,unsigned short,unsigned short,unsigned short,unsigned short,unsigned
8	(daqDevice *this,ulong param_1,ushort param_2,ushort param_3,ushort param_4,ushort param_5
8	(daqDevice *this,ulong param_1,ushort param_2,long param_3,float param_4,long *param_5,
8	*,float *,float *,long *) */
8	long,long,unsigned long *) */
8	(daqDevice *this,ulong param_1,long param_2,ulong *param_3)
8	long,unsigned long,long) */
8	(daqDevice *this,ulong param_1,ulong param_2,long param_3)
8	(daqDevice *this,ulong param_1,short param_2,char *param_3,ushort param_4,ushort param_5,
8	param_18,param_19);
8	(daqDevice *this,ulong param_1,short param_2,char *param_3,short param_4,short param_5,
8	(daqDevice *this,ulong param_1,ulong param_2,ulong param_3)
8	long,unsigned short,long,float *,long,short *,short *) */
8	param_18,param_19,param_20,param_21);
8	short param_6,short param_7,short param_8,double param_9,double param_10)
8	*,long,long,float *,long,float *) */
8	long param_6,float *param_7)
8	*,float *) */
8	long *,unsigned long *) */
8	long,unsigned long,unsigned long,unsigned long,unsigned long,unsigned long) */
8	FUN_2104c090(param_1);
8	*(undefined ***)in_ECX = &PTR_FUN_211d9bf8;
8	*(undefined4 *)(in_ECX + 0x13c) = 0;
8	UINT uMode;
8	FARPROC pFVar1;
8	char local_20 [4];
8	uMode = SetErrorMode(0x8000);
8	SetErrorMode(uMode);
8	Ordinal_116();
8	if (RVar1 != 0) {
8	sVar4 = -0x2864;
8	FARPROC pFVar2;
8	if (hModule == (HMODULE)0x0) {
8	undefined4 in_stack_00000028;
8	return in_stack_00000028;
8	undefined4 in_stack_00000038;
8	undefined4 in_stack_00000040;
8	char *in_stack_00000010;
8	sVar1 = strlen(in_stack_00000010);
8	int in_stack_00000014;
8	int in_stack_00000018;
8	return param_3 * param_6;
8	char *in_stack_00000014;
8	sVar1 = strlen(in_stack_00000014);
8	undefined4 in_stack_00000014;
8	undefined4 in_stack_0000001c;
8	undefined2 *param_8,undefined2 *param_9)
8	NdrGetBuffer(&local_d4,0x1e,param_1);
8	local_d4.MaxCount = param_14;
8	local_d4.MaxCount = param_17;
8	local_d4.MaxCount = param_20;
8	local_d4.MaxCount = param_23;
8	local_d4.MaxCount = param_26;
8	*(undefined2 *)((int)local_d4.Buffer + 0xc) = param_9;
8	*(ULONG_PTR *)((int)local_d4.Buffer + 0x10) = param_10;
8	*(ULONG_PTR *)((int)local_d4.Buffer + 0x14) = param_11;
8	local_d4.Buffer = (uchar *)((int)local_d4.Buffer + 0x1c);
8	*param_14 = *(ULONG_PTR *)local_d4.Buffer;
8	*param_15 = *(ULONG_PTR *)((int)local_d4.Buffer + 4);
8	*param_16 = *(ULONG_PTR *)((int)local_d4.Buffer + 8);
8	local_d4.Buffer = (uchar *)((int)local_d4.Buffer + 0x12);
8	undefined4 param_4,undefined2 param_5,undefined4 param_6,undefined4 *param_7,
8	*param_7 = *(undefined4 *)local_d4.Buffer;
8	undefined2 param_4,uchar *param_5,ULONG_PTR param_6,undefined2 param_7,
8	ULONG_PTR param_8,ULONG_PTR param_9,undefined2 param_10,ULONG_PTR param_11,
8	*(ULONG_PTR *)((int)local_d4.Buffer + 0xc) = param_9;
8	*(ULONG_PTR *)((int)local_d4.Buffer + 0x18) = param_12;
8	*(ULONG_PTR *)((int)local_d4.Buffer + 0x1c) = param_13;
8	local_d4.Buffer = (uchar *)((int)local_d4.Buffer + 0x20);
8	ULONG_PTR param_5,undefined2 *param_6,undefined2 *param_7)
8	*param_7 = *(undefined2 *)((int)local_d4.Buffer + 2);
8	undefined2 param_4,undefined4 param_5,undefined4 param_6,undefined2 *param_7)
8	local_d4.Buffer = (uchar *)((undefined4 *)((uint)(local_d4.Buffer + 3) & 0xfffffffc) + 1);
8	*param_9 = *(undefined2 *)((uint)(local_d4.Buffer + 1) & 0xfffffffe);
8	ULONG_PTR param_9,undefined4 param_10,ULONG_PTR param_11,undefined2 *param_12)
8	*(ULONG_PTR *)((int)local_d4.Buffer + 8) = param_11;
8	NdrConvert(&local_d4,&DAT_211da4d8);
8	ULONG_PTR param_9,ULONG_PTR param_10,uchar *param_11,ULONG_PTR param_12,
8	*(ULONG_PTR *)local_d4.Buffer = param_12;
8	*(ULONG_PTR *)((int)local_d4.Buffer + 4) = param_13;
8	*(undefined4 *)(local_d4.Buffer + 0xc) = param_7;
8	undefined2 param_8,undefined4 param_9,undefined4 param_10,undefined2 param_11,
8	NdrGetBuffer(&local_d4,0x30,param_1);
8	*(undefined2 *)(local_d4.Buffer + 0xc) = param_8;
8	*(undefined4 *)(local_d4.Buffer + 0x10) = param_9;
8	*(undefined4 *)(local_d4.Buffer + 0x14) = param_10;
8	undefined4 *param_4,undefined4 *param_5,undefined2 *param_6)
8	*param_5 = *(undefined4 *)(local_d4.Buffer + 8);
8	*param_6 = *(undefined2 *)(local_d4.Buffer + 0xc);
8	NdrGetBuffer(&local_d4,0x24,param_1);
8	*(undefined2 *)(local_d4.Buffer + 10) = param_6;
8	*(undefined2 *)(local_d4.Buffer + 0x14) = param_9;
8	NdrConvert(&local_d4,"N\x0fN\bN\x06N\x06N\x06N\x06N\x06N\bN\x06Q\x01\x06");
8	puVar1 = (undefined4 *)((uint)(local_d4.Buffer + 3) & 0xfffffffc);
8	*param_8 = *puVar1;
8	local_d4.Buffer = (uchar *)(puVar1 + 2);
8	undefined4 *param_12,undefined4 *param_13,undefined4 *param_14,undefined2 *param_15
8	*(undefined2 *)(local_d4.Buffer + 0x10) = param_6;
8	local_d4.Buffer = local_d4.Buffer + 0x20;
8	*param_11 = *(undefined4 *)local_d4.Buffer;
8	*param_12 = *(undefined4 *)(local_d4.Buffer + 4);
8	*param_13 = *(undefined4 *)(local_d4.Buffer + 8);
8	*param_14 = *(undefined4 *)(local_d4.Buffer + 0xc);
8	*param_15 = *(undefined2 *)(local_d4.Buffer + 0x10);
8	undefined2 *param_13)
8	*(ULONG_PTR *)((int)local_d4.Buffer + 0xc) = param_8;
8	NdrConvert(&local_d4,"N\x0fN\x06Q\x01\x02");
8	ULONG_PTR param_5,undefined2 param_6,undefined2 param_7,ULONG_PTR param_8,
8	*(undefined2 *)((int)local_d4.Buffer + 0x10) = param_11;
8	NdrConvert(&local_d4,"N\x0fN\bN\bQ\x01\x06");
8	NdrConvert(&local_d4,"N\x0fN\bN\bQ\x01\x02");
8	local_d4.BufferLength = 0x12;
8	NdrGetBuffer(&local_d4,0x12,param_1);
8	NdrConvert(&local_d4,"N\x0fN\x06N\x06N\x06N\x06N\x06N\x06Q\x01\x06");
8	ULONG_PTR param_5,undefined2 *param_6)
8	local_d4.BufferLength = 0x17;
8	local_d4.BufferLength = 0x31;
8	*(ULONG_PTR *)local_d4.Buffer = param_7;
8	*(undefined2 *)(local_d4.Buffer + 10) = param_5;
8	*pUVar1 = param_7;
8	pUVar1[5] = param_12;
8	*(undefined2 *)(pUVar1 + 1) = param_6;
8	local_d4.BufferLength = 0x2b;
8	*param_15 = *(undefined4 *)(local_d4.Buffer + 0xc);
8	*param_16 = *(undefined2 *)(local_d4.Buffer + 0x10);
8	local_d4.BufferLength = 0x3c;
8	undefined4 param_4,undefined4 param_5,uchar *param_6,ULONG_PTR param_7,
8	local_d4.MaxCount = param_13;
8	local_d4.MaxCount = param_16;
8	local_d4.MaxCount = param_19;
8	*param_6 = *(undefined2 *)(local_d4.Buffer + 4);
8	undefined2 *param_4,undefined2 *param_5)
8	*param_5 = *(undefined4 *)local_d4.Buffer;
8	NdrConvert(&local_d4,"N\x0fN\x06N\bN\bN\bQ\x01\x06");
8	*param_5 = *(undefined4 *)(local_d4.Buffer + 4);
8	*param_6 = *(undefined4 *)(local_d4.Buffer + 8);
8	*param_7 = *(undefined2 *)(local_d4.Buffer + 0xc);
8	NdrConvert(&local_d4,"N\x0fN\bN\bN\bN\bN\bN\bQ\x01\x06");
8	*param_9 = *(undefined2 *)(local_d4.Buffer + 8);
8	NdrPointerMarshall(&local_d4,param_11,"\x12\b\x06\\\x12");
8	*param_11 = *(undefined2 *)(local_d4.Buffer + 2);
8	*param_12 = *(undefined2 *)(local_d4.Buffer + 4);
8	local_d4.BufferLength = 0x1f;
8	NdrGetBuffer(&local_d4,0x1f,param_1);
8	local_d4.Offset = 0;
8	local_d4.ActualCount = uVar2;
8	undefined2 param_4,undefined4 param_5,undefined2 param_6,undefined4 param_7,
8	undefined4 param_8,ULONG_PTR param_9,uchar *param_10,undefined4 param_11,
8	undefined2 param_12,undefined4 param_13,undefined2 param_14,undefined4 param_15,
8	undefined4 param_16,undefined4 param_17,undefined4 param_18,undefined4 param_19,
8	undefined4 *param_20,undefined4 *param_21,undefined4 param_22,undefined4 param_23,
8	undefined4 param_24,undefined4 param_25,undefined4 *param_26,undefined4 *param_27,
8	undefined4 *param_28,undefined4 *param_29,undefined4 *param_30,undefined2 *param_31
8	local_d4.BufferLength = 0x84;
8	NdrConformantArrayBufferSize(&local_d4,param_10,"\x1b\x03\x04");
8	*(undefined2 *)(local_d4.Buffer + 0xc) = param_6;
8	*(undefined4 *)(local_d4.Buffer + 0x14) = param_8;
8	*(ULONG_PTR *)(local_d4.Buffer + 0x18) = param_9;
8	NdrConformantArrayMarshall(&local_d4,param_10,"\x1b\x03\x04");
8	*(undefined4 *)local_d4.Buffer = param_11;
8	*(undefined2 *)(local_d4.Buffer + 4) = param_12;
8	puVar1 = (undefined4 *)((uint)(local_d4.Buffer + 9) & 0xfffffffc);
8	*puVar1 = param_13;
8	*(undefined2 *)(puVar1 + 1) = param_14;
8	puVar1[2] = param_15;
8	puVar1[3] = param_16;
8	puVar1[4] = param_17;
8	puVar1[5] = param_18;
8	puVar1[6] = param_19;
8	puVar1[7] = param_23;
8	puVar1[8] = param_25;
8	local_d4.Buffer = (uchar *)(puVar1 + 9);
8	*param_20 = *(undefined4 *)local_d4.Buffer;
8	*param_21 = *(undefined4 *)(local_d4.Buffer + 4);
8	NdrConformantArrayUnmarshall(&local_d4,(uchar **)&param_22,"\x1b\x01\x02",'\0');
8	NdrConformantArrayUnmarshall(&local_d4,(uchar **)&param_24,"\x1b\x03\x04",'\0');
8	*param_26 = *(undefined4 *)local_d4.Buffer;
8	*param_27 = *(undefined4 *)(local_d4.Buffer + 4);
8	*param_28 = *(undefined4 *)(local_d4.Buffer + 8);
8	*param_29 = *(undefined4 *)(local_d4.Buffer + 0xc);
8	*param_30 = *(undefined4 *)(local_d4.Buffer + 0x10);
8	*param_31 = *(undefined2 *)(local_d4.Buffer + 0x14);
8	*param_32 = *(undefined2 *)(local_d4.Buffer + 0x16);
8	ULONG_PTR param_5,ULONG_PTR param_6,uchar *param_7,ULONG_PTR param_8,uchar *param_9
8	local_d4.Buffer = (uchar *)(puVar1 + 1);
8	local_d4.BufferLength = 0x1a;
8	*pUVar1 = param_6;
8	undefined4 param_4,undefined4 param_5,undefined4 *param_6,undefined4 param_7,
8	NdrConvert(&local_d4,"N\x0fN\bN\x06N\bN\nQ\x01\x02");
8	*param_6 = *(undefined4 *)local_d4.Buffer;
8	*param_11 = *(undefined2 *)local_d4.Buffer;
8	*(undefined2 *)((int)local_d4.Buffer + 4) = param_5;
8	*param_8 = *(ULONG_PTR *)local_d4.Buffer;
8	*param_9 = (short)*(ULONG_PTR *)((int)local_d4.Buffer + 4);
8	NdrConformantArrayUnmarshall(&local_d4,(uchar **)&stack0x00000038,"\x1b\x03\x04",'\0');
8	NdrConformantArrayUnmarshall(&local_d4,(uchar **)&stack0x0000003c,"\x1b\x01\x02",'\0');
8	NdrConformantArrayUnmarshall(&local_d4,(uchar **)&param_8,"\x1b\x01\x02",'\0');
8	ULONG_PTR param_5,undefined2 param_6,undefined2 param_7,undefined2 param_8,
8	*(undefined2 *)(pUVar1 + 2) = param_8;
8	*(short *)(local_d4.Buffer + 2) = param_3;
8	local_d4.Buffer = (uchar *)(puVar2 + 2);
8	*param_5 = *(undefined2 *)((uint)(local_d4.Buffer + 1) & 0xfffffffe);
8	NdrConformantArrayUnmarshall(&local_d4,(uchar **)&param_3,"\x1b",'\0');
8	*(ULONG_PTR *)(local_d4.Buffer + 4) = param_3;
8	local_d4.MaxCount = (uint)param_8;
8	local_d4.MaxCount = (uint)param_7;
8	local_d4.BufferLength = 0x11;
8	NdrConvert(&local_d4,&DAT_211db0d4);
8	*param_5 = *(ushort *)local_d4.Buffer;
8	local_d4.MaxCount = (int)param_5;
8	local_d4.MaxCount = (uint)param_6;
8	undefined4 *in_stack_00000018;
8	puVar2 = &local_20;
8	param_5,uVar1);
8	puVar3);
8	param_11,param_12,param_13,param_14,param_15,param_16,param_17,param_18,
8	local_20 = CONCAT22((short)((uint)param_1 >> 0x10),
8	(ushort)param_1 & 0xff00 | *(ushort *)(in_ECX + 0x2c));
8	local_24);
8	undefined4 param_18)
8	goto LAB_21025021;
8	local_c = iVar3;
8	goto LAB_2102503c;
8	piVar7 = piVar7 + 0xe;
8	uVar6 = uVar5;
8	undefined4 param_11,undefined4 param_12,undefined4 param_13,undefined4 param_14,
8	(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9,
8	param_9 = 0;
8	sVar5 = strlen(_Str);
8	puVar7 = puVar7 + 0xe;
8	FUN_21185a40(iVar4);
8	local_30[0] = 0;
8	sVar3 = strlen(_Str);
8	puVar2 = local_1c;
8	uVar1 = ((param_1 >> 0x18 & 0xf) << 8 | param_1 >> 0x10 & 0xf) << 0x10 |
8	undefined4 param_6,undefined4 param_7,int param_8,undefined4 param_9,undefined4 param_10
8	,undefined4 param_11,undefined4 param_12,undefined4 param_13,undefined4 param_14,
8	undefined4 *param_19,undefined4 *param_20,undefined4 param_21,undefined4 param_22,
8	undefined4 *param_23,undefined4 *param_24,undefined4 *param_25,undefined4 *param_26,
8	local_1c = &stack0xffffffa4;
8	local_34[0] = 0;
8	local_34[0] = (**(code **)(*in_ECX + 0x34))
8	(param_1,&local_40,&local_3c,&local_24,&local_48,&local_38,local_2c);
8	local_40 = param_8;
8	iVar2 = local_38;
8	if (((short)local_48 != 1) && (iVar2 = local_44, (short)param_2 == 2)) {
8	iVar2 = local_3c * local_38;
8	local_44 = iVar2;
8	local_20 = local_40 * iVar2;
8	local_20 = iVar4;
8	puVar6 = local_34;
8	iVar2 = local_20;
8	param_20,param_21,iVar2,param_22,iVar4,param_23,param_24,param_25,param_26,param_27,
8	return local_34[0];
8	uVar4 = ((param_1 >> 0x18 & 0xf) << 8 | param_1 >> 0x10 & 0xf) << 0x10 |
8	return local_40;
8	goto code_r0x21025c83;
8	uint *param_5,undefined4 *param_6)
8	puVar4 = &local_2c;
8	int local_24 [2];
8	local_1c = &stack0xffffffbc;
8	if ((short)local_30 == 0) {
8	psVar6 = local_20;
8	puVar5 = &local_24;
8	if (local_20[0] != -0x2864) {
8	if ((local_24 & 0x100000) != 0) {
8	*param_5 = local_24;
8	local_24 & 0x4000 | param_1 & 0xffff;
8	*param_6 = local_24;
8	param_1 = (int)*(short *)(in_ECX + 0x2c) | param_1 & 0xffffff00;
8	puVar2 = local_24;
8	local_28);
8	iVar3 = param_5;
8	local_2c[0] = (**(code **)(*in_ECX + 0x120))(param_1,param_2,param_3,&local_24);
8	local_2c[0] = (**(code **)(*in_ECX + 300))(param_1,&local_20);
8	*param_3 = puVar1;
8	puVar9 = param_9;
8	uVar3 = CONCAT22((short)((param_1 & 0xffffff00) >> 0x10),
8	(ushort)(param_1 & 0xffffff00) | *(ushort *)(in_ECX + 0x2c));
8	uVar4 = (int)*(short *)(in_ECX + 0x2c) | param_1 & 0xffffff00;
8	puVar5 = local_24;
8	undefined4 param_6,undefined4 param_7,undefined4 param_8,undefined4 param_9)
8	puVar5 = &local_20;
8	uVar1 = CONCAT22((short)((uint)puVar3 >> 0x10),*(undefined2 *)(in_ECX + 0x2c));
8	*(undefined ***)in_ECX = &PTR_FUN_211dca2c;
8	if (*(HMODULE *)(in_ECX + 0x2c) != (HMODULE)0x0) {
8	undefined4 param_4)
8	,undefined4 param_5)
8	uVar2 = 0xffffd8e3;
8	sVar1 = FUN_21007370(param_1,param_2,param_3);
8	,undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8
8	sVar1 = FUN_21146c41(param_1);
8	(**(code **)(*DAT_2121b220 + 0x10))();
8	return 0xffffd8d3;
8	FUN_21136440(param_1,param_2);
8	param_10,param_11,param_12,param_13,param_14,param_15,param_16);
8	DAT_2121a00c = OpenMutexA(0x1f0001,0,s_NationalInstrumentsSCXIHDLCHidde_21207b64);
8	if (DAT_2121a00c == (HANDLE)0x0) {
8	if (pvVar4 == (HANDLE)0x0) {
8	if (DAT_2121a010 == (HANDLE)0x0) {
8	if (LVar7 == 0) {
8	DAT_2121a018 = 1;
8	ReleaseMutex(DAT_2121a00c);
8	DVar1 = WaitForSingleObject(DAT_2121a00c,10000);
8	LRESULT LVar4;
8	if (LVar4 == 0) {
8	return 0xfffffffd;
8	*psVar1 = param_2;
8	LRESULT LVar3;
8	if (LVar3 == 0) {
8	SetEvent((HANDLE)(&DAT_2121a024)[sVar2]);
8	BVar1 = GetExitCodeProcess(DAT_2121a008,&local_8);
8	LRESULT LVar2;
8	LVar2 = SendMessageTimeoutA(*(HWND *)(DAT_2121a004 + 4),0x404,
8	if (LVar2 == 0) {
8	CloseHandle(DAT_2121b208);
8	if (DAT_2121b218 == 0) {
8	return 0xd598;
8	CloseHandle(lpParameter);
8	DWORD DVar9;
8	CHAR local_104 [256];
8	iVar3 = palStatusMapStatusValue(uVar2);
8	puVar4[5] = 0;
8	if (iVar3 == 3) {
8	lstrcatA(local_104,s__kernel32_dll_21207ba8);
8	hModule = LoadLibraryA(local_104);
8	if (iVar4 == iVar1) {
8	if (pcVar2 != (code *)0x0) {
8	palStatusMapStatusValue(uVar1);
8	goto switchD_2103cd6b_caseD_1;
8	goto switchD_2103cd6b_caseD_5;
8	goto switchD_2103cd6b_caseD_a;
8	goto switchD_2103cd6b_caseD_64;
8	uVar4 = 7;
8	switch((undefined2)param_1) {
8	if (param_2 == 0x5316) {
8	if (param_2 == 0x5320) {
8	return param_2 == 0x2000;
8	bVar1 = FUN_21185030(*(undefined4 *)(param_1 + 0xc),2);
8	sVar2 = (short)uVar5 >> 1;
8	if ((uVar5 & 1) != 0) {
8	uVar6 = sVar2 + uVar6;
8	short sVar17;
8	uint uVar21;
8	iVar12 = 2;
8	uVar15 = (undefined2)((uint)iVar12 >> 0x10);
8	if (sVar5 == 0x12) {
8	return CONCAT22(uVar16,0xd8ed);
8	*(byte *)(local_8 + 0x41d) = *(byte *)(local_8 + 0x41d) & 0xdf;
8	if ((*(char *)(local_8 + 0x3dc) != '\0') && (*(char *)(local_8 + 0x3dc) != '\x05')) {
8	FUN_21185130(*(undefined4 *)(local_8 + 0xc),0x1a,0xff02);
8	*(byte *)(local_8 + 0x41d) = *(byte *)(local_8 + 0x41d) | 0x20;
8	*(undefined1 *)(local_8 + 0x3dc) = 5;
8	sVar17 = *(short *)(local_8 + 0x41d);
8	uVar24 = *(undefined4 *)(local_8 + 0xc);
8	uVar21 = CONCAT31((int3)(((uint)uVar11 << 0x10) >> 8),-(param_2 != 0)) & 0xffffff04;
8	uVar15 = (undefined2)(uVar21 >> 0x10);
8	return CONCAT22(uVar15,0xd755);
8	iVar18 = 1 << ((byte)((int)uVar21 / 2) & 0x1f);
8	uVar11 = 2;
8	FUN_21042be0(iVar2,4,CONCAT22(extraout_var,*(undefined2 *)(iVar2 + 0x39c)),1);
8	FUN_21185130(*(undefined4 *)(local_8 + 0xc),6,(int)*(short *)(local_8 + 0x421));
8	*(ushort *)(local_8 + 0x41d) = *(ushort *)(local_8 + 0x41d) & ~uVar11;
8	*(ushort *)(local_8 + 0x41d) = *(ushort *)(local_8 + 0x41d) | uVar11;
8	*(char *)(iVar2 + 0x3d) = (char)param_3;
8	FUN_21143130(param_5,param_6,iVar2,iVar2 + 4);
8	*(undefined1 *)(local_8 + 0x344) = uVar20;
8	*(undefined1 *)(local_8 + 0x395) = uVar20;
8	*(byte *)(param_1 + 0x421) = *(byte *)(param_1 + 0x421) | 0x40;
8	*(byte *)(param_1 + 0x421) = *(byte *)(param_1 + 0x421) & 0xbf;
8	sVar6 = (-(ushort)(*(short *)(&DAT_2120f8e0 + iVar5) != 0xf) & 4) + 6;
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),0x1a,0xffea);
8	FUN_2105f6b0(0x21,*(undefined2 *)(param_1 + 0xaf6),param_1 + 0x273,0);
8	FUN_211850f0(*(undefined4 *)(iVar3 + 0xc),0x17,0xb4);
8	FUN_21042980(iVar3,9,0x78,0);
8	iVar2 = param_1 * 0x7a;
8	if ((short)param_3 < 0) {
8	sVar2 = *(short *)(iVar4 + 0x277);
8	if ((uVar10 & 1) == 0) {
8	*param_4 = uVar7;
8	uVar13 = *puVar1;
8	*(byte *)(iVar4 + 0x356) = bVar11;
8	FUN_211850f0(uVar13,7,(int)(char)bVar11);
8	if ((uVar8 & uVar7) == 0) {
8	while ((uVar8 & uVar7) == 0) {
8	uVar13 = *(undefined4 *)(param_1 + 0xc);
8	else if ((sVar2 == 0xd) || (sVar2 == 0xe)) {
8	uVar7 = (ushort)param_4;
8	FUN_21185030(*(undefined4 *)(local_8 + 0xc),10);
8	FUN_2105f760(0x21,CONCAT22(extraout_var,*(undefined2 *)(local_8 + 0xaf6)),local_8 + 0x273);
8	if (*(short *)(local_8 + 0x14a) != 0) {
8	uVar8 = 4;
8	bVar7 = bVar7 + 1;
8	else if (sVar2 == 0x12) {
8	sVar1 = *(short *)(&DAT_2120f8de + iVar5);
8	if (sVar1 == 6) {
8	*(short *)(param_1 + 0x254) = param_3;
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),0,(int)*(short *)(param_1 + 0x41b));
8	uStack_20 = 0x3ff00000;
8	uStack_20 = 0x40240000;
8	iVar3 = (int)(short)param_3;
8	goto switchD_21040332_caseD_3;
8	if (sVar2 != 0xd) {
8	local_2c = 0.5;
8	local_2c = 1.0;
8	if (sVar2 == 0xe) {
8	if ((((double)CONCAT44(param_5,param_4) == 0.0) || ((double)CONCAT44(param_5,param_4) < 0.001)) ||
8	(5000.0 < (double)CONCAT44(param_5,param_4))) {
8	sStack_18 = 0;
8	*(undefined2 *)(iVar1 + 0x234) = 0;
8	*(undefined4 *)(iVar1 + 0x230) = 5;
8	(local_3c /
8	longlong lVar4;
8	ushort *puVar10;
8	if (local_10._4_2_ == 0) {
8	local_8 = uVar8;
8	puVar10 = param_7;
8	iVar6 = param_6;
8	if (*(short *)(iVar1 + 0x94 + (uVar8 & 0xffff) * 2) == 1) {
8	iVar11 = iVar6;
8	return (int)(short)local_14;
8	sVar1 = sVar3;
8	if ((uVar7 & 0x100) != 0) {
8	bVar5 = FUN_21185030(param_1[3],0);
8	if ((bVar5 & 1) != 0) {
8	if ((bVar5 & 2) != 0) {
8	if ((uVar9 & 0x100) == 0) {
8	local_8 = uVar12;
8	sVar2 = FUN_2103d0b0(uVar12,param_2);
8	param_2 = 0xffffffff;
8	if ((param_3 != 0) &&
8	if ((0xc < sVar4) && (sVar4 < 0xf)) {
8	if (param_4 != 0x14) {
8	if ((short)local_10 == 4) {
8	dVar14 = local_24;
8	bVar7 = *(byte *)((int)param_1 + 0x357);
8	local_c[0x11a] = 0;
8	local_c[0x118] = 10;
8	local_c[(uVar6 & 0xffff) + 0x4a] = param_5;
8	} while ((short)iVar13 <= sVar4);
8	_param_4 = 0xd;
8	_param_4 = _param_4 + -1;
8	} while (_param_4 != 0);
8	psVar1[uVar6 & 0xffff] = 0;
8	psVar1[uVar6 & 0xffff] = param_3;
8	uVar6 = FUN_2103d030(param_2);
8	*(byte *)((int)param_1 + 0xae3) = *(byte *)((int)param_1 + 0xae3) | 1;
8	else if (sVar3 == 1) {
8	*(byte *)((int)param_1 + 0xae1) = *(byte *)((int)param_1 + 0xae1) & 0xf7;
8	psVar11[0x129] = 8;
8	DAT_2121196c = DAT_2121196c & ~(ushort)(1 << ((byte)local_1c & 0x1f));
8	cVar4 = '\x01';
8	iVar3 + 0x39a);
8	undefined2 local_c [4];
8	local_c[1] = 2;
8	if (cVar1 < '\x04') {
8	} while (-1 < sVar5);
8	if (sVar2 != 6) {
8	local_8 = 0xe;
8	iVar9 = 6;
8	if (bVar3) goto LAB_2104228b;
8	} while (-1 < (short)iVar9);
8	iVar9 = param_2;
8	iVar8 = param_2;
8	sVar11 = (short)param_3;
8	FUN_21185130(*(undefined4 *)(local_c + 0xc),iVar8,(int)sVar11);
8	if (*(char *)(iVar10 + 0x344 + local_c) == '\0') {
8	LPDWORD pDVar8;
8	local_4a = 2;
8	local_4a = 4;
8	undefined1 uVar9;
8	undefined2 uVar16;
8	int *piVar15;
8	int iVar21;
8	int local_18 [4];
8	sVar4 = local_8[1];
8	(&DAT_2120f8ea)[iVar7] = 0xff;
8	param_2 = (short *)((int)param_2 + 1);
8	*(undefined2 *)(&DAT_2120f920 + iVar7) = 4;
8	(&DAT_2120f8e9)[iVar7] = 0xff;
8	(&DAT_2120f8e8)[iVar7] = 0xff;
8	goto LAB_210431e9;
8	local_18[2] = 0;
8	return 0xd7fc;
8	switch(sVar11) {
8	iVar21 = *(int *)(&DAT_2120f937 + iVar7);
8	piVar15 = piVar15 + 1;
8	iVar20 = iVar20 + -1;
8	} while (iVar20 != 0);
8	*(undefined4 *)(&DAT_2120f8ec + iVar7) = 0x6720;
8	*(undefined4 *)(&DAT_2120f8f0 + iVar7) = 0x6720;
8	*(undefined4 *)(&DAT_2120f8ec + iVar7) = 0x4c90;
8	*(undefined4 *)(&DAT_2120f8f0 + iVar7) = 0x8980;
8	if (*psVar1 == 10) {
8	__16slotInitMap = __16slotInitMap & ~(ushort)(1 << ((byte)param_1 & 0x1f));
8	return (uint)uVar12;
8	sVar1 = (&DAT_2120f958)[(short)param_1 * 0x3d];
8	&local_c);
8	FUN_21184e80(iVar3);
8	iVar3 = *(int *)(*(int *)((int)&DAT_2120f9b1 + iVar2) + 0x463);
8	uVar7 = uVar6 + 0x62;
8	local_14 = uVar6;
8	puVar3 = (undefined4 *)FUN_21136300(uVar2);
8	goto LAB_21043eba;
8	if (param_3 != 0xff) {
8	if ('\x03' < (char)bVar5) {
8	short local_18 [8];
8	iVar4 = (short)((short)param_1 + -1) * 4;
8	iVar3 = *(int *)(&DAT_21212774 + iVar4);
8	if (*(char *)(iVar5 + 0xa86) != '\0') {
8	if (uVar4 != 0) break;
8	piVar1 = (int *)(iVar2 + 0x1ee);
8	uVar2 = FUN_21185030(*(undefined4 *)(param_1 + 0xc),0);
8	uVar5 = FUN_21045280(uVar2,2,param_2);
8	*param_5 = uVar5;
8	uVar5 = FUN_21045280(uVar2,6,param_2);
8	uVar5 = FUN_21045280(uVar2,10,param_2);
8	if ((param_3 & 8) != 0) {
8	param_1 = param_6;
8	param_1 = param_7;
8	sVar3 = FUN_210450c0(uVar1,iVar2,param_3,iVar5);
8	sVar3 = FUN_210450c0(uVar1,iVar2,0xe0,(int)&param_2 + 2);
8	if (param_2._2_2_ == 1) {
8	param_8 = 8;
8	uVar2 = FUN_21044ff0(param_1,iVar1,iVar3 + 3,*param_2);
8	if (*(short *)(param_2 + 0xa8) == 0) {
8	iVar2 = param_2 + 0x14 + sVar1 * 2;
8	uVar1 = *(undefined1 *)(param_2 + 0xae2);
8	puVar3[2] = (undefined2)param_3;
8	*(undefined1 *)((int)puVar3 + 3) = uVar1;
8	sVar6 = *(short *)((int)DAT_212191c0 + 1);
8	return CONCAT22(uVar1,2);
8	local_c = local_8 + 0x14;
8	if ((param_2 == 1) || (param_2 == 2)) {
8	sVar4 = (short)param_4;
8	if ((short)param_7 < 0) {
8	local_8 = CONCAT22(local_8._2_2_,*(undefined2 *)(param_2 + 0xa8));
8	local_c = CONCAT22(local_c._2_2_,*(undefined2 *)(param_2 + 0x14));
8	FUN_21005ab0(param_1,0xffffffff,1,10,0,0);
8	puVar6 = &DAT_2121196c;
8	*puVar6 = *puVar6 | (ushort)local_10;
8	dVar2 = fabs(dVar3);
8	dVar3 = fabs(dVar4);
8	*param_12 = sVar2;
8	else if (0xff < sVar2) {
8	sVar2 = 0xff;
8	undefined4 param_5,undefined4 param_6,double *param_7)
8	sVar1 = FUN_21044ff0(param_1,param_2,param_5,param_6);
8	sVar1 = (short)param_5;
8	if (0 < (short)param_5) {
8	iVar3 = FUN_21183e00(local_24);
8	} while (iVar3 == 0);
8	,undefined4 param_6,int param_7)
8	CONCAT22((short)((uint)*(undefined4 *)(iVar3 + 0x54) >>
8	0x10),*(undefined2 *)(iVar3 + 0x1c)),
8	*(undefined2 *)(iVar3 + 0x1e)),
8	*(undefined4 *)(iVar3 + 0x50),
8	FUN_21044ff0(param_1,param_2,param_4);
8	local_c = local_c - dVar4;
8	dVar3 = fabs(local_c);
8	*param_9 = sVar2;
8	param_1 = 0x79e;
8	FUN_21045fe0(uVar1,iVar2,param_3,1,0x400,&local_2c);
8	FUN_21005dc0(uVar1,param_4,param_1);
8	FUN_21045fe0(uVar1,iVar2,param_3,1,0x400,&local_24);
8	local_2c = local_2c - dVar6;
8	local_24 = local_24 - local_14;
8	dVar5 = fabs(local_1c);
8	sVar3 = (short)param_6;
8	FUN_21005dc0(param_1,param_6,param_4);
8	FUN_21005dc0(param_1,param_6,param_5);
8	dVar1 = fabs((local_c - local_14) - (local_1c - local_24));
8	uVar3 = FUN_21045280(param_3,2,param_4);
8	uVar3 = FUN_21045280(param_3,6,param_4);
8	uVar3 = FUN_21045280(param_3,10,param_4);
8	if ((param_3 & 1) == 0) {
8	sVar3 = (short)param_4;
8	sVar4 = (short)iVar7;
8	*(undefined4 *)(param_2 + 0x10) = 0xcccccccd;
8	*(undefined4 *)(param_2 + 0x14) = 0x9999999a;
8	param_2[0xe] = 0x12;
8	param_2[0xf] = 0x16;
8	*(undefined4 *)(param_2 + 0x12) = 0x3feccccc;
8	*(undefined4 *)(param_2 + 0x16) = 0x3ff19999;
8	*(undefined4 *)(param_2 + 10) = 0x33333333;
8	*(undefined4 *)(param_2 + 0xc) = 0x40033333;
8	*(undefined4 *)(param_2 + 6) = 0x9999999a;
8	*(undefined4 *)(param_2 + 0x18) = 0x9999999a;
8	*(undefined4 *)(param_2 + 0x1c) = 0xeb851eb8;
8	*(undefined4 *)(param_2 + 0x20) = 0x47ae147b;
8	*(undefined4 *)(param_2 + 0x24) = 0xd2f1a9fc;
8	*param_2 = 0x28f;
8	param_2[1] = 0x3d7;
8	param_2[2] = 6;
8	param_2[3] = 0x14;
8	param_2[4] = 0x42;
8	param_2[5] = 0x62;
8	*(undefined4 *)(param_2 + 8) = 0x3ff99999;
8	*(undefined4 *)(param_2 + 0x1a) = 0x40099999;
8	*(undefined4 *)(param_2 + 0x1e) = 0x3f9eb851;
8	*(undefined4 *)(param_2 + 0x22) = 0x3fd47ae1;
8	*(undefined4 *)(param_2 + 0x26) = 0x3f80624d;
8	*param_2 = bVar1;
8	*param_2 = bVar2;
8	uVar3 = FUN_210475e0(param_1,pbVar1,5);
8	pbVar2 = param_2;
8	iVar7 = 4;
8	FUN_211850f0(param_1,0x1c,(int)(char)(bVar3 & 0xdf));
8	bVar3 = 0xb;
8	if (((int)(short)((ushort)(byte)uVar6 << 8 | param_4 & 0xff) & 1 << (bVar3 & 0x1f)) == 0) {
8	bVar4 = *pbVar2 & 0xbf;
8	bVar4 = *pbVar2 | 0x40;
8	*pbVar2 = bVar4;
8	FUN_211850f0(param_1,0x1c,(int)(char)bVar4);
8	*pbVar2 = bVar4 | 0x20;
8	FUN_211850f0(param_1,0x1c,(int)(char)(bVar4 | 0x20));
8	*pbVar2 = bVar4 & 0xdf;
8	FUN_211850f0(param_1,0x1c,(int)(char)(bVar4 & 0xdf));
8	*pbVar2 = bVar3 | 0x10;
8	if (uVar1 == 3) {
8	param_3 = 0xc;
8	*param_2 = bVar1 & 0xdf;
8	FUN_211850f0(param_1,0x1c,(int)(char)(bVar1 & 0xdf));
8	*param_2 = bVar1 | 0x20;
8	FUN_211850f0(param_1,0x1c,(int)(char)(bVar1 | 0x20));
8	param_3 = 8;
8	cVar1 = *pcVar2;
8	FUN_2103bde0(0x1002);
8	ushort local_28 [2];
8	undefined1 local_18 [2];
8	uVar5 = (ushort)param_3;
8	sVar4 = 0xc;
8	*local_20 = *local_20 & ~local_28[0];
8	FUN_21185130(param_2,10,*puVar2 & 0xff7f);
8	local_34 = local_40;
8	param_2 = 1 << ((char)local_40 - 1U & 0x1f);
8	local_30 = iVar6;
8	sVar3 = (short)iVar6;
8	undefined2 uStack_2a;
8	undefined2 uStack_26;
8	undefined2 uStack_22;
8	iVar2);
8	undefined2 uStack_1e;
8	undefined2 uStack_12;
8	if (((sVar3 == 0xd) || (sVar3 == 0xe)) || (sVar3 == 6)) {
8	local_10 = param_2[3];
8	piVar5 = param_5;
8	DAT_2121196c = DAT_2121196c | (ushort)(1 << ((byte)param_1 & 0x1f));
8	piVar5 = param_2;
8	switch(param_3 & 0xf) {
8	param_3 = 0x400;
8	param_3 = 0x4000;
8	uVar4 = FUN_2103d030(param_4);
8	cVar10 = 'k';
8	cVar10 = '`';
8	cVar10 = cVar8;
8	if (cVar10 != cVar8) {
8	sVar3 = 0x2a1f;
8	if (1 < (short)param_4) {
8	undefined1 local_44 [4];
8	if (sVar4 == 10) {
8	if ((short)local_34 == 2) {
8	local_30 = local_3c;
8	param_2 = 1 << ((char)local_3c - 1U & 0x1f);
8	*local_1c = *local_1c | local_28[0];
8	if (0 < (short)local_30) {
8	*local_18 = *local_18 | local_20[0];
8	*param_6 = 0x10;
8	*param_10 = 0x8000;
8	*param_12 = param_2;
8	*param_15 = 0x4000;
8	*param_18 = 0x2000;
8	*param_17 = param_2;
8	*param_20 = param_2;
8	*param_5 = 8;
8	if ((param_1 == 0xd) || (param_1 == 0xe)) {
8	*param_3 = 0x100;
8	*param_2 = 0x21;
8	local_10[1] = 2;
8	if ((iVar6 != 0) && (local_14 == 0)) {
8	psVar2[6] = sVar5;
8	*(undefined1 *)((int)psVar2 + 5) = uVar4;
8	sVar5 = FUN_2104a330(CONCAT22(uVar9,psVar2[1]));
8	uVar9 = extraout_var_05;
8	*psVar1 = -1;
8	switch(psVar2[1]) {
8	uVar9 = extraout_var_03;
8	if (cVar3 == '\x01') {
8	param_2 = (short *)0x1;
8	(&DAT_2120d03d)[iVar4] = 0xff;
8	sVar2 = *param_1;
8	param_1[5] = 0;
8	return (float10)local_14;
8	DWORD DVar11;
8	iVar2 = iVar8 * 0x7a;
8	uVar5 = FUN_21185030(*(undefined4 *)(iVar1 + 0xc),0x15);
8	local_56 = param_1 + 0x20c;
8	*puVar3 = *puVar2;
8	for (uVar1 = (uint)((param_2 & 1) != 0); uVar1 != 0; uVar1 = uVar1 - 1) {
8	puVar3 = (undefined4 *)((int)puVar3 + 2);
8	local_c = local_8 + 0x12;
8	if (*(short *)(local_8 + 0x14a) == 0) {
8	local_18 = *(int *)(&DAT_21212774 + (short)((short)param_1 + -1) * 4);
8	iVar3 = param_6;
8	else if (sVar7 == 1) {
8	uVar8 = FUN_2104a6a0(uVar8);
8	if (CONCAT11(uVar5,uVar4) == 0) {
8	sVar6 = *(short *)(iVar3 + 0x266);
8	if (1 < sVar6) {
8	iVar11 = sVar6 + -1;
8	uVar8 = (uint)sVar7;
8	return CONCAT22(sVar7,0xd690);
8	uVar11 = *(undefined4 *)(param_3 + 0xc);
8	*(byte *)(param_3 + 0x356) = bVar6;
8	FUN_211855e0(iVar9 + 1,(int)(short)cVar3);
8	FUN_211850f0(*(undefined4 *)(param_3 + 0xc),1,0);
8	FUN_21185070(*(undefined4 *)(param_3 + 0xc),2);
8	FUN_21185030(*(undefined4 *)(param_3 + 0xc),3);
8	if (*(code **)(&DAT_21213a58 + iVar9 * 4) != (code *)0x0) {
8	(**(code **)(&DAT_21213a58 + iVar9 * 4))(iVar1);
8	*(undefined4 *)(&DAT_21213a58 + iVar9 * 4) = 0;
8	if (*(char *)(param_2 + 0x3dd) != '\0') {
8	*(undefined1 *)(param_2 + 0x3dd) = 0;
8	else if (*(char *)(param_2 + 0x3de) == '\b') {
8	*(undefined1 *)(param_2 + 0x3de) = 7;
8	if (((((sVar7 == 0x30) || (sVar7 == 0xc9)) || (sVar7 == 0x39)) ||
8	((sVar7 == 0x3a || (sVar7 == 0x1e)))) || (sVar7 == 0x21)) {
8	FUN_211850f0(*(undefined4 *)(param_2 + 0xc),0xe,(int)(char)bVar6);
8	*(byte *)(param_2 + 0xae0) = bVar6;
8	FUN_211850f0(*(undefined4 *)(param_2 + 0xc),2,(int)(char)bVar6);
8	*(undefined1 *)(iVar5 + 0xf7) = 0;
8	uVar12 = (undefined2)((uint)iVar9 >> 0x10);
8	bVar6 = *(byte *)(param_2 + 0xae3) & 0xef;
8	uVar12 = extraout_var_04;
8	local_28 = uVar5;
8	uVar11 = local_30;
8	if (sVar3 == 6) {
8	else if (sVar3 != 0x12) {
8	FUN_21185130(*(undefined4 *)(local_8 + 0xc),iVar10,uVar13);
8	local_20 = (*DAT_21214124)(0x51,param_1);
8	else if (sVar3 == 6) {
8	if ((int)sVar8 % 3 == 0) {
8	uVar13 = 0xffffffff;
8	uVar7 = *(uint *)(local_10 + 0xd7);
8	*(undefined1 *)(local_24 + 0x29) = 0;
8	uVar7 = *(uint *)(local_10 + 0xdb);
8	if (*(short *)(local_18 + 0x34) != 0) {
8	*(undefined4 *)(iVar4 + 0x1dc) = 0;
8	FUN_211850f0(*(undefined4 *)(local_8 + 0xc),0x19,0);
8	FUN_21185030(*(undefined4 *)(local_8 + 0xc),9);
8	(*DAT_21214124)(0x1023,param_1);
8	HANDLE pvVar8;
8	undefined2 local_11c;
8	undefined2 local_112;
8	undefined2 local_110;
8	undefined2 local_be;
8	undefined2 local_7c;
8	undefined2 local_72;
8	undefined2 local_70;
8	if (sVar6 == 0x12) {
8	*(undefined2 *)(param_5 + 6) = 0;
8	local_8 = iVar11;
8	if ((short)local_1c == 0x12) {
8	puVar3[2] = uVar2;
8	local_11c = 7;
8	lpBytesReturned = &local_2c;
8	puVar16 = &local_7c;
8	puVar14 = &local_7c;
8	pDVar18 = (LPDWORD)&param_4;
8	local_cc = 4;
8	DeviceIoControl(pvVar8,DVar13,puVar14,DVar15,puVar16,DVar17,pDVar18,p_Var19);
8	FUN_211850f0(*(undefined4 *)(local_c + 0xc),0x17,0x40);
8	if (sVar6 < -0x2a5c) {
8	if (sVar6 == -0x2a5d) {
8	*(undefined2 *)(puVar3 + 6) = 4;
8	*(undefined2 *)(puVar3 + 6) = 6;
8	*(undefined2 *)(puVar3 + 6) = 7;
8	*(undefined2 *)(puVar3 + 6) = 5;
8	*(undefined2 *)(puVar3 + 6) = 3;
8	else if (sVar6 == 0) {
8	*(undefined2 *)(puVar3 + 6) = 1;
8	*(undefined2 *)(puVar3 + 6) = 2;
8	uVar9 = *puVar3;
8	*(short *)(param_5 + 6) = sVar6;
8	*puVar3 = uVar9 / param_2;
8	*param_5 = uVar9 / param_2;
8	puVar3[4] = 1;
8	puVar3[3] = local_28;
8	*param_5 = *puVar3;
8	return uVar9 & 0xffff0000;
8	if (*(int *)(&DAT_21211864 + param_1 * 4) != 1) {
8	return CONCAT22(param_1 >> 0xf,0xd8eb);
8	return CONCAT22(uVar3,0xd75d);
8	sVar1 = sVar1 + -1;
8	int local_52;
8	undefined4 local_4a;
8	undefined2 uStack_3a;
8	pDVar11 = &param_3;
8	p_Var12 = (LPOVERLAPPED)0x0;
8	puVar9 = &local_54;
8	DVar10 = 0x50;
8	puVar7 = &local_54;
8	DVar8 = 0x50;
8	DVar6 = 0xabcd201c;
8	pvVar3 = (HANDLE)FUN_21002400();
8	DeviceIoControl(pvVar3,DVar6,puVar7,DVar8,puVar9,DVar10,pDVar11,p_Var12);
8	local_54 = 4;
8	int local_82;
8	undefined2 local_7a;
8	short local_12;
8	pcVar6 = pcVar6 + 1;
8	iVar11 = extraout_ECX;
8	if (sVar5 == 8) {
8	puVar16 = (undefined4 *)0x0;
8	param_1 = (undefined4 *)0x1;
8	local_12 = 999;
8	local_18 = 0x21e;
8	puVar12 = (undefined4 *)0x100;
8	puVar14 = (undefined4 *)0x200;
8	param_1 = (undefined4 *)0x1000;
8	puVar7 = (undefined4 *)0x800;
8	puVar16 = (undefined4 *)0x8000;
8	else if ((short)local_c == 0) {
8	puVar12 = param_6;
8	if ((sVar5 != 0) &&
8	*(undefined1 *)(iVar2 + 0xf8) = 1;
8	uVar9 = FUN_21136200(param_7);
8	uVar9 = FUN_21136200(param_6);
8	uVar1 = *(undefined2 *)param_5;
8	bVar3 = param_5[2];
8	*(undefined1 *)(iVar17 + 0x29) = 2;
8	*(undefined1 *)(iVar17 + 5) = (undefined1)local_8;
8	*(undefined2 *)(iVar17 + 0x22) = uVar1;
8	*(byte *)(iVar17 + 0x48) = bVar3;
8	*(undefined2 *)(iVar17 + 0x24) = 0;
8	*(byte *)(iVar17 + 0x2c) = bVar3 & 0xef;
8	uVar4 = FUN_21132800(param_5,1);
8	*(undefined1 *)(iVar17 + 0x2f) = uVar4;
8	iVar17 = param_9;
8	param_7);
8	if (bVar3 == 0) {
8	uVar9 = uVar9 | 0x10;
8	if ((*(byte *)(param_2 + 0x42b) & 4) != 0) {
8	uVar9 = uVar9 | 0x40;
8	uVar10 = uVar10 | 0x20;
8	uVar3 = 0x80;
8	if ((param_4 & 4) != 0) {
8	uVar2 = 0x40;
8	cVar1 = *(char *)(iVar3 + 0x349);
8	else if (sVar2 == 0) {
8	uVar6 = uVar6 | 0x8000;
8	uVar6 = uVar6 | 0x80;
8	if ((param_4 & 2) != 0) {
8	sVar5 = (short)param_5;
8	param_6 = param_5;
8	if (param_7 == '\x02') {
8	FUN_2104df40(iVar1,CONCAT22(uVar6,(short)cVar3),1,iVar2,uVar7,param_6);
8	FUN_21185490(iVar3 + 1,(int)param_2);
8	*param_4 = (byte)param_5;
8	psVar11 = (short *)(local_3c + 0x12);
8	if (sVar9 < -1) {
8	return CONCAT22(uVar4,0xd690);
8	param_2 = CONCAT13(1,(undefined3)param_2);
8	local_2c = uVar10;
8	param_2 = param_2 & 0xffffff;
8	uVar5 = (uint)sVar9;
8	return 0xd75b;
8	sVar12 = (short)local_2c;
8	if ((short)local_54 != 0) {
8	if (uVar5 < local_8) {
8	local_34 = local_8;
8	local_34 = local_10;
8	if (local_c < param_4) {
8	local_38 = 0x2a5e;
8	sVar9 = (short)uVar10;
8	iVar3 = iVar3 + 2;
8	uVar10 = uVar6;
8	if ((short)local_38 != 0) {
8	if (local_10 <= uVar5) {
8	if ((short)local_54 == 0) {
8	sVar1 = *(short *)(&DAT_2120f8de + (short)param_1 * 0x7a);
8	iVar5 = (int)(short)param_3;
8	goto switchD_2104eae9_caseD_2;
8	local_10 = (byte)((char)param_2 >> 2) & 0xf;
8	if (sVar1 == 0xe) {
8	uVar2 = FUN_2103d030(param_2);
8	if (param_8 == (int *)0x0) {
8	if (((uint)param_1 & 0xffff0000) == 0) {
8	if (iVar8 == 1) {
8	puVar7 = puVar3;
8	param_1 = (undefined4 *)((int)param_1 + 2);
8	undefined2 local_9a;
8	local_10 = iVar1;
8	if (0x7f < iVar1) {
8	puVar2 = local_1a0;
8	iVar12 = local_10;
8	if (lVar3 != 0) {
8	_close(iVar1);
8	} while (sVar2 < param_1);
8	if (local_10 == (undefined2 *)0x0) {
8	puVar13 = local_10;
8	_close(iVar11);
8	uVar6 = FUN_2103d030(CONCAT22((short)((ulonglong)uVar8 % (ulonglong)local_c >> 0x10),
8	param_6[(int)((ulonglong)uVar8 % (ulonglong)local_c)]));
8	if (*(short *)(iVar5 + 0x138) != 0) {
8	return CONCAT22(uVar4,0xd68f);
8	return CONCAT22(uVar4,0xd63d);
8	sVar1 = *(short *)(&DAT_2120f8de + (short)iVar2 * 0x7a);
8	return -0x29c3;
8	sVar7 = (short)local_1c;
8	local_10 = 0x1000;
8	iVar9 = 1;
8	iVar6 = FUN_21183e00(local_3c);
8	*(undefined2 *)(iVar9 + 0x10e) = 1;
8	uVar4 = FUN_21185070(*(undefined4 *)(local_8 + 0xc),0x18);
8	uVar3 = (ushort)local_10;
8	while ((uVar4 & uVar3) != 0) {
8	uVar4 = FUN_21185070(*(undefined4 *)(local_8 + 0xc),0);
8	FUN_2104a6a0(param_1 + -1);
8	if (*local_c == 0x18) {
8	sVar4 = FUN_21064870(iVar1,&local_8,0x4a);
8	uVar2 = FUN_21095200(param_1);
8	FUN_21095210(param_1,0);
8	sVar3 = FUN_210990d0(CONCAT22(extraout_var,*(undefined2 *)(param_1 + 0x11)));
8	if ((0 < sVar3) && (sVar3 < 0x41)) {
8	return *(undefined4 *)(*(int *)(&DAT_2120f937 + iVar1) + 0x21a);
8	iVar5 = param_1 + 0x12;
8	iVar6 = param_1 + 0x12;
8	undefined1 local_4c [32];
8	while (*psVar1 == 0) {
8	if (*(char *)(local_18 + 0x1ca) != '\0') {
8	return 0xd544;
8	iVar2 = FUN_21183e00(local_4c);
8	sVar4 = *(short *)(local_18 + 0x10e);
8	if (uVar3 < local_10) {
8	if (local_14 != local_c) {
8	if ((short)local_28 == 1) {
8	undefined2 local_90;
8	undefined4 local_8a;
8	iVar10 = param_2;
8	while ((int)sVar6 - 1U < 0x12) {
8	sVar9 = (short)iVar10;
8	local_c = FUN_21052ae0(local_18,param_4,0);
8	if (*(short *)(iVar12 + 0x1f) == 1) {
8	uVar2 = *(ushort *)(iVar7 + 0xa3);
8	FUN_21185130(*(undefined4 *)(iVar7 + 0xc),4,(int)(short)uVar2);
8	*(ushort *)(iVar7 + 0xa3) = uVar2;
8	goto switchD_21050a8e_default;
8	iVar12 = sVar9 * 0x10;
8	local_c = FUN_21052ae0(iVar12 + 0x3a7 + iVar7,param_4,0);
8	short local_52;
8	uVar4 = uVar4 & ~(ushort)(1 << (bVar3 & 0x1f));
8	uVar4 = uVar4 | (ushort)(1 << (bVar3 & 0x1f));
8	short local_3e;
8	local_3e = param_2;
8	local_3e = param_2 + -2;
8	local_8 = (ushort *)((int)puVar4 + 1099);
8	param_2 = local_3e;
8	bVar5 = -(param_2 != 0) & 4;
8	if ((*(short *)(local_24 + 2) == 0x25) &&
8	goto LAB_21051eb1;
8	uVar9 = FUN_21185070(*(undefined4 *)(iVar2 + 0xc),0);
8	return 0xd756;
8	if ((short)local_1c != 0) break;
8	(*(short *)(iVar2 + 0xaf8) = *(short *)(iVar2 + 0xaf8) + -1, *(short *)(iVar2 + 0xaf8) == 0
8	if (3 < sVar3) {
8	sVar6 = (short)local_28;
8	uVar9 = 1 << (bVar7 & 0x1f);
8	local_42 = param_2 + -2;
8	local_8 = iVar2 + 1099;
8	param_2 = local_42;
8	iVar3 = (int)local_3c;
8	sVar2 = *(short *)(&DAT_2120f8de + iVar3 * 0x7a);
8	local_c = FUN_210643c0(3,&local_18,&local_3c);
8	*param_3 = local_36;
8	sVar2 = (short)local_1c;
8	local_3a = param_2 + -2;
8	local_8 = iVar5 + 1099;
8	param_2 = local_3a;
8	local_c = 0x2973;
8	if (sVar2 == 0xff) {
8	sVar2 = (short)local_14;
8	bVar4 = (byte)param_3;
8	if (sVar7 == 0x2975) {
8	sVar7 = 0x2973;
8	goto LAB_2105279a;
8	if (-1 < (short)local_14) {
8	sVar5 = (short)iVar6;
8	param_2 = iVar4;
8	iVar6 = iVar6 + -2;
8	param_1 = iVar2 + 1099;
8	local_32 = (undefined2)iVar6;
8	local_14 = FUN_210643c0(6,&local_c,&local_34);
8	piVar1 = piVar1 + 1;
8	psVar2 = param_4;
8	*param_5 = -1;
8	*param_6 = -1;
8	*param_5 = (short)*(char *)((int)param_4 + 5);
8	sVar4 = param_4[1];
8	short local_16;
8	iVar12 = 3;
8	uVar10 = (undefined2)(uVar7 >> 0x10);
8	if ((cVar1 != -1) && ((cVar1 == (char)local_8[2] || (cVar1 == *(char *)((int)local_8 + 5)))))
8	if ((cVar1 != -1) &&
8	((cVar1 == (char)local_8[4] ||
8	ushort uVar18;
8	if (*(short *)(local_8 + 0xad) == 0) {
8	if ((*(short *)(local_8 + 0x1f) == 0) && (*(short *)(local_8 + 0x2f) == 0)) {
8	FUN_21185130(*(undefined4 *)(local_8 + 0xc),0,uVar9);
8	FUN_21132450(param_1,(short)cVar3,0xffffffff);
8	if ((*(byte *)(local_8 + 0x102) & 0x40) != 0) {
8	FUN_211855e0(iVar10 + 1,(int)sVar13);
8	*(undefined2 *)(&DAT_21213588 + sVar13 * 2) = 0;
8	*(ushort *)(iVar7 + 6) = *(ushort *)(iVar7 + 6) & 0xfbff;
8	*(ushort *)(local_8 + 0x101) = *(ushort *)(local_8 + 0x101) & 0xbfff;
8	if ((uVar5 & 8) != 0) {
8	iVar11 = iVar11 + 0x10;
8	FUN_21185130(*(undefined4 *)(local_8 + 0xc),2,uVar8);
8	uVar8 = uVar8 | 0x40;
8	MrCleanRemoveHandler(2,1,param_1);
8	param_4 = param_4 << 1;
8	_param_3 = param_4;
8	switch((undefined2)param_5) {
8	switch(iVar10) {
8	uVar5 = uVar5 & 0xfffb;
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),0,(int)(short)uVar8 | 0x100);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),2,(int)(short)uVar7 | 0x100);
8	*(undefined2 *)(param_1 + 0xaf) = 0;
8	if (*(short *)(param_1 + 0x21) != 0) {
8	if (*(short *)(param_1 + 0x31) != 0) {
8	*(undefined2 *)(iVar11 + 0x21 + param_1) = 1;
8	uVar4 = (ushort)(byte)param_5;
8	*(ushort *)(iVar11 + 0x19 + param_1) = uVar4;
8	uVar16 = uVar16 | 0x400;
8	uVar16 = uVar16 | 0x800;
8	uVar16 = uVar16 | 2;
8	uVar4 = uVar8 & 0xf97f;
8	uVar16 = uVar16 & 0xdbff;
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),0,(int)(short)uVar4 | 0x100);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),0,(int)(short)uVar4);
8	uVar8 = uVar4 | 0x600;
8	uVar8 = uVar4 | 0x680;
8	uVar16 = uVar16 & 0xb7ff;
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),2,(int)(short)uVar9 | 0x100);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),2,(int)(short)uVar9);
8	if (iVar10 == 2) {
8	*(short *)(iVar6 + 0x13) = sVar12 + 1;
8	uint param_7)
8	if (*(short *)(param_1 + 0x1f) == 1) {
8	if (*(short *)(param_1 + 0x3f) == 1) {
8	if ((param_3 == 1) || (param_3 == 2)) {
8	if ((ushort)param_4 != 0) {
8	uVar5 = uVar5 | 0x40;
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),0,param_2);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),2,(int)(short)(uVar11 & 0xf87f) | 0x100);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),2,param_2);
8	*(ushort *)(param_1 + 0xff) =
8	(byte)((byte)*(ushort *)(param_1 + 0x101) ^ (byte)param_3) & 3 ^
8	*(ushort *)(param_1 + 0x101);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),2,(int)(short)uVar10);
8	switch(*(undefined2 *)(param_1 + 0xad)) {
8	if ((uVar6 & 0x100) == 0) {
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),0,*(ushort *)(param_1 + 0x9f) & 63999);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),*(undefined2 *)(param_1 + 0x27),
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),2,*(ushort *)(param_1 + 0xa1) & 63999);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),*(undefined2 *)(param_1 + 0x47),
8	sVar2 = *(short *)(param_1 + 0xaf);
8	if (*(short *)(param_1 + 0x39) == 1) {
8	if (*(short *)(iVar8 + 0x19 + param_1) != 1) {
8	if (*(short *)(iVar8 + 0x1f + param_1) != 0) {
8	goto LAB_21054e1f;
8	iVar1 = iVar8 + param_1;
8	if (*(short *)(iVar8 + 0x19 + param_1) == 1) {
8	bVar4 = FUN_21185030(*(undefined4 *)(param_1 + 0xc),*(undefined2 *)(iVar1 + 0x27));
8	uVar5 = FUN_21185030(*(undefined4 *)(param_1 + 0xc),*(undefined2 *)(iVar1 + 0x27));
8	*(undefined1 *)param_3 = uVar5;
8	uVar7 = FUN_21185070(*(undefined4 *)(param_1 + 0xc),*(undefined2 *)(param_1 + 0x27));
8	uVar7 = FUN_21185070(*(undefined4 *)(param_1 + 0xc),*(undefined2 *)(param_1 + 0x47));
8	if (iVar6 == 0) goto LAB_21055362;
8	return CONCAT22((short)((uint)iVar6 >> 0x10),0xd68f);
8	uVar7 = (undefined2)((uint)iVar6 >> 0x10);
8	param_3 = param_6;
8	if (param_5 == -2) {
8	param_3 = param_3 * 10;
8	((bVar1 && (*(short *)(param_1 + 0x107) != (short)param_2)))) {
8	return CONCAT22(uVar7,0xd755);
8	sVar4 = (short)iVar3;
8	switch(*(short *)(&DAT_2120f8de + (short)iVar1 * 0x7a)) {
8	return CONCAT22((short)((uint)(*(short *)(&DAT_2120f8de + (short)iVar1 * 0x7a) + -2) >> 0x10),
8	0xd75d);
8	param_1 = param_1 + 1099;
8	,int param_6)
8	if (sVar4 != 2) {
8	local_20 = param_5;
8	local_1c = (uVar12 & 0x1000) >> 0xc;
8	sVar8 = 1;
8	if ((short)local_3c == -1) {
8	local_4a = 0;
8	local_58 = 2;
8	*(undefined2 *)(iVar4 + 0xc1) = 1;
8	*(undefined2 *)(iVar4 + 0xc3) = 1;
8	if (((short)param_6 == 1) || (((*local_10 & 0x180) != 0 && ((*local_10 & 0x400) == 0)))) {
8	FUN_21185130(*(undefined4 *)(iVar4 + 0xc),0,(int)(short)local_14);
8	FUN_21185130(*(undefined4 *)(iVar4 + 0xc),0xe,0);
8	uVar12 = uVar11;
8	*(undefined2 *)(param_3 * 0x10 + 0x1f + iVar4) = 1;
8	*(undefined2 *)(iVar4 + 0x4f) = 1;
8	uVar4 = *param_6;
8	uVar9 = FUN_21136200(param_5);
8	uVar9 = FUN_21136200(param_4);
8	bVar11 = (byte)(uVar10 >> 8);
8	FUN_21185490(iVar12 + 1,(int)sVar6);
8	*(byte *)(iVar3 + 7) = *(byte *)(iVar3 + 7) | 4;
8	*(undefined2 *)(&DAT_21213588 + sVar6 * 2) = 1;
8	*(byte *)(param_2 + 0x102) = *(byte *)(param_2 + 0x102) | 0x40;
8	if ((param_4 == 1) && (uVar5 == 1)) {
8	FUN_21185130(*(undefined4 *)(iVar1 + 0xc),iVar3,(int)(short)local_c | 0x100);
8	FUN_21185130(*(undefined4 *)(iVar1 + 0xc),2,*(ushort *)(iVar1 + 0xa1) | 0x100);
8	*(ushort *)(iVar1 + 0xa1) = *(ushort *)(iVar1 + 0xa1) & 0xffdf;
8	uVar4 = uVar4 & 0x7fff;
8	uVar2 = uVar2 & 0xfffd;
8	FUN_21185130(*(undefined4 *)(iVar1 + 0xc),0x14,(int)(short)uVar2);
8	FUN_21185130(*(undefined4 *)(iVar1 + 0xc),4,(int)(short)uVar4);
8	FUN_21185130(*(undefined4 *)(iVar1 + 0xc),2,*(undefined2 *)(iVar1 + 0xa1));
8	local_c = local_c | 0x40;
8	*(ushort *)(iVar1 + 0xa1) = *(ushort *)(iVar1 + 0xa1) | 0x20;
8	uVar4 = uVar4 | 0x8000;
8	*(ushort *)(iVar1 + 0xa3) = uVar4;
8	*(ushort *)(iVar1 + 0xa5) = uVar2;
8	sVar8 = (short)uVar9;
8	if (sVar8 != 1) {
8	MrCleanInstallHandler(2,1,param_1,FUN_21056e60);
8	uint *param_6,uint *param_7,undefined4 *param_8,undefined4 *param_9)
8	if (piVar1[1] == 0) {
8	goto LAB_21057023;
8	local_20 = local_8;
8	*param_4 = local_1c;
8	*param_8 = local_14;
8	undefined4 param_6,undefined4 param_7,undefined4 param_8,int *param_9)
8	if ((puVar3[1] == 0) && (*puVar3 < (uint)-param_4)) {
8	FUN_21057e80(param_1,param_2,local_8,&local_c,local_10,local_20);
8	sVar1 = palStatusMapStatusValue(uVar6);
8	undefined1 local_50 [8];
8	iVar9 = *piVar1;
8	sVar2 = -0x2718;
8	if (*param_6 == 1) {
8	param_6[9] = 0;
8	param_1[2] = 0;
8	param_1[3] = 0;
8	undefined1 *puStack_68;
8	FUN_21057e80();
8	local_1c = local_34;
8	local_20 = local_38;
8	if (piVar2[1] == 0) {
8	local_14 = *(undefined4 *)(iVar3 + 0x14);
8	local_18 = *(undefined4 *)puVar1;
8	local_c = puVar5[1];
8	local_10 = *puVar5;
8	u64::u64((u64 *)&puStack_68,(u64 *)(iVar3 + 8));
8	u64::u64((u64 *)&uStack_70,(u64 *)&local_20);
8	u64::u64((u64 *)&uStack_78,(u64 *)(iVar3 + 8));
8	u64::u64((u64 *)&uStack_80,(u64 *)&local_20);
8	if (iVar6 == 0) goto LAB_21057e68;
8	if (((iVar6 != 0) || (local_2c != local_24)) || (local_30 != local_28)) goto LAB_21057e68;
8	puVar4 = (u64 *)u64::u64(local_50,(u64 *)&local_18);
8	iVar6 = FUN_21058a20();
8	if (iVar6 != 0) goto LAB_21057e68;
8	**(undefined1 **)(iVar3 + 0x1c) = 0;
8	puStack_8c = local_48;
8	puVar4 = (u64 *)FUN_21058980();
8	undefined2 local_6a;
8	local_6a = 0;
8	int local_32;
8	if ((local_10 < local_8) || ((local_10 == local_8 && (local_14 < local_c)))) {
8	u64::u64((u64 *)&local_24,puVar5);
8	else if ((local_8 < local_10) || ((local_8 == local_10 && (local_c < local_14)))) {
8	*param_7 = local_c;
8	*param_8 = local_8;
8	int *param_10)
8	iVar1 = param_1 + (param_3 + -1) * 0x34;
8	if (*(int *)(iVar1 + 0x45b) == 0) {
8	if (param_5 < 0) {
8	if ((local_8 == 0) && (local_c < (uint)-param_5)) {
8	iVar5 = *piVar2;
8	(**(code **)(*piVar2 + 0xc))(param_5);
8	local_4c[0] = param_2;
8	local_2a = param_1 + 0x4b7;
8	local_22 = param_1 + 0x60c;
8	sVar3 = FUN_21145950(local_4c,local_30);
8	iVar5 = 0x6658;
8	FUN_21183d20(local_6c,uVar6);
8	local_14 = param_9;
8	local_10 = *(uint *)(*(int *)(iVar1 + 0x453) + 8) >> 1;
8	sVar3 = palStatusMapStatusValue(uVar4);
8	if ((0 < param_3) && (param_3 < 3)) {
8	uVar4 = (undefined2)((uint)&local_8 >> 0x10);
8	sVar3 = (**(code **)(*param_2 + 0x26c))
8	(CONCAT22(uVar4,(short)*piVar2),CONCAT22(uVar4,*(undefined2 *)((int)piVar2 + 2))
8	iVar5 = piVar2[3];
8	param_1[1] = iVar5;
8	if (sVar3 == -0x2970) {
8	piVar2[4] = piVar2[2];
8	*param_1 = iVar5;
8	uVar3 = param_3[1];
8	puVar1 = (u64 *)u64::u64(local_c,param_2);
8	uVar3 = *(undefined4 *)(puVar1 + 4);
8	*param_1 = *(undefined4 *)puVar1;
8	undefined *puVar2;
8	return CONCAT22(uVar5,0xd5c6);
8	iVar1 = (param_1 & 0xffff) * 0x7a;
8	if (*(short *)(&DAT_2120f8e0 + iVar1) != 0x1f) {
8	if (sVar3 == 8) {
8	*(byte *)(param_1 + 0xae1) = *(byte *)(param_1 + 0xae1) & 0xfd;
8	uVar5 = 0xd8ed;
8	iVar8 = (int)param_2;
8	uVar6 = CONCAT31((int3)(((uint)uVar7 << 0x10) >> 8),uVar3) | (uint)bVar4 << 8;
8	FUN_2105f760(CONCAT22((short)((uint)(param_1 + 0x273) >> 0x10),
8	*(undefined2 *)(param_1 + 0x10)),*(undefined2 *)(param_1 + 0xaf6),
8	if (*(short *)(&DAT_2120f8de + iVar2) == 8) {
8	FUN_211850f0(*(undefined4 *)(local_c + 0xc),0xb,
8	if ((sVar2 == 0) && (param_1[3] != 0)) {
8	puVar8 = puVar8 + 0x51;
8	puVar9[-1] = 0;
8	*puVar9 = 0;
8	*(undefined2 *)(param_2 + 0x3a6) = 0;
8	*(undefined2 *)(param_2 + 0x3a8) = 0;
8	(&DAT_2120f99c)[iVar7] = 0;
8	(&DAT_2120f9a1)[iVar7] = 0xf8;
8	(&DAT_2120f9a2)[iVar7] = 0x3e;
8	(&DAT_2120f9a3)[iVar7] = 0;
8	(&DAT_2120f9ab)[iVar7] = 0;
8	(&DAT_2120f9ac)[iVar7] = 0xfc;
8	(&DAT_2120f9ad)[iVar7] = 0xff;
8	iVar6 = (int)(short)param_1;
8	iVar4 = 3;
8	uVar1 = FUN_21128ae0(0x3f05,local_18,0);
8	longlong lVar3;
8	FUN_21184e80(*(int *)(param_1 + 4));
8	param_1[0x14] = 0;
8	param_1[0x17] = 0;
8	if (param_1[1] != 0) {
8	*(undefined2 *)(param_2 + 0x16) = 0;
8	*psVar5 = 0;
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),0,0);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),2,0);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),4,0);
8	undefined4 local_42;
8	undefined4 local_2e;
8	puVar5 = param_2;
8	iVar13 = (int)sVar7;
8	*param_2 = psVar1;
8	iVar11 = (int)sVar7;
8	sVar6 = *(short *)(puVar5 + 4);
8	*(undefined2 *)(puVar5 + 0x2be) = 1;
8	*(undefined2 *)((int)puVar5 + 0xaf6) = 0x99;
8	*(undefined2 *)(puVar5 + 0x2be) = 0;
8	puVar5[3] = iVar8;
8	local_56 = 1;
8	local_54 = 0x10;
8	*(undefined2 *)(puVar2 + 1) = 0;
8	iVar8 = sVar7 * 0x10;
8	} while (sVar7 < 3);
8	*(undefined1 *)((int)puVar5 + 0xadf) = 0;
8	*(undefined1 *)((int)puVar5 + 0xae3) = 0;
8	if (((((sVar1 == 0x30) || (sVar1 == 0xc9)) || (sVar1 == 0x39)) ||
8	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),0xc,0);
8	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),4,0);
8	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),5,0);
8	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),6,0);
8	FUN_211850f0(*(undefined4 *)(param_1 + 0xc),0x17,0x70);
8	FUN_21183e60(2,1);
8	if (*pcVar4 == -1) {
8	pcVar4 = pcVar4 + 0x10;
8	iVar5 = *(int *)(&DAT_21212774 + local_10 * 4);
8	uVar12 = *(undefined4 *)(iVar2 + 0xc);
8	*(undefined1 *)(iVar5 + 0x19e) = 1;
8	if ((short)uVar10 == 0) {
8	case 0x4028:
8	iVar2) != 0) + '\x02',iVar5);
8	sVar7 = *(short *)(iVar2 + 0x10);
8	(short)uVar10 != 0)) {
8	uVar10 = -(uint)(*(short *)(iVar2 + 0x277) != 0) & 0xffffd5c8;
8	uVar8 = (int)(short)param_4 & 0x80000001;
8	if ((short)uVar10 != 0) break;
8	undefined1 *puVar9;
8	FUN_21184e80(param_2[3]);
8	FUN_21043c00(param_1,0xffffffff,0xffffffff,0xffffffff,0,0);
8	*(undefined2 *)(param_2 + 0x52) = 1;
8	*psVar8 = 0;
8	if ((bVar4 & 0x80) == 0x80) {
8	puVar9 = puVar9 + 2;
8	FUN_211850f0(*(undefined4 *)(param_2 + 0xc),1,0);
8	uVar3 = FUN_21185030(*(undefined4 *)(param_2 + 0xc),0);
8	FUN_2105bd60(0xdf,0,param_2);
8	FUN_2105bd60(0xdf,1,param_2);
8	param_2 = 0x10;
8	param_1 = *(byte *)(param_3 + 0x356) & param_1;
8	*(byte *)(param_3 + 0x356) = param_1;
8	FUN_211850f0(*(undefined4 *)(param_3 + 0xc),7,(int)(char)param_1);
8	bVar1 = *(byte *)(param_3 + 0x356) | ~param_1;
8	*(byte *)(param_3 + 0x356) = bVar1;
8	FUN_211850f0(*(undefined4 *)(param_3 + 0xc),7,(int)(char)bVar1);
8	*(undefined2 *)(param_2 + 0xb2) = 0;
8	sVar1 = FUN_2105c4d0(param_1,param_3,param_5,param_2,param_4);
8	FUN_21067260(param_1);
8	if (DAT_2121a064 != 0) {
8	DAT_2121a064 = 1;
8	local_a = param_5;
8	param_1[6] = 0;
8	param_1[8] = 0;
8	if ((short)iVar3 == -1) {
8	local_10 = iVar3;
8	uVar7 = 0xffff;
8	else if (sVar1 == 0) {
8	sVar1 = 3;
8	goto LAB_2105cbe7;
8	sVar1 = 4;
8	sVar1 = FUN_210672a0(local_8,(int)&param_5 + 3,(int)&param_5 + 3);
8	FUN_21183e60(5,3);
8	sVar1 = FUN_2105cc10(local_8,local_1c,param_3,local_20,local_18);
8	sVar1 = 1;
8	if (((short)local_1c != 0) &&
8	if ((short)iVar9 != 0) {
8	iVar7 = FUN_21183e00(local_44);
8	if ((short)uVar12 == 0) {
8	FUN_21185030(*(undefined4 *)(local_8 + 0xc),0x15);
8	sVar4 = *(short *)(iVar6 + 0x266);
8	if (1 < sVar4) {
8	if (1 < sVar1) {
8	uVar11 = uVar11 - 1;
8	} while (uVar11 != 0);
8	*param_3 = *param_3 + 1;
8	uVar4 = uVar3 + 1;
8	if (uVar3 == 0xffff) {
8	return (uint)in_EAX & 0xffff0000;
8	if (*(char *)(param_1 + 0x3dd) != '\0') {
8	cVar1 = *(char *)(param_1 + 0x3de);
8	return CONCAT22((short)(uVar8 >> 0x10),0xd755);
8	*param_2 = 6;
8	*param_2 = 7;
8	return -0x28c9;
8	if (*(short *)(&DAT_2120f8de + (short)uVar1 * 0x7a) == 4) {
8	if ((short)param_7 != 0) {
8	iVar3 = 10;
8	iVar3 = 1000;
8	sVar2 = FUN_2104a3a0(param_1);
8	uVar16 = uVar14;
8	if (sVar9 < 1) {
8	uVar7 = FUN_21136310(*(undefined4 *)(param_8 + 0x266));
8	iVar13 = (int)(short)local_10;
8	uVar7 = FUN_211362e0(0x2040,iVar13 << 1);
8	iVar10 = FUN_21136300(uVar7);
8	*(undefined2 *)puVar11 = 1;
8	local_18 = (uint)(short)param_2;
8	*puVar11 = 0x10001;
8	uVar14 = FUN_21185030(*(undefined4 *)(param_8 + 0xc),0);
8	uVar7 = *(undefined4 *)(param_8 + 0xc);
8	*(byte *)(param_8 + 0x356) = bVar12;
8	FUN_211850f0(*(undefined4 *)(param_8 + 0xc),1,0);
8	sVar6 = (short)param_5;
8	*(byte *)(iVar4 + 0x357) = bVar12;
8	FUN_211850f0(*(undefined4 *)(iVar4 + 0xc),5,(int)(char)bVar12);
8	*(byte *)(iVar4 + 0x356) = bVar12;
8	FUN_211850f0(*(undefined4 *)(iVar4 + 0xc),7,(int)(char)bVar12);
8	uVar16 = FUN_21185030(*(undefined4 *)(iVar4 + 0xc),0);
8	param_7 = 1;
8	if (iVar5 == -1) {
8	FUN_210062e0(uVar2);
8	case 0x99:
8	iVar1 = FUN_21184f00((int)param_1,0,4,0);
8	uVar2 = FUN_21184e80(iVar1);
8	*(undefined2 *)(param_2 + 4) = 0x21;
8	*(undefined2 *)(param_2 + 4) = 0x1e;
8	*(undefined2 *)(param_3 + 4) = 0x21;
8	*(undefined2 *)(param_3 + 4) = 0x1f;
8	*(undefined2 *)(param_2 + 4) = 0x17;
8	*(ushort *)(param_2 + 2) = *(ushort *)(param_2 + 2) & 0xfffd | 0xd;
8	*(ushort *)(param_3 + 2) = *(ushort *)(param_3 + 2) & 0xfffd | 0xd;
8	*(byte *)(param_3 + 2) = *(byte *)(param_3 + 2) | 7;
8	byte *pbVar12;
8	if ((((short)param_6 == 0) && (*(short *)(param_2 + 0x13a) == 1)) &&
8	(*(short *)(param_2 + 0x254) != 0)) {
8	iVar8 = FUN_21136300(local_20);
8	FUN_21136340(local_20);
8	for (uVar10 = uVar6 * 2 >> 2; uVar10 != 0; uVar10 = uVar10 - 1) {
8	sVar3 = (short)local_8;
8	if (sVar3 == 0x12) {
8	uVar7 = FUN_21136310(uVar7);
8	_param_10 = 0;
8	uVar6 = FUN_2103d030(local_10);
8	uVar6 = FUN_2103d030(local_24);
8	uVar5);
8	else if (sVar1 == 0x10) {
8	*(ushort *)(iVar2 + 0x423) = uVar5;
8	goto LAB_21060762;
8	uVar5 = (ushort)((param_5 << 3 | param_6) << 3);
8	uVar4 = (ushort)(byte)(((-(sVar2 != 1) & 0xfcU) + 4) * ' ' | bVar3) << 8;
8	if ((sVar1 != 1) && (sVar1 != 0xf)) {
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),iVar6,0xff04);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),iVar5,(int)(short)param_5);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),iVar6,0xff48);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),iVar5,0);
8	*(undefined1 *)(param_1 + 0x3fc) = 4;
8	param_4 = 2;
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),iVar6,0xff03);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),iVar6,0xff0b);
8	iVar2 = 0x14;
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),iVar1,0xff0a);
8	if ((param_2 < 0x10001) || ((*(short *)(iVar1 + 0x146) != 0 && (*(short *)(iVar1 + 0x142) == 0))))
8	*(ushort *)(iVar1 + 0x41b) = uVar3;
8	if (*(short *)(iVar1 + 0xa6) == 0) {
8	if ((((param_3 == 0) && (param_4 == 0)) || (*(short *)(iVar1 + 0x13c) != 1)) ||
8	uVar3 = uVar3 | 8;
8	uVar3 = uVar3 | 0x10;
8	if ((short)param_6 != 0) {
8	if (param_1 == 6) {
8	FUN_21185130(uVar6,uVar7,(int)sVar2);
8	uVar7 = 6;
8	*pbVar1 = *pbVar1 | 1;
8	sVar6 = sVar3;
8	sVar15 = (short)param_2;
8	*param_6 = sVar5;
8	if (0x7fff < uVar9) {
8	*param_7 = (short)uVar9;
8	uVar7 = FUN_211362e0(0x2040,iVar13);
8	psVar2 = param_5;
8	if (1 < sVar15) {
8	param_6 = (short *)0x0;
8	iVar10 = 1;
8	pbVar1[1] = 0;
8	param_6 = (short *)((int)param_6 + 1);
8	} while (local_20 != 0);
8	uVar1 = *(ushort *)(param_2 + -2 + (short)param_1 * 2);
8	sVar2 = (short)(param_1 + -2);
8	iVar6 = uVar3 + 1;
8	psVar7 = (short *)(param_2 + uVar3 * 2);
8	uVar8 = (uint)uVar1;
8	iVar4 = (int)(short)uVar8 / (int)sVar2;
8	sVar2 = (short)iVar4 * *psVar7;
8	uVar5 = (undefined2)((uint)iVar4 >> 0x10);
8	uVar3 = CONCAT22(uVar5,sVar2);
8	psVar7 = psVar7 + -1;
8	uVar8 = uVar3;
8	return CONCAT22(uVar5,sVar2);
8	return CONCAT22((short)((uint)(param_1 + -2) >> 0x10),uVar1);
8	uVar2 = (int)(short)param_1 % (int)(short)param_2;
8	param_2 = uVar2;
8	iVar2 = FUN_2104a070(param_1,&local_8);
8	iVar2 = FUN_21082970(iVar3,&param_1);
8	if (-1 < (short)iVar2) {
8	sVar1 = FUN_210990d0(CONCAT22(extraout_var,*(undefined2 *)(param_1 + 0x11)));
8	return (int)(short)iVar2;
8	dVar1 = 0.001;
8	dVar1 = 2e-07;
8	if ((double)param_5 * dVar2 < dVar1) {
8	return CONCAT22(uVar3,0xd894);
8	sVar2 = FUN_21064870(param_1,&param_1,0x4c);
8	sVar1 = *(short *)(&DAT_2120f8de + (short)iVar3 * 0x7a);
8	if ((sVar1 == 0xd) || (iVar3 = 0x18, sVar1 == 0xe)) {
8	iVar3 = 0x14;
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),iVar3 + 2,0xffc4);
8	FUN_21185130(*(undefined4 *)(param_1 + 0xc),iVar3 + 2,0xff24);
8	sVar1 = FUN_21064870(param_1,&local_8,0x4f);
8	if (*(short *)(local_8 + 0x14c) == 0) {
8	FUN_211850f0(*(undefined4 *)(local_8 + 0xc),1,(int)*(char *)(local_8 + 0xadf));
8	if (*(short *)(&DAT_2120f8de + (short)param_1 * 0x7a) != 8) {
8	sVar1 = FUN_21064870(param_1,&param_1,0x4f);
8	uVar6 = *puVar2;
8	puVar9 = (undefined2 *)(uVar6 & 0xff);
8	puVar9 = (undefined2 *)(uint)bVar3;
8	uVar6 = (uint)puVar9 & 1;
8	sVar4 = (short)uVar6;
8	if ((~bVar4 & 2) == 0) {
8	if ((bVar4 & 1) == 0) {
8	sVar1 = param_3[1];
8	if (*(short *)(iVar6 + 0x155) == 0) {
8	if (*(short *)(iVar6 + 0x15d) != 0xff) {
8	iVar6 = (int)param_3[1];
8	if (param_3[1] < 0) {
8	if ((sVar1 != 0) && (sVar1 != 1)) {
8	if (*(short *)(iVar6 * 0x10 + 0x15d + iVar3) != 0xff) {
8	if (param_3[6] == 0) {
8	uVar5 = 0xd75d;
8	undefined1 local_1c [16];
8	if (_DAT_2120b704 == -1) {
8	case 0x7c:
8	undefined2 local_28 [16];
8	lpOutBuffer = local_28;
8	lpInBuffer = local_28;
8	local_24 = 3;
8	undefined4 local_1a;
8	local_1a = param_3;
8	return local_1a;
8	local_24 = 6;
8	*param_2 = local_1c;
8	*param_4 = local_18;
8	local_24 = 8;
8	FUN_2106aba0();
8	iVar2 = local_10;
8	if (((((sVar6 == 0) &&
8	sVar6 == 0 &&
8	sVar2 = FUN_2116328b(param_1,0,&local_c);
8	iVar1 = *(int *)(param_6 + 0x1c6);
8	*(undefined1 *)(param_6 + 0x1ca) = 0;
8	if ((param_5 != 0) && (sVar2 == 0)) {
8	if ((sVar3 == 0) &&
8	piVar7 = param_2;
8	param_5 = 2;
8	sVar3 = FUN_21067100(local_c,4,local_40[iVar8],
8	sVar3 = FUN_21067100(local_c,4,local_40[iVar8] >> 1,
8	local_10 = uVar10;
8	uVar5 = uVar6;
8	if (*(char *)(iVar2 + 0x2d) != '\0') {
8	iVar9 = param_5 - 4;
8	local_18 = local_34;
8	local_1c = local_38;
8	psVar4 = param_7;
8	if (extraout_AX == 0) {
8	iVar3 = (int)param_4;
8	sVar1 = FUN_2116328b(param_1,0,&param_1);
8	sVar3 = FUN_2106aa40(param_1,4,uVar1,0x57e,puVar2);
8	sVar2 = FUN_2106aa40(param_1,8,DAT_21219160,0x57e,puVar1);
8	if (param_5 == 0xb) {
8	uVar3 = 7;
8	sVar2 = FUN_2106aa40(param_1,10,DAT_21219160,0x57e,puVar1);
8	puVar6 = DAT_212191c0;
8	*(undefined4 *)(puVar1 + 3) = param_6;
8	uVar1 = *param_5;
8	sVar3 = FUN_2106aa40(param_1,4,DAT_21219160,0x57e,puVar2);
8	*param_3 = *(undefined2 *)((int)DAT_212191c0 + 3);
8	sVar3 = FUN_2106aa40(param_1,2,DAT_21219160,0x57e,puVar2);
8	puVar4 = puVar4 + 2;
8	*(undefined1 *)puVar4 = *(undefined1 *)param_3;
8	*param_4 = *(undefined4 *)((int)DAT_212191c0 + 3);
8	if (((sVar2 == 1) || (sVar2 == 0xf)) || (sVar2 == 6)) {
8	uVar12 = *(undefined4 *)(param_1 + 0xc);
8	uVar9 = 8;
8	*(ushort *)(param_1 + 0x421) = *(ushort *)(param_1 + 0x421) & 0x3fff;
8	FUN_21042be0(iVar3,4,CONCAT22(extraout_var,*(undefined2 *)(iVar3 + 0x39c)),1);
8	ushort uVar19;
8	sVar8 = FUN_21068f00(*(undefined4 *)(local_8 + 0x435),param_3);
8	sVar8 = FUN_21068f20(*(undefined4 *)(local_8 + 0x435),param_3);
8	sVar8 = FUN_21068f00(*(undefined4 *)(local_8 + 0x431),local_c);
8	FUN_21068f60(param_1,local_8,*(undefined4 *)(local_8 + 0x431),*(undefined4 *)(local_8 + 0x435)
8	goto LAB_210683d0;
8	sVar11 = FUN_210690a0(param_3,1);
8	uVar14 = FUN_21068ee0(param_2,param_3);
8	uVar14 = FUN_21068eb0(param_2,param_3,1);
8	sVar11 = FUN_21068f00(*(undefined4 *)(local_8 + 0x3c0),param_2);
8	return (-(uint)(param_3 != 1) & 0x2974) - 0x2974;
8	uVar10 = 1;
8	if ((sVar11 == 2) || (sVar11 == 5)) {
8	((cVar1 = *(char *)(*(char *)(local_8 + 0x42e) * 0x10 + 0x3bc + local_8), cVar1 == '\x05'
8	} while ((short)iVar18 < 7);
8	if (sVar11 == 3) {
8	uVar10 = uVar5;
8	else if (param_3 == 0) {
8	iVar1 = iVar4 * 0x7a;
8	return 0xffffd8a0;
8	iVar1 = *(int *)(*(int *)(&DAT_2120f937 + (short)uVar2 * 0x7a) + 0x2ef);
8	puVar6 = (undefined4 *)(iVar1 + 0xac);
8	*puVar7 = *puVar6;
8	if (*param_1 == 0x18) {
8	*puVar6 = *puVar5;
8	short local_58 [16];
8	undefined1 local_1c [6];
8	psVar9 = psVar9 + 2;
8	local_28 = (int)param_3;
8	local_2e = param_2 + -1;
8	local_2a = param_5;
8	short local_34 [5];
8	uVar2 = FUN_21145a80(local_34,local_18);
8	short local_3c [5];
8	undefined1 local_20 [6];
8	local_3c[0] = (short)param_1;
8	if (*(int *)(iVar1 + 99) == 0) {
8	uVar2 = 0xd5c6;
8	uVar2 = FUN_21145490(local_3c,local_20);
8	puVar2 = (undefined2 *)FUN_21136280(iVar1);
8	sVar1 = *(short *)(iVar3 + 2);
8	uVar2 = *(undefined2 *)(&DAT_2120f8de + iVar4);
8	uVar5 = FUN_211657e0(iVar3,sVar1,uVar2,uVar5);
8	*(undefined2 *)(param_1 + 0x2c) = 0x10;
8	*(undefined2 *)(param_1 + 0x2e) = 0x20;
8	*(undefined2 *)(param_1 + 0x30) = 0x40;
8	*(undefined2 *)(param_1 + 0x38) = 0x80;
8	uVar3 = FUN_21165100(param_1);
8	if (*(short *)(&DAT_2120f8e0 + param_1 * 0x7a) == 0x1e) {
8	FUN_211850f0(*(undefined4 *)(iVar1 + 0xc),0x13,*(undefined1 *)(iVar1 + 0x4d7));
8	FUN_211850f0(*(undefined4 *)(iVar1 + 0xc),0x11,(int)*(short *)(iVar1 + 0x626));
8	iVar1 = *(int *)(&DAT_2120f937 + (short)param_2 * 0x7a);
8	*(undefined4 *)(param_1 + 0x40) = uVar2;
8	if (*(int *)(&DAT_2120f937 + param_1 * 0x7a) != 0) {
8	if (*psVar1 == 3) {
8	psVar1 = psVar1 + 8;
8	while ((bVar3 != 0 || (param_2 != 0))) {
8	~*(ushort *)(param_1 + 0x38) & uVar5);
8	bVar2 = FUN_21185030(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x32));
8	if (((*(byte *)(param_1 + 0x34) & bVar2) != 0) && (param_4 != 0)) {
8	*(byte *)(param_4 + (uint)param_2) = *(byte *)(param_4 + (uint)param_2) | bVar3;
8	uVar4 = FUN_211850f0(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x2a),uVar5 | uVar1
8	**(ushort **)(param_1 + 0x26) = uVar5 | uVar1;
8	uVar4 = **(ushort **)(param_1 + 0x26);
8	uVar4 = uVar4 & ~*(ushort *)(param_1 + 0x2c);
8	uVar4 = uVar4 | *(ushort *)(param_1 + 0x2c);
8	~*(ushort *)(param_1 + 0x38) & uVar4);
8	if ((*(byte *)(param_1 + 0x34) & bVar3) == 0) {
8	if (49999 < uVar5) break;
8	} while ((*(byte *)(param_1 + 0x34) & bVar3) == 0);
8	if (uVar5 == 50000) {
8	uVar2 = 0xd5d0;
8	FUN_211850f0(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x2a),uVar4 | uVar1);
8	**(ushort **)(param_1 + 0x26) = uVar4 | uVar1;
8	uVar6 = **(ushort **)(param_1 + 0x26);
8	uVar6 = uVar6 & ~*(ushort *)(param_1 + 0x2c);
8	uVar6 = uVar6 | *(ushort *)(param_1 + 0x2c);
8	~*(ushort *)(param_1 + 0x38) & uVar6);
8	FUN_21185030(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x32));
8	if (((*(byte *)(param_1 + 0x34) & bVar3) != 0) && (param_4 != 0)) {
8	FUN_211850f0(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x2a),uVar6 | uVar1);
8	puVar2 = *(ushort **)(param_1 + 0x26);
8	*puVar2 = uVar6 | uVar1;
8	uVar1 = FUN_211850f0(*(undefined4 *)(param_1 + 0x40),param_2,uVar2);
8	bVar1 = FUN_21185030(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x32));
8	uVar2 = (ushort)((bVar1 & *(byte *)(param_1 + 0x34)) != 0);
8	if (uVar2 == 1) break;
8	~*(ushort *)(param_1 + 0x38) & uVar1);
8	uVar2 = FUN_211850f0(*(undefined4 *)(param_1 + 0x40),*(undefined2 *)(param_1 + 0x2a),uVar1);
8	if (DAT_2121a068 == (HANDLE)0x0) {
8	return 0xffffd544;
8	return DVar1 & 0xffff0000;
8	HANDLE hEvent;
8	SetEvent(hEvent);
8	for (iVar2 = 0x10; iVar2 != 0; iVar2 = iVar2 + -1) {
8	FUN_21064d20(param_1,(int)&param_1 + 2);
8	FUN_2106ab00();
8	uVar6 = (undefined2)((uint)in_ECX >> 0x10);
8	sVar8 = (short)uVar3;
8	uVar6 = (undefined2)((uint)uVar5 >> 0x10);
8	*(undefined4 *)(param_1 + 0x20) = uVar2;
8	FUN_2106b050(param_1);
8	uVar4 = param_2 + 0xffff;
8	*(undefined1 *)((uVar4 & 0xffff) + param_4) = 0;
8	param_2 = CONCAT22(param_2._2_2_,*puVar2);
8	param_2 = param_2 | CONCAT22((short)((uint)param_3 >> 0x10),*(undefined2 *)(param_1 + 0x2c));
8	FUN_2106b720(*(undefined2 *)(param_1 + 0x2a),param_2);
8	FUN_2106b820(CONCAT22(extraout_var,*(undefined2 *)(param_1 + 0x36)));
8	puVar2 = extraout_EDX;
8	if (((*(ushort *)(param_1 + 0x34) & uVar1) != 0) && (param_4 != 0)) {
8	uVar4 = uVar4 + 0xffff;
8	**(undefined2 **)(param_1 + 0x26) = (undefined2)param_2;
8	puVar3 = *(undefined2 **)(param_1 + 0x26);
8	uVar4 = (undefined2)((uint)puVar3 >> 0x10);
8	uVar6 = uVar6 | CONCAT22(uVar4,*(undefined2 *)(param_1 + 0x2c));
8	bVar1 = bVar1 >> 1;
8	uVar1 = (undefined2)((uint)in_ECX >> 0x10);
8	uVar1 = extraout_var;
8	if ((*(short *)(iVar1 + 0x3ab) != 0) && (*(short *)(iVar1 + 0x3ab) != 3)) {
8	*(undefined2 *)(iVar1 + 0x3ab) = 3;
8	FUN_21082970(param_1,&local_8);
8	sVar1 = FUN_21142800(param_1);
8	iVar2 = *(int *)(&DAT_2120f937 + (short)param_1 * 0x7a);
8	sVar4 = (short)uVar2;
8	iVar1 = *(int *)(&DAT_2120f937 + sVar4 * 0x7a);
8	uVar3 = FUN_210039d0((int)sVar6,0x2009,local_2c);
8	puVar6 = param_7;
8	puVar1);
8	*param_3 = 0xffffffff;
8	pbVar4 = (byte *)&param_2;
8	uVar3 = uVar3 << 8 | (uint)*pbVar4;
8	for (uVar3 = (param_2 & 0xffff) >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
8	param_11,1);
8	return CONCAT44(uVar3,2);
8	int local_2c [10];
8	iVar4 = param_1 * 0x7a;
8	sVar2 = 2;
8	iVar5 = *piVar3;
8	sVar5 = (-(ushort)(*(short *)(&DAT_2120f8e0 + iVar8) != 0xf) & 4) + 6;
8	iVar8 = 0xfff;
8	iVar4 = iVar8;
8	bVar14 = uVar13 == 0;
8	if ((int)uVar13 < 0) {
8	bVar14 = (uVar13 - 1 | 0xfffffffe) == 0xffffffff;
8	if ((0 < sVar2) && (sVar2 < 4)) {
8	return CONCAT22(sVar2 >> 0xf,0xd8ed);
8	int aiStackY_20048 [32758];
8	int local_48 [10];
8	sVar10 = 2;
8	else if ((short)local_14 == 1) {
8	if (*(char *)(local_c + 0xa86) != '\0') {
8	*(undefined2 *)(local_c + 0x43b) = 2;
8	iVar6 = (int)sVar10;
8	iVar7 = (int)sVar10;
8	if ((*(char *)(local_48[sVar2] + 0x45) == sVar4) &&
8	iVar6 = param_3;
8	if ((((short)local_10 == 4) && (*(short *)(iVar6 + 0x10) == 0x21)) &&
8	FUN_21073bc0(param_1,local_c,local_48,param_2,0);
8	uVar9 = extraout_var_04;
8	*(short *)(param_1 + 0x441) = (short)param_5;
8	*(uint *)(param_1 + 0x447) = param_4;
8	*(short *)(param_1 + 0x43f) = param_3;
8	iVar6 = iVar6 + 0x51;
8	if ((*(char *)(local_1c[sVar10] + 0x45) == '\x01') &&
8	if (local_6 == '\0') {
8	psVar4 = local_c;
8	sVar10 = *local_c;
8	*(undefined4 *)(param_1 + 0x447) = param_5;
8	if (((sVar10 == 4) && (*(short *)(param_1 + 0x10) == 0x21)) &&
8	if (param_2 == -2) {
8	local_18 = (*DAT_21214104)(0x1001,param_1);
8	if ((short)local_18 == -0x2a3a) {
8	else if ((short)local_18 == 1) {
8	iVar13 = 2;
8	if (((*(char *)(uVar6 + 0x43) != '\0') && (*(char *)(uVar6 + 0x45) == sVar3)) &&
8	(*(char *)(uVar6 + 0x46) == '\x01')) {
8	if (sVar12 == -2) {
8	return -0x296a;
8	return -0x296b;
8	uVar10 = (undefined2)((uint)puVar8 >> 0x10);
8	iVar2 = (short)param_1 * 0x7a;
8	switch(*(undefined2 *)(&DAT_2120f8de + iVar2)) {
8	*piVar6 = iVar2;
8	iVar2 = iVar2 + 0x51;
8	sVar9 = 2;
8	} while (sVar5 < sVar9);
8	if (sVar4 == 0x12) {
8	local_5 = *(char *)(iVar9 + 0x46);
8	iVar9 = param_3;
8	if (*(char *)(iVar9 + 0x45) == '\x01') {
8	bVar3 = *(byte *)((int)piVar12 + 10);
8	if ((*(char *)(local_2c[sVar7] + 0x45) == sVar9) &&
8	} while (sVar7 < sVar3);
8	FUN_21073bc0(param_1,param_2,local_2c,param_3,1);
8	uVar4 = FUN_2106f730(param_1,param_2,param_3);
8	goto LAB_21070622;
8	iVar1 = iVar7 * 0x7a;
8	if ((*(char *)(iVar5 + 0x43) != '\x01') && (*(char *)(iVar5 + 0x43) != '\x03')) {
8	cVar8 = *(char *)(iVar5 + 0x46);
8	bVar2 = *(byte *)((int)piVar9 + 10);
8	*(undefined1 *)((int)piVar9 + 0xd) = 1;
8	short *local_34;
8	iVar11 = 2;
8	iVar1 = local_14;
8	if (5 < (short)uVar5) {
8	*(ushort *)(local_c + 0xa8e) = uVar4;
8	puVar12 = (ushort *)*puVar13;
8	bVar3 = (byte)puVar12[5];
8	puVar12 = (ushort *)puVar13[1];
8	puVar12 = param_3;
8	local_10 = -0x2a33;
8	if (local_20 == 6) {
8	uVar8 = FUN_21185070(*(undefined4 *)(local_c + 0xc),0);
8	*(undefined2 *)(local_c + 0x427) = uVar8;
8	*(undefined1 *)(puVar13 + 8) = 4;
8	*param_4 = uVar10;
8	iVar5 = iVar4 * 0x7a;
8	local_10 = (*DAT_21214104)(0x1001,param_1);
8	if ((short)local_10 == -0x2a3a) {
8	else if ((short)local_10 == 1) {
8	*piVar7 = iVar4;
8	*(short *)(param_2 + 0x30) = (short)param_3;
8	local_18 = (*DAT_21214114)(0x8a,iVar1);
8	if (local_14 == 6) {
8	piVar6 = local_48;
8	} while (sVar8 < sVar10);
8	} while (sVar3 < sVar10);
8	undefined4 param_6,undefined4 param_7,undefined4 param_8)
8	sVar3 = *(short *)(&DAT_2120f8de + (short)param_1 * 0x7a);
8	if ((short)local_20 == 10) {
8	FUN_21007aa0(param_1,local_c,0);
8	if (sVar3 < 0) goto LAB_21071a13;
8	uVar9 = local_24;
8	local_14 = local_18;
8	return -0x2a61;
8	uVar8 = FUN_21136310(param_4);
8	_close(local_28);
8	if ((short)local_10 == 6) {
8	if ((sVar5 != 0) && (sVar5 != 0x28ce)) goto LAB_210723f0;
8	if (sVar5 < 0) goto LAB_210723f0;
8	_lseek(local_28,iVar7,0);
8	iVar7 = FUN_21183e00(local_78);
8	if (iVar7 != 0) goto LAB_21072354;
8	&local_8,local_4c,local_54);
8	} while (sVar4 < sVar3);
8	uVar13 = FUN_21042d00(local_14,10,0);
8	if ((uVar13 & 0x20) == 0) {
8	goto LAB_2107239b;
8	uVar13 = FUN_21185070(*(undefined4 *)(local_18 + 0xc),0);
8	uint param_6)
8	uint *local_24;
8	iVar8 = local_10 + 0x305;
8	*piVar10 = iVar7;
8	cVar1 = *(char *)(local_60[*param_3] + 0x45);
8	if (cVar1 != *(char *)(local_60[param_3[sVar5]] + 0x45)) {
8	} while (sVar5 < sVar6);
8	if (cVar1 != '\x01') goto LAB_210728e1;
8	local_5 = cVar1;
8	bVar2 = *(byte *)((int)piVar10 + 10);
8	piVar10 = (int *)local_14[1];
8	uVar9 = FUN_21185070(*(undefined4 *)(local_10 + 0xc),0);
8	return local_a;
8	uVar9 = FUN_2104ca00(param_1,local_10,puVar13);
8	*(undefined1 *)((int)local_14 + 0x2e) = 0;
8	*(byte *)(param_2 + 0x41d) = *(byte *)(param_2 + 0x41d) & 0xbf;
8	FUN_21042900(param_2,0,0x40);
8	FUN_21042900(param_2,0x40,0);
8	(*DAT_21214114)(0x8a,param_1);
8	*(byte *)(param_2 + 0x41d) = *(byte *)(param_2 + 0x41d) | 0x40;
8	} while (sVar2 < 2);
8	if (param_4._2_2_ != 0) {
8	*(byte *)(param_2 + 0x421) = *(byte *)(param_2 + 0x421) & 0x7f;
8	char cVar9;
8	FUN_21185130(*(undefined4 *)(param_2 + 0xc),iVar16,uVar11);
8	uVar10 = uVar10 | 0xff40;
8	FUN_21185130(*(undefined4 *)(param_2 + 0xc),iVar16,uVar10);
8	FUN_21041e40(param_1,param_2);
8	if ((sVar18 == 1) || (sVar18 == 0xf)) {
8	if (sVar4 == -1) {
8	if (sVar18 == 0) {
8	uVar12 = uVar12 - 1;
8	sVar18 = (short)uVar12;
8	*(byte *)(param_2 + 0xadf) = bVar15;
8	uVar12 = FUN_211850f0(*(undefined4 *)(param_2 + 0xc),1,(int)(char)bVar15);
8	FUN_211850f0(*(undefined4 *)(param_2 + 0xc),0x17,0xb4);
8	*(undefined1 *)(iVar20 + 0x388) = 0;
8	*(undefined1 *)(iVar20 + 0x389) = 0;
8	FUN_21042980(iVar20,9,0xb8,0);
8	param_1 = uVar12;
8	uVar10 = uVar21;
8	if (0xffff < uVar10) {
8	uVar21 = uVar21 * 10;
8	return CONCAT22(uVar14,0xd755);
8	FUN_21042980(iVar20,8,0,0);
8	FUN_21185130(*(undefined4 *)(iVar1 + 0xc),0x16,1 << ((char)param_2 - 1U & 0x1f) | 0xffc0);
8	FUN_21185130(*(undefined4 *)(iVar1 + 0xc),0x16,1 << ((char)param_2 - 1U & 0x1f) | 0xff40);
8	if ((*(char *)(param_1 + 0x3cc) == '\0') || (*(char *)(param_1 + 0x3cc) == '\n')) {
8	FUN_21185130(*(undefined4 *)(param_2 + 0xc),0x16,0xffc2);
8	FUN_21185130(*(undefined4 *)(param_2 + 0xc),0x16,0xff0a);
8	FUN_21185130(*(undefined4 *)(param_2 + 0xc),0x16,0xff02);
8	FUN_21185130(*(undefined4 *)(param_2 + 0xc),iVar1,uVar7);
8	FUN_21185130(*(undefined4 *)(param_2 + 0xc),iVar1,uVar6);
8	*pcVar8 = '\0';
8	_param_3 = _param_3 + 1;
8	if (5 < sVar5) {
8	uVar9 = *(undefined4 *)(param_2 + 0xc);
8	FUN_21042980(param_2,6,0,1);
8	FUN_21042980(param_2,7,0,1);
8	FUN_21042980(param_2,8,0,0);
8	sVar2 = *(short *)(&DAT_2120f8de + param_1 * 0x7a);
8	if (((&DAT_2120f8e8)[iVar1] != -1) && (*(int *)(&DAT_2120f8f0 + iVar1) == 0x8980)) {
8	FUN_21077c20(param_2,0,0);
8	FUN_21185030(*(undefined4 *)(param_2 + 0xc),0x1e);
8	if ((*(char *)(*param_3 + 0x44) == '\0') || (*(char *)(param_3[1] + 0x44) == '\0')) {
8	if (*(char *)(*param_3 + 0x3f) == '\0') {
8	iVar5 = (-(uint)(*(char *)(param_3[1] + 0x43) != '\0') & 2) + 1;
8	FUN_2104d230(param_1,iVar5);
8	FUN_211850f0(*(undefined4 *)(param_2 + 0xc),1,(int)*(char *)(param_2 + 0xadf));
8	char cVar6;
8	local_1c = iVar8;
8	FUN_21042980(iVar3,9,0x18,0);
8	*(ushort *)(param_2 + 0x41d) = *(ushort *)(param_2 + 0x41d) | 0x8000;
8	cVar6 = '\x06';
8	cVar6 = (-(*(char *)(param_3[1] + 0x43) != '\0') & 2U) + 5;
8	FUN_2104d230(param_1,cVar6);
8	*(byte *)(param_2 + 0x41c) = *(byte *)(param_2 + 0x41c) | 8;
8	undefined2 local_86;
8	int *local_28;
8	local_20 = (undefined2 *)(param_2 + 0x41d);
8	piVar7 = (int *)0x41d;
8	piVar9 = param_4;
8	piVar7 = param_4;
8	if (2 < sVar6) {
8	uVar15 = 0x20;
8	local_c = 0x22;
8	case 0xff:
8	piVar7 = (int *)local_14[1];
8	piVar14[1] = (int)piVar7;
8	piVar7 = (int *)*local_14;
8	*piVar14 = (int)piVar7;
8	*(undefined4 *)((int)piVar9 + 0x1f) = 0;
8	local_18 = local_18 + 2;
8	if (sVar6 < 3) {
8	*puVar1 = *puVar1 & ~uVar7;
8	sVar4 = (short)(char)(&DAT_2120f8e6)[iVar3 * 0x7a];
8	switch(*(undefined2 *)(&DAT_2120f8de + iVar3 * 0x7a)) {
8	sVar5 = (short)param_1 + -1;
8	switch(sVar10) {
8	local_3e = local_c;
8	local_3e = local_10;
8	FUN_2104e0b0(&local_44,puVar3,iVar9);
8	uVar8 = FUN_21136200(local_18);
8	uVar8 = FUN_21136200(puVar3);
8	*(undefined1 *)(iVar9 + 0xf) = 0;
8	bVar5 = FUN_211327a0(&local_44,1);
8	uVar6 = FUN_21132800(&local_44,1);
8	*(undefined1 *)(iVar9 + 0x2f) = uVar6;
8	*(undefined1 *)(iVar9 + 0x29) = 1;
8	*(ushort *)(iVar9 + 0x22) = local_44;
8	*(undefined1 *)(iVar9 + 0x48) = (undefined1)local_42;
8	*(undefined1 *)(iVar9 + 5) = (undefined1)local_1c;
8	*(undefined1 *)(iVar9 + 0x31) = (undefined1)param_4;
8	iVar7 = local_c;
8	sVar8 = -1;
8	local_5 = false;
8	bVar14 = false;
8	FUN_21183d20(local_44,2,3);
8	piVar9 = local_c;
8	cVar1 = (char)local_c[8];
8	(iVar11 = FUN_21183e00(local_44), iVar11 == 0))) {
8	cVar1 = (char)piVar9[8];
8	iVar11 = FUN_21183e00(local_44);
8	local_14 = (int)param_1;
8	uVar7 = (uint)sVar5;
8	goto LAB_21077bdf;
8	*(ushort *)(iVar1 + 0x421) = uVar2;
8	puVar2 = (ushort *)(iVar1 + -2 + iVar4 * 2);
8	sVar4 = *(short *)(&DAT_2120f8de + iVar2 * 0x7a);
8	if (sVar4 != 10) {
8	undefined **ppuVar3;
8	ppuVar3 = ppuVar3 + 1;
8	FUN_21078070(0);
8	iSync_release(DAT_2121b220,0);
8	FUN_210023a0();
8	DWORD *pDVar8;
8	pDVar8 = &local_c;
8	DVar7 = 4;
8	puVar4 = &local_8;
8	DVar5 = 4;
8	DVar3 = 0xabcd2018;
8	puVar1 = DAT_2120d4e8;
8	if (*(uint *)(DAT_2120d4e8 + 8) != 0) {
8	piVar2 = (int *)((int)piVar2 + *(int *)(DAT_2120d4e8 + 4));
8	} while (uVar1 < *(uint *)(DAT_2120d4e8 + 8));
8	puVar3[1] = uVar1;
8	FUN_210789b0(3,0);
8	uVar2 = DVar1;
8	if ((*(DWORD *)((int)&DAT_2120e0ec + iVar3) == DVar1) &&
8	(uVar2 = 0, *(code **)((int)&DAT_2120d4ec + iVar3) != (code *)0x0)) {
8	uVar2 = (**(code **)((int)&DAT_2120d4ec + iVar3))(iVar4 + 1);
8	} while (iVar4 < 0x40);
8	} while (iVar3 < 0xc00);
8	(**(code **)(*param_1 + 8))();
8	tPIMMblockReference_unlockBlock(&local_8);
8	if (((DAT_2121a06c != 0) && (DAT_2121a078 != 0)) && (DAT_2121a07c != 0)) {
8	undefined4 local_39;
8	if (puVar7 == (undefined4 *)0x0) {
8	local_2f = 1;
8	iVar5 = DAT_2121a06c;
8	sVar6 = *(short *)(iVar5 + 0x5d);
8	if (sVar6 == -1) {
8	*(undefined2 *)((int)puVar7 + 0x22) = 3;
8	*(short *)(puVar7 + 5) = sVar6;
8	goto LAB_21078e1a;
8	*(undefined2 *)(puVar7 + 5) = 1;
8	param_1._0_2_ = 0;
8	iVar6 = 3;
8	*param_2 = DAT_2120ecfc;
8	pcVar4 = param_1;
8	iVar2 = tPIMMblockReference_getPointer(&DAT_2120ecec);
8	return 0xd75e;
8	cVar1 = *pcVar4;
8	if (cVar1 == ':') {
8	goto LAB_21079194;
8	sVar1 = *(short *)(iVar2 + 10);
8	undefined1 local_44 [12];
8	local_38 = 0x28;
8	local_38 = cVar4;
8	puVar9 = param_2;
8	uVar4 = *param_2;
8	*(undefined4 *)((int)param_2 + 0xf) = *(undefined4 *)(iVar5 + 0x1b);
8	*(undefined2 *)((int)param_2 + 0xd) = *(undefined2 *)(iVar5 + 0x19);
8	if (DAT_2121a070 == (HANDLE)0x0) {
8	DAT_2121a06c = MapViewOfFile(DAT_2121a070,0xf001f,0,0,0);
8	if (DAT_2121a06c == (LPVOID)0x0) {
8	undefined2 local_37;
8	daqDevice *pdVar7;
8	*(undefined ***)in_ECX = &PTR_FUN_211dd400;
8	sVar3 = *param_2;
8	sVar3 = FUN_2104a070(param_1,pdVar7);
8	puVar2 = *(undefined2 **)pdVar7;
8	*(undefined2 *)(&DAT_2120f8de + iVar4) = *puVar2;
8	uVar1 = puVar2[6];
8	*(undefined2 *)(&DAT_2120f8e0 + iVar4) = puVar2[1];
8	*(undefined2 *)(&DAT_2120f8e2 + iVar4) = uVar1;
8	for (iVar4 = 8; iVar4 != 0; iVar4 = iVar4 + -1) {
8	uVar2 = FUN_210643c0(5,&local_8,&local_3c);
8	} while ((short)iVar3 < 8);
8	uVar1 = uVar1 & 0xfff;
8	if ((short)uVar1 == 0xff6) {
8	short local_1a;
8	if ((7 < param_2) && (param_2 < 0x10)) {
8	*param_3 = local_1a;
8	if (((param_2 != 0x3714) && (param_2 != 0x3476)) && (param_2 != 14000)) {
8	else if ((param_2 != 0x3778) && (param_2 != 0x37dc)) {
8	if (param_2 == 0x6784) {
8	*param_3 = (short)param_2._3_1_;
8	sVar3 = (**(code **)(*in_ECX + 0x40c))(param_1,&param_1,local_8,local_c);
8	if (((param_1 != 0) && (local_8[0] <= (short)param_2)) && ((short)param_2 <= local_c[0])) {
8	if ((sVar3 == 0) && (param_4._3_1_ != (char)uVar2)) {
8	sVar3 = -0x27d9;
8	*param_3 = local_8 & 0xffff;
8	*param_4 = local_c & 0xffff;
8	if (((short)local_8 == 0) && ((short)local_c == 0)) {
8	*(undefined ***)in_ECX = &PTR_FUN_211ddaa8;
8	pdVar7 = in_ECX + 0x220;
8	iVar4 = (int)sVar5;
8	*(undefined2 *)(in_ECX + iVar4 * 5 + 0x2f) = 0;
8	} while (sVar3 < 0x32);
8	if ((-1 < param_2) && (param_2 < 0x32)) {
8	sVar2 = param_2 * 2;
8	sVar2 = param_2 * 2 + 1;
8	*(byte *)(in_ECX + 0x2f6) = bVar1;
8	iVar2 = CONCAT22((short)((uint)in_EAX >> 0x10),(short)param_2);
8	return CONCAT22((ushort)(uVar3 >> 0x12),uVar5);
8	uint local_d0;
8	undefined4 local_1c [2];
8	iVar1 = *(int *)(in_ECX + iVar2 * 4 + 0x220);
8	local_c = &local_dc;
8	local_1c[0] = 1;
8	local_dc = 0;
8	local_d8 = 0;
8	local_d4 = 0x23;
8	local_c0 = 0;
8	local_bc = 0x20;
8	local_a4 = 0x21;
8	local_8c = 0x22;
8	local_74 = 0x23;
8	local_5c = 0x20;
8	local_44 = 0x21;
8	local_2c = 0x22;
8	local_58 = local_b8;
8	local_40 = local_a0;
8	local_28 = local_88;
8	return lVar4;
8	bVar1 = FUN_21185030(*(undefined4 *)(in_ECX + 0x2ec),param_2 * 2 + 0x29);
8	if (param_2 < 0x37dd) {
8	if (param_2 != 0x37dc) {
8	if (param_2 < 0x3b61) {
8	if (param_2 != 0xa474) {
8	FUN_21185130(param_1,param_2,0x52);
8	FUN_21185130(iVar1,uVar2,0x52);
8	} while (iVar4 == 0);
8	_param_1 = 9;
8	_param_1 = 8;
8	iVar5 = FUN_21184f00(iVar5,0,6,0);
8	FUN_211850f0(iVar5,_param_1 + 0x9a,0);
8	_param_1 = 4;
8	_param_1 = 2;
8	if (param_2 == 0x7aa8) {
8	_param_1 = 1;
8	_param_1 = 3;
8	if (param_3 < 0x7bd5) {
8	param_2 = 7;
8	puVar2 = (undefined4 *)*param_1;
8	if ((param_1 < 1) || (0x40 < param_1)) {
8	undefined4 local_35;
8	if (DAT_2120ed08 != (HANDLE)0x0) {
8	CloseHandle(DAT_2120ed08);
8	local_14 = iVar2;
8	cVar1 = '\0';
8	FUN_21185130(iVar4,0x75a,1);
8	FUN_21184e80(iVar4);
8	FUN_21185030(iVar4,0x80);
8	FUN_21183e60(0xf,2);
8	if (param_2 < 0xa9ed) {
8	if (param_2 == 0xa9ec) {
8	param_1 = param_1 & 0xfffffffb;
8	goto LAB_2107ced1;
8	FUN_2107ce00(param_1,uVar1,1);
8	*(byte *)(param_1 + 0x4a) = *(byte *)(param_1 + 0x4a) | 0x10;
8	FUN_2107ce00(param_1,param_2,1);
8	FUN_2107ce00(param_1,param_2,in_stack_00000018);
8	*(uint *)(param_1 + 0x3c) = uVar1;
8	if ((*(uint *)(param_1 + 0x44) < param_4) ||
8	((param_4 == *(uint *)(param_1 + 0x44) &&
8	((*(uint *)(param_1 + 0x40) < param_3 ||
8	((param_3 == *(uint *)(param_1 + 0x40) && (*(uint *)(param_1 + 0x3c) <= param_2)))))))) {
8	*(uint *)(param_1 + 0x40) = param_3;
8	*(uint *)(param_1 + 0x44) = param_4;
8	*(uint *)(param_1 + 0x44) = param_4 + 1;
8	if ((*(byte *)(param_1 + 0x4a) & 8) == 0) {
8	ushort param_5,undefined4 param_6)
8	uVar3 = FUN_2107d200(param_1,uVar2);
8	if (*(int *)(param_1 + 0x2a) != 0) {
8	uVar3 = *(int *)(param_1 + 0x2a) - 1;
8	if ((*(ushort *)(param_1 + 0x4a) & 2) != 0) {
8	*(ushort *)(param_1 + 0x4a) = *(ushort *)(param_1 + 0x4a) & 0xfffd | 4;
8	if ((uVar1 & 1) == 0) {
8	if ((uVar1 & 8) == 0) {
8	else if (param_5 < *(ushort *)(param_1 + 0x26)) {
8	uVar3 = uVar1 | 1;
8	*(short *)(param_1 + 0x4a) = (short)uVar3;
8	else if ((uVar1 & 8) == 0) {
8	else if (*(ushort *)(param_1 + 0x22) < param_5) {
8	*(ushort *)(param_1 + 0x4a) = uVar1 & 0xfffe;
8	if (*(int *)(param_1 + 0x3c) != 0) {
8	uVar3 = *(int *)(param_1 + 0x3c) - 1;
8	*(uint *)(param_1 + 0x3c) = uVar3;
8	*(undefined4 *)(param_1 + 0x3c) = *(undefined4 *)(param_1 + 0x32);
8	uVar3 = *(uint *)(param_1 + 0x2e);
8	*(byte *)(param_1 + 0x4a) = *(byte *)(param_1 + 0x4a) | 2;
8	uVar3 = CONCAT22((short)(uVar3 >> 0x10),uVar1);
8	if ((uVar1 & 4) == 0) {
8	uVar4 = CONCAT31((int3)(uVar3 >> 8),(char)uVar1) & 0xfffffffb;
8	*(short *)(param_1 + 0x4a) = (short)uVar4;
8	return CONCAT22((short)(uVar4 >> 0x10),1);
8	if (*(uint *)(param_1 + 0xc3) != 0) {
8	*in_ECX = &PTR_FUN_211de198;
8	*param_2 = (short)uStack_8._3_1_;
8	if (uStack_8._3_1_ != '\0') {
8	return CONCAT22(uVar2,(short)uVar1);
8	case 0x52fd:
8	goto switchD_2107d9ea_caseD_52da;
8	goto LAB_2107d9d0;
8	cVar2 = FUN_21080780(param_2);
8	if (*(char *)(param_1 + 0xb0) == '\x02') {
8	*(undefined1 *)(param_1 + 0xb0) = 1;
8	*(undefined1 *)(param_1 + 0xb0) = 0;
8	iVar3 = param_1 + 0x15;
8	FUN_21183d20(local_28,0x32,2);
8	uVar2 = FUN_2107e050(param_1,param_2,uVar2,0,0x3ff00000,0,0,param_3,param_4);
8	*(undefined1 *)(param_1 + 0x166) = 2;
8	FUN_2107f050(puVar1,0);
8	sVar3 = FUN_2107ea70(puVar1);
8	sVar2 = -0x2717;
8	if (0 < local_c) {
8	FUN_2107f050(iVar1,1);
8	*puVar3 = (char)param_2;
8	puVar3 = puVar3 + 0xb;
8	if (0 < *(short *)(param_1 + 0x96)) {
8	puVar4 = (undefined4 *)(param_1 + 0xbd);
8	} while ((short)iVar3 < 0x10);
8	iVar3 = 7;
8	uVar1 = (uint)(short)iVar2;
8	if ((-1 < param_2) && (param_2 < 8)) {
8	*param_2 = 0x66bc;
8	undefined8 uVar15;
8	char *local_14;
8	*(undefined4 *)((int)param_1 + 0x93) = 0;
8	local_14 = param_6;
8	param_4 = uVar6;
8	if (0 < *(short *)(param_1 + 0x81)) {
8	sVar1 = *(short *)(param_1 + 0x290);
8	*(undefined4 *)((int)param_1 + 0x87) = 0;
8	FUN_21184e80(*(undefined4 *)(param_1 + 2));
8	iVar3 = *(int *)(param_1 + 0x87);
8	*(undefined1 *)(param_1 + 0x9b) = 0;
8	*(undefined2 *)(param_1 + 0x213) = 1;
8	*(undefined1 *)(param_1 + 0x184) = 0;
8	*(undefined4 *)(param_1 + 0x1a5) = 0;
8	*(undefined4 *)(param_1 + 0x1a9) = 0;
8	*(undefined4 *)(param_1 + 0x1d7) = 0;
8	*(undefined1 *)(param_1 + 0x1db) = 0;
8	*(undefined4 *)(param_1 + 0x1dc) = 0;
8	*(undefined4 *)(param_1 + 0x1e0) = 0;
8	*(undefined4 *)(param_1 + 0x1e8) = 0;
8	*(undefined4 *)(param_1 + 0x1ec) = 0;
8	*(undefined4 *)(param_1 + 0x1f0) = 0;
8	*(undefined4 *)(param_1 + 0x1fc) = 0;
8	*(undefined4 *)(param_1 + 0x201) = 0;
8	*(undefined4 *)(param_1 + 0x205) = 0;
8	FUN_2100a860(CONCAT22(extraout_var_00,*param_1),local_30);
8	local_1c = 0x6982;
8	FUN_2100a860(CONCAT22(extraout_var,*param_1),local_30);
8	if (*(char *)(param_1 + 0x9b) != '\x03') {
8	*(undefined1 *)(param_1 + 0x9b) = 3;
8	*(undefined1 *)(param_1 + 0x9c) = 0;
8	*(undefined1 *)(param_1 + 0x9c) = 1;
8	bVar2 = bVar2 + 1;
8	undefined8 uVar12;
8	undefined2 local_3c [2];
8	if (local_2c == 5) {
8	iVar8 = (int)((ulonglong)uVar12 >> 0x20);
8	return (int)uVar12;
8	*(undefined4 *)(puVar5 + 0x35) = uVar7;
8	&local_1c);
8	if (local_70 == 0.0) {
8	local_28 = local_68;
8	puStack_24 = puStack_64;
8	goto LAB_2107f818;
8	puStack_24 = (undefined4 *)0x0;
8	} while (uVar11 < param_1);
8	if ((param_1 & 0x400) != 0) {
8	uVar3 = uVar3 & 0xffffff00;
8	*param_3 = 2e+07;
